```python
import pm4py
from pm4py.objects.petri_net.obj import PetriNet, Marking
from pm4py.objects.petri_net.utils import petri_utils

# 1. Create the Petri Net object
net = PetriNet("InsuranceClaimProcess")

# 2. Create Places (representing states between activities)
p_start = PetriNet.Place("p_start")  # Initial state: Claim Filed
p_registered = PetriNet.Place("p_registered") # State: Claim Registered, ready for DV
p_after_dv = PetriNet.Place("p_after_dv") # State: DV completed, decision needed (OK/NOK)
p_docs_ok_before_fc = PetriNet.Place("p_docs_ok_before_fc") # State: Docs OK, ready for FC
p_docs_nok_before_rds = PetriNet.Place("p_docs_nok_before_rds") # State: Docs NOK, ready for RDS
p_after_fc = PetriNet.Place("p_after_fc") # State: FC completed, decision needed (OK/NOK)
p_fraud_ok_before_ca = PetriNet.Place("p_fraud_ok_before_ca") # State: Fraud check OK, ready for CA
p_fraud_nok_before_ii = PetriNet.Place("p_fraud_nok_before_ii") # State: Fraud check NOK, ready for II
p_assessed = PetriNet.Place("p_assessed") # State: Claim Assessed, ready for threshold check
p_waiting_for_approval = PetriNet.Place("p_waiting_for_approval") # State: High amount, needs approval
p_payment_authorized = PetriNet.Place("p_payment_authorized") # State: Ready for Payment (either approved or low amount)
p_paid = PetriNet.Place("p_paid") # State: Payment completed, ready for Notification
p_notified = PetriNet.Place("p_notified") # State: Notification sent, ready for Closure
p_end = PetriNet.Place("p_end") # Final state: Claim Closed

# Add places to the net
places = [p_start, p_registered, p_after_dv, p_docs_ok_before_fc, p_docs_nok_before_rds,
          p_after_fc, p_fraud_ok_before_ca, p_fraud_nok_before_ii, p_assessed,
          p_waiting_for_approval, p_payment_authorized, p_paid, p_notified, p_end]
for p in places:
    net.places.add(p)

# 3. Create Transitions (representing activities)
t_CR = PetriNet.Transition(name="CR", label="Claim Registration")
t_DV = PetriNet.Transition(name="DV", label="Document Verification")
# Invisible transitions for DV outcome choice
t_Docs_OK = PetriNet.Transition(name="Docs_OK", label="Documents OK") # Could be invisible (label=None)
t_Docs_NOK = PetriNet.Transition(name="Docs_NOK", label="Documents NOK") # Could be invisible (label=None)
t_RDS = PetriNet.Transition(name="RDS", label="Re-Document Submission")
t_FC = PetriNet.Transition(name="FC", label="Fraud Check")
# Invisible transitions for FC outcome choice
t_Fraud_OK = PetriNet.Transition(name="Fraud_OK", label="Fraud Check OK") # Could be invisible (label=None)
t_Fraud_NOK = PetriNet.Transition(name="Fraud_NOK", label="Fraud Check NOK") # Could be invisible (label=None)
t_II = PetriNet.Transition(name="II", label="In-depth Investigation")
t_CA = PetriNet.Transition(name="CA", label="Claim Assessment")
# Invisible transitions for threshold check choice
t_Check_High = PetriNet.Transition(name="Check_High", label="Amount High") # Could be invisible (label=None)
t_Check_Low = PetriNet.Transition(name="Check_Low", label="Amount Low") # Could be invisible (label=None)
t_AP = PetriNet.Transition(name="AP", label="Approval")
t_P = PetriNet.Transition(name="P", label="Payment")
t_N = PetriNet.Transition(name="N", label="Notification")
t_CL = PetriNet.Transition(name="CL", label="Closure")

# Add transitions to the net
transitions = [t_CR, t_DV, t_Docs_OK, t_Docs_NOK, t_RDS, t_FC, t_Fraud_OK, t_Fraud_NOK,
               t_II, t_CA, t_Check_High, t_Check_Low, t_AP, t_P, t_N, t_CL]
for t in transitions:
    net.transitions.add(t)

# 4. Add Arcs (representing the process flow)

# Start -> CR -> Registered
petri_utils.add_arc_from_to(p_start, t_CR, net)
petri_utils.add_arc_from_to(t_CR, p_registered, net)

# Registered -> DV -> After DV Decision Point
petri_utils.add_arc_from_to(p_registered, t_DV, net)
petri_utils.add_arc_from_to(t_DV, p_after_dv, net)

# After DV Decision: OK or NOK
petri_utils.add_arc_from_to(p_after_dv, t_Docs_OK, net)
petri_utils.add_arc_from_to(t_Docs_OK, p_docs_ok_before_fc, net) # -> Ready for FC
petri_utils.add_arc_from_to(p_after_dv, t_Docs_NOK, net)
petri_utils.add_arc_from_to(t_Docs_NOK, p_docs_nok_before_rds, net) # -> Ready for RDS

# RDS Loop: Ready for RDS -> RDS -> Registered (back before DV)
petri_utils.add_arc_from_to(p_docs_nok_before_rds, t_RDS, net)
petri_utils.add_arc_from_to(t_RDS, p_registered, net) # Loop back to before DV

# Docs OK -> FC -> After FC Decision Point
petri_utils.add_arc_from_to(p_docs_ok_before_fc, t_FC, net)
petri_utils.add_arc_from_to(t_FC, p_after_fc, net)

# After FC Decision: OK or NOK
petri_utils.add_arc_from_to(p_after_fc, t_Fraud_OK, net)
petri_utils.add_arc_from_to(t_Fraud_OK, p_fraud_ok_before_ca, net) # -> Ready for CA
petri_utils.add_arc_from_to(p_after_fc, t_Fraud_NOK, net)
petri_utils.add_arc_from_to(t_Fraud_NOK, p_fraud_nok_before_ii, net) # -> Ready for II

# II Loop: Ready for II -> II -> Docs OK (back before FC)
petri_utils.add_arc_from_to(p_fraud_nok_before_ii, t_II, net)
petri_utils.add_arc_from_to(t_II, p_docs_ok_before_fc, net) # Loop back to before FC

# Fraud OK -> CA -> Assessed
petri_utils.add_arc_from_to(p_fraud_ok_before_ca, t_CA, net)
petri_utils.add_arc_from_to(t_CA, p_assessed, net)

# Assessed -> Threshold Check Decision Point
petri_utils.add_arc_from_to(p_assessed, t_Check_High, net)
petri_utils.add_arc_from_to(t_Check_High, p_waiting_for_approval, net) # -> Needs Approval
petri_utils.add_arc_from_to(p_assessed, t_Check_Low, net)
petri_utils.add_arc_from_to(t_Check_Low, p_payment_authorized, net) # -> Directly to Payment Authorized

# Needs Approval -> AP -> Payment Authorized
petri_utils.add_arc_from_to(p_waiting_for_approval, t_AP, net)
petri_utils.add_arc_from_to(t_AP, p_payment_authorized, net)

# Payment Authorized -> P -> Paid
petri_utils.add_arc_from_to(p_payment_authorized, t_P, net)
petri_utils.add_arc_from_to(t_P, p_paid, net)

# Paid -> N -> Notified
petri_utils.add_arc_from_to(p_paid, t_N, net)
petri_utils.add_arc_from_to(t_N, p_notified, net)

# Notified -> CL -> End
petri_utils.add_arc_from_to(p_notified, t_CL, net)
petri_utils.add_arc_from_to(t_CL, p_end, net)

# 5. Define Initial and Final Markings
im = Marking()
im[p_start] = 1  # Start with one token in the initial place

fm = Marking()
fm[p_end] = 1    # End with one token in the final place

# The accepting Petri net is now defined by (net, im, fm)

# Optional: Print structure summary (for verification)
print("Petri Net Construction Complete.")
print(f"Net Name: {net.name}")
print(f"Number of Places: {len(net.places)}")
print(f"Number of Transitions: {len(net.transitions)}")
print(f"Number of Arcs: {len(net.arcs)}")
print("\nInitial Marking:")
for place, tokens in im.items():
    print(f"- {place.name}: {tokens} token(s)")
print("\nFinal Marking:")
for place, tokens in fm.items():
    print(f"- {place.name}: {tokens} token(s)")

# Example of how to access the components (not required by prompt, but useful)
# print("\nPlaces:")
# for p in net.places:
#     print(f"- {p.name}")
# print("\nTransitions:")
# for t in net.transitions:
#     print(f"- {t.name} (Label: {t.label})")
# print("\nArcs:")
# for arc in net.arcs:
#      print(f"- From '{arc.source.name}' to '{arc.target.name}'")

```

**Explanation:**

1.  **Places (`PetriNet.Place`)**: Represent the states or conditions in the process. For example, `p_start` represents the state where a claim has just been filed, `p_registered` represents the state after registration, and `p_end` is the final state after closure. Places like `p_after_dv` and `p_after_fc` act as decision points before routing based on verification/check outcomes.
2.  **Transitions (`PetriNet.Transition`)**: Represent the activities or events that cause state changes. Each activity from the scenario (CR, DV, FC, etc.) is mapped to a transition. We also introduce transitions like `t_Docs_OK`, `t_Docs_NOK`, `t_Fraud_OK`, `t_Fraud_NOK`, `t_Check_High`, `t_Check_Low` to model the choices or branching logic based on the outcomes of DV, FC, and CA respectively. These could potentially be *silent transitions* (label=None) if we only care about the flow, but giving them labels makes the model clearer.
3.  **Arcs**: Connect places to transitions and transitions to places, defining the sequence and causality. `petri_utils.add_arc_from_to()` is used for this.
    *   An arc from a place to a transition signifies that the transition requires a token in that place to fire (pre-condition).
    *   An arc from a transition to a place signifies that firing the transition produces a token in that place (post-condition).
4.  **Loops**:
    *   The **RDS loop** is modeled by `t_Docs_NOK` leading to `p_docs_nok_before_rds`, which enables `t_RDS`, whose output `p_registered` is the input place for `t_DV`. This correctly models going back for re-verification after re-submission.
    *   The **II loop** is modeled similarly: `t_Fraud_NOK` leads to `p_fraud_nok_before_ii`, enabling `t_II`, whose output `p_docs_ok_before_fc` is the input place for `t_FC`. This models re-checking after investigation. Note that II can happen multiple times.
5.  **Conditional Approval**: The choice between needing approval (`AP`) or going directly to payment (`P`) after assessment (`CA`) is modeled using the intermediate place `p_assessed` and two conflicting transitions (`t_Check_High`, `t_Check_Low`). Only one of these can fire, routing the process token accordingly. Both paths eventually converge at `p_payment_authorized` before the Payment transition `t_P`.
6.  **Initial Marking (`im`)**: `im[p_start] = 1` sets the initial state, indicating one claim is ready to start the process.
7.  **Final Marking (`fm`)**: `fm[p_end] = 1` defines the goal state, representing a single successfully closed claim.

This code creates the Petri net structure (`net`) along with its initial (`im`) and final (`fm`) markings, constituting the accepting Petri net for the described insurance claim process.