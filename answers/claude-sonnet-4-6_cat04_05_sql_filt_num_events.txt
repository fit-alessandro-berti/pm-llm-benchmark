# DuckDB SQL Query: Filter Cases by Event Count

## Solution

```sql
SELECT
    el.case_id,
    el.activity,
    el.timestamp
FROM event_log el
INNER JOIN (
    SELECT
        case_id,
        COUNT(*) AS event_count
    FROM event_log
    GROUP BY case_id
    HAVING COUNT(*) <= 6
) AS valid_cases
    ON el.case_id = valid_cases.case_id
ORDER BY
    el.case_id,
    el.timestamp;
```

## How It Works

### Step-by-Step Breakdown

| Step | Operation | Purpose |
|------|-----------|---------|
| 1 | **Subquery aggregation** | Groups events by `case_id` and counts events per case |
| 2 | **`HAVING` filter** | Retains only `case_id`s with  6 events |
| 3 | **`INNER JOIN`** | Matches original events against the filtered case list |
| 4 | **`ORDER BY`** | Returns events in a logical, readable sequence |

### Alternative Approaches

**Using a Window Function (single-pass):**
```sql
SELECT
    case_id,
    activity,
    timestamp
FROM (
    SELECT
        *,
        COUNT(*) OVER (PARTITION BY case_id) AS event_count
    FROM event_log
)
WHERE event_count <= 6
ORDER BY
    case_id,
    timestamp;
```

**Using a CTE (more readable):**
```sql
WITH case_event_counts AS (
    SELECT
        case_id,
        COUNT(*) AS event_count
    FROM event_log
    GROUP BY case_id
    HAVING COUNT(*) <= 6
)
SELECT
    el.case_id,
    el.activity,
    el.timestamp
FROM event_log el
INNER JOIN case_event_counts cec
    ON el.case_id = cec.case_id
ORDER BY
    el.case_id,
    el.timestamp;
```

## Key Design Decisions

- **`HAVING` vs `WHERE`**: `HAVING` is used to filter *after* aggregation, which is required when filtering on aggregate functions like `COUNT()`
- **`INNER JOIN`** ensures only events belonging to valid cases are returned — no orphaned or unmatched rows
- **`SELECT *`** is intentionally avoided to make the output schema explicit and predictable