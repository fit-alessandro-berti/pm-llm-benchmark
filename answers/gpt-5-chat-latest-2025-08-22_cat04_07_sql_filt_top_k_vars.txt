Got it! Let’s carefully design the DuckDB SQL solution step by step to satisfy all requirements.

We need to:

1. Compute the **activity sequence per case** by ordering activities by timestamp.  
2. Aggregate them into a **process variant string**.  
3. Count frequency of cases per variant.  
4. Select the **top K variants** (parameterizable).  
5. Return **all events for cases belonging to those variants** only.

Here’s the **DuckDB SQL query**:

```sql
-- Set K here
WITH per_case AS (
    SELECT
        case_id,
        STRING_AGG(activity, '->' ORDER BY timestamp) AS variant
    FROM event_log
    GROUP BY case_id
),
variant_counts AS (
    SELECT
        variant,
        COUNT(*) AS case_count
    FROM per_case
    GROUP BY variant
),
top_k_variants AS (
    SELECT
        variant
    FROM variant_counts
    ORDER BY case_count DESC
    LIMIT 5   -- replace 5 with the desired K
),
filtered_cases AS (
    SELECT
        pc.case_id
    FROM per_case pc
    JOIN top_k_variants tk
      ON pc.variant = tk.variant
)
SELECT
    e.*
FROM event_log e
JOIN filtered_cases fc
  ON e.case_id = fc.case_id
ORDER BY e.case_id, e.timestamp;
```

---

### Explanation:

1. **`per_case`**  
   - For each `case_id`, we concatenate the activities in timestamp order to generate the sequence of activities (the *variant*).

2. **`variant_counts`**  
   - We count how many cases follow each variant.

3. **`top_k_variants`**  
   - Selects only the most frequent `K` variants (uses `LIMIT K`).

4. **`filtered_cases`**  
   - Finds all `case_id`s belonging to these top variants.

5. **Final SELECT**  
   - Returns all original event rows for those `case_id`s, keeping event details.  
   - Ordered by `case_id, timestamp`.

---

 This query correctly outputs only **events from cases in the top K process variants**, leaving out everything else.

---

Would you like me to also show how to **parameterize K dynamically** (e.g., with a DuckDB query parameter) so it’s easier to reuse in scripts?