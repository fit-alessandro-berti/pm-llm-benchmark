To model the complex insurance claim management process, we construct an accepting Petri net with appropriate places, transitions, and arcs to capture the process flow, including potential loops for re-submission and investigation. Here's the Python code using the PM4Py library:

```python
from pm4py.objects.petri_net.obj import PetriNet, Marking
from pm4py.objects.petri_net.utils import petri_utils

# Create the Petri net
net = PetriNet(name="Insurance Claim Process")

# Create transitions
cr = PetriNet.Transition(name="CR", label="Claim Registration")
dv = PetriNet.Transition(name="DV", label="Document Verification")
rds = PetriNet.Transition(name="RDS", label="Re-Document Submission")
fc = PetriNet.Transition(name="FC", label="Fraud Check")
ii = PetriNet.Transition(name="II", label="In-depth Investigation")
ca = PetriNet.Transition(name="CA", label="Claim Assessment")
ap = PetriNet.Transition(name="AP", label="Approval")
skip_ap = PetriNet.Transition(name="skip_AP", label=None)  # Silent transition
p = PetriNet.Transition(name="P", label="Payment")
n = PetriNet.Transition(name="N", label="Notification")
cl = PetriNet.Transition(name="CL", label="Closure")

# Add transitions to the net
net.transitions.extend([cr, dv, rds, fc, ii, ca, ap, skip_ap, p, n, cl])

# Create places
start = PetriNet.Place(name="start")
p_CR = PetriNet.Place(name="p_CR")
p_DV = PetriNet.Place(name="p_DV")
p_FC = PetriNet.Place(name="p_FC")
p_CA = PetriNet.Place(name="p_CA")
p_AP = PetriNet.Place(name="p_AP")
p_P = PetriNet.Place(name="p_P")
p_N = PetriNet.Place(name="p_N")
p_CL = PetriNet.Place(name="p_CL")

# Add places to the net
net.places.extend([start, p_CR, p_DV, p_FC, p_CA, p_AP, p_P, p_N, p_CL])

# Connect elements with arcs
# Initial flow
petri_utils.add_arc_from_to(start, cr, net)
petri_utils.add_arc_from_to(cr, p_CR, net)

# Document Verification with Re-Submission loop
petri_utils.add_arc_from_to(p_CR, dv, net)
petri_utils.add_arc_from_to(dv, p_DV, net)
petri_utils.add_arc_from_to(p_DV, rds, net)
petri_utils.add_arc_from_to(rds, p_CR, net)

# Fraud Check with Investigation loop
petri_utils.add_arc_from_to(p_DV, fc, net)
petri_utils.add_arc_from_to(fc, p_FC, net)
petri_utils.add_arc_from_to(p_FC, ii, net)
petri_utils.add_arc_from_to(ii, p_DV, net)

# Claim Assessment and Approval bypass
petri_utils.add_arc_from_to(p_FC, ca, net)
petri_utils.add_arc_from_to(ca, p_CA, net)
petri_utils.add_arc_from_to(p_CA, ap, net)
petri_utils.add_arc_from_to(ap, p_AP, net)
petri_utils.add_arc_from_to(p_CA, skip_ap, net)
petri_utils.add_arc_from_to(skip_ap, p_AP, net)

# Payment and Closure
petri_utils.add_arc_from_to(p_AP, p, net)
petri_utils.add_arc_from_to(p, p_P, net)
petri_utils.add_arc_from_to(p_P, n, net)
petri_utils.add_arc_from_to(n, p_N, net)
petri_utils.add_arc_from_to(p_N, cl, net)
petri_utils.add_arc_from_to(cl, p_CL, net)

# Set initial and final markings
im = Marking()
im[start] = 1

fm = Marking()
fm[p_CL] = 1

# The accepting Petri net is defined by (net, im, fm)
```

**Explanation:**
- **Places** represent states between activities (e.g., `p_CR` after Claim Registration).
- **Transitions** correspond to process activities with labels matching the task names.
- **Loops** are implemented for document re-submission (DV  RDS) and fraud investigation (FC  II).
- **Approval bypass** uses a silent transition (`skip_AP`) to model conditional routing.
- The **initial marking** has a token in the `start` place, representing a new claim.
- The **final marking** has a token in `p_CL`, representing a closed claim.