```sql
WITH k_value AS (
  SELECT 3 AS k  -- Set desired K here
),
case_variants AS (
  SELECT 
    case_id,
    LIST_AGG(activity ORDER BY timestamp) AS variant
  FROM event_log
  GROUP BY case_id
),
variant_stats AS (
  SELECT 
    variant,
    COUNT(*) AS freq
  FROM case_variants
  GROUP BY variant
),
top_variants AS (
  SELECT variant
  FROM variant_stats
  ORDER BY freq DESC
  LIMIT (SELECT k FROM k_value)
),
top_cases AS (
  SELECT DISTINCT cv.case_id
  FROM case_variants cv
  INNER JOIN top_variants tv ON cv.variant = tv.variant
)
SELECT e.*
FROM event_log e
INNER JOIN top_cases tc ON e.case_id = tc.case_id
ORDER BY e.case_id, e.timestamp;
```

## Explanation

This query systematically addresses the requirements:

1. **case_variants CTE**: Groups events by `case_id` and uses `LIST_AGG(activity ORDER BY timestamp)` to construct the ordered sequence of activities for each case, preserving timestamp order.

2. **variant_stats CTE**: Groups the case variants by their activity sequence (`variant`) and counts the frequency of each unique variant.

3. **k_value CTE**: Defines the parameter `k` for flexibility (set to 3 as an example; adjust as needed).

4. **top_variants CTE**: Identifies the top K variants by sorting frequencies in descending order and limiting to K using the parameter from `k_value`.

5. **top_cases CTE**: Selects all `case_id`s whose variants match one of the top K variants via an inner join.

6. **Final SELECT**: Retrieves all columns (`*`) from `event_log` for cases in `top_cases`, ordered by `case_id` and `timestamp` to maintain logical event order within cases.

This ensures only events from the top K most frequent process variants are returned, excluding all others. DuckDB's support for list aggregation and equality on lists enables precise variant matching.