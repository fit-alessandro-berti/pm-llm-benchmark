To solve this problem in DuckDB, we can use Common Table Expressions (CTEs) and DuckDB’s powerful list aggregation functions. 

The following query identifies the ordered activity sequence for every case, finds the most frequent sequences, and then filters the original event log to include only those cases.

```sql
-- Define K (e.g., top 5 variants)
WITH case_variants AS (
    -- 1. Construct the sequence of activities for each case_id
    -- We use list() with an ORDER BY clause to ensure the sequence matches the timestamp
    SELECT 
        case_id, 
        list(activity ORDER BY timestamp) AS variant
    FROM event_log
    GROUP BY case_id
),
variant_counts AS (
    -- 2 & 3. Group by the sequence to find unique variants and their frequencies
    -- We select the top K variants (e.g., LIMIT 5)
    SELECT 
        variant, 
        count(*) as variant_frequency
    FROM case_variants
    GROUP BY variant
    ORDER BY variant_frequency DESC
    LIMIT 5  -- Replace 5 with your desired value for K
),
filtered_cases AS (
    -- 4. Identify the case_ids that belong to those top K variants
    SELECT 
        cv.case_id
    FROM case_variants cv
    JOIN variant_counts vc ON cv.variant = vc.variant
)
-- Return all original events for the cases identified above
SELECT 
    e.case_id,
    e.activity,
    e.timestamp
FROM event_log e
WHERE e.case_id IN (SELECT case_id FROM filtered_cases)
ORDER BY e.case_id, e.timestamp;
```

### Explanation of the Steps:

1.  **`case_variants` CTE**: We use the `list(activity ORDER BY timestamp)` aggregate function. In DuckDB, this creates a Python-like list of the activities for each `case_id`, specifically following the chronological order of the events.
2.  **`variant_counts` CTE**: DuckDB allows grouping by list types. This step counts how many cases follow each specific list of activities. We then sort by frequency descending and use `LIMIT K` to isolate the most common process behaviors.
3.  **`filtered_cases` CTE**: We join the per-case sequences back against our top-K list to identify exactly which `case_id`s we want to keep.
4.  **Final Select**: We perform a final filter on the original `event_log` table. This ensures the output contains the full event data (not just the aggregated list) for the relevant cases.

### Why this is efficient in DuckDB:
*   **List Aggregation**: DuckDB's vectorized engine handles list creation and comparison very efficiently compared to traditional SQL engines.
*   **Direct Comparison**: DuckDB can compare entire arrays/lists in the `JOIN` or `IN` clause without needing to stringify them (e.g., `list_agg` with commas), which avoids issues with activities that might contain commas.