Here's a compact Python script that constructs an accepting Petri net for the insurance claim process described. It uses places for states between activities, transitions labeled with activity names (and a few invisible transitions for routing/decision), loops for re-document submission and repeated in-depth investigations, and defines the initial and final markings.

```python
from pm4py.objects.petri_net.obj import PetriNet, Marking
from pm4py.objects.petri_net.utils import petri_utils

# create net
net = PetriNet(name="insurance_claim_process")

# places
p_start = PetriNet.Place(name="p_start")                     # new claim arrives
p_registered = PetriNet.Place(name="p_registered")           # after Claim Registration
p_after_dv = PetriNet.Place(name="p_after_dv")               # after Document Verification (decision point)
p_after_fc = PetriNet.Place(name="p_after_fc")               # after Fraud Check (decision / investigations)
p_after_ca = PetriNet.Place(name="p_after_ca")               # after Claim Assessment
p_after_approval = PetriNet.Place(name="p_after_approval")   # after Approval or skip
p_paid = PetriNet.Place(name="p_paid")                       # after Payment
p_notified = PetriNet.Place(name="p_notified")               # after Notification
p_closed = PetriNet.Place(name="p_closed")                   # final closed / archived state

# add places to net
for p in [p_start, p_registered, p_after_dv, p_after_fc, p_after_ca,
          p_after_approval, p_paid, p_notified, p_closed]:
    net.places.add(p)

# transitions (labels are activity names; some internal routing transitions are invisible -> label=None)
t_cr = PetriNet.Transition(name="t_cr", label="Claim Registration")
t_dv = PetriNet.Transition(name="t_dv", label="Document Verification")
t_rds = PetriNet.Transition(name="t_rds", label="Re-Document Submission")   # loop if docs incomplete

t_fc = PetriNet.Transition(name="t_fc", label="Fraud Check")
t_ii = PetriNet.Transition(name="t_ii", label="In-depth Investigation")     # can happen multiple times
t_proceed_from_fc = PetriNet.Transition(name="t_proceed_from_fc", label=None)  # internal routing to CA

t_ca = PetriNet.Transition(name="t_ca", label="Claim Assessment")
t_approval = PetriNet.Transition(name="t_approval", label="Approval")
t_skip_approval = PetriNet.Transition(name="t_skip_approval", label=None)   # approval not required path

t_payment = PetriNet.Transition(name="t_payment", label="Payment")
t_notification = PetriNet.Transition(name="t_notification", label="Notification")
t_closure = PetriNet.Transition(name="t_closure", label="Closure")

# add transitions to net
for t in [t_cr, t_dv, t_rds, t_fc, t_ii, t_proceed_from_fc,
          t_ca, t_approval, t_skip_approval, t_payment, t_notification, t_closure]:
    net.transitions.add(t)

# arcs / flow
petri_utils.add_arc_from_to(p_start, t_cr, net)
petri_utils.add_arc_from_to(t_cr, p_registered, net)

petri_utils.add_arc_from_to(p_registered, t_dv, net)
petri_utils.add_arc_from_to(t_dv, p_after_dv, net)

# from document verification we can either request re-submission (loop) or proceed to fraud check
petri_utils.add_arc_from_to(p_after_dv, t_rds, net)
petri_utils.add_arc_from_to(t_rds, p_after_dv, net)   # loop: re-submit docs and re-check

petri_utils.add_arc_from_to(p_after_dv, t_fc, net)
petri_utils.add_arc_from_to(t_fc, p_after_fc, net)

# fraud check: possible in-depth investigations loop, then proceed to assessment
petri_utils.add_arc_from_to(p_after_fc, t_ii, net)
petri_utils.add_arc_from_to(t_ii, p_after_fc, net)    # repeated investigations
petri_utils.add_arc_from_to(p_after_fc, t_proceed_from_fc, net)
petri_utils.add_arc_from_to(t_proceed_from_fc, p_after_ca, net)

# claim assessment and branching to approval or skip approval
petri_utils.add_arc_from_to(p_after_ca, t_ca, net)
petri_utils.add_arc_from_to(t_ca, p_after_ca, net)    # keep assessment place as decision point

# from assessment, either Approval (visible) or skip (invisible)
petri_utils.add_arc_from_to(p_after_ca, t_approval, net)
petri_utils.add_arc_from_to(t_approval, p_after_approval, net)

petri_utils.add_arc_from_to(p_after_ca, t_skip_approval, net)
petri_utils.add_arc_from_to(t_skip_approval, p_after_approval, net)

# payment, notification, closure
petri_utils.add_arc_from_to(p_after_approval, t_payment, net)
petri_utils.add_arc_from_to(t_payment, p_paid, net)

petri_utils.add_arc_from_to(p_paid, t_notification, net)
petri_utils.add_arc_from_to(t_notification, p_notified, net)

petri_utils.add_arc_from_to(p_notified, t_closure, net)
petri_utils.add_arc_from_to(t_closure, p_closed, net)

# initial and final markings
im = Marking()
im[p_start] = 1

fm = Marking()
fm[p_closed] = 1

# net, im, fm are ready to use
```

Notes:
- Re-document submission is modeled as a loop on p_after_dv (t_rds consumes and produces the same place), allowing multiple resubmissions.
- In-depth investigation is modeled similarly as a loop on p_after_fc (t_ii), allowing several investigations before proceeding.
- Approval is conditional: an invisible transition t_skip_approval models the path where approval is not required; the visible t_approval models the approval activity.
- im places the single token in p_start (new claim). fm requires the token to reach p_closed (claim closed/archived).