Here's a Python script that generates a temporal profile for an hypothetical Purchase-to-Pay process.

```python
import random
import math
import matplotlib.pyplot as plt

# Define the activities in the Purchase-to-Pay process
activities = ['Order', 'Invoice', 'Receivable', 'Payment']

# Define the temporal profile as a dictionary
temporal_profile = {}

# Define the average and standard deviation for each couple of activities
# The values are in seconds
temporal_profile[('Order', 'Invoice')] = (86400, 3600)  # 1 day avg, 1 hour std
temporal_profile[('Invoice', 'Receivable')] = (172800, 86400)  # 2 days avg, 1 day std
temporal_profile[('Receivable', 'Payment')] = (86400, 86400)  # 1 day avg, 1 day std
temporal_profile[('Order', 'Receivable')] = (604800, 259200)  # 7 days avg, 3 days std
temporal_profile[('Order', 'Payment')] = (2592000, 1728000)  # 30 days avg, 2 days std
temporal_profile[('Invoice', 'Payment')] = (1728000, 864000)  # 2 weeks avg, 1 week std
temporal_profile[('Receivable', 'Payment')] = (604800, 604800)  # 1 week avg, 1 week std

# Function to generate a random time between two activities based on the temporal profile
def generate_random_time(activity1, activity2):
    avg, std = temporal_profile[(activity1, activity2)]
    zeta = 2  # deviation factor
    min_time = avg - zeta * std
    max_time = avg + zeta * std
    return random.uniform(min_time, max_time)

# Function to check if a deviation occurs
def check_deviation(activity1, activity2, time):
    avg, std = temporal_profile[(activity1, activity2)]
    zeta = 2  # deviation factor
    min_time = avg - zeta * std
    max_time = avg + zeta * std
    return time < min_time or time > max_time

# Generate a sample data
sample_data = {}
for i in range(100):
    trace = [activities[random.randint(