To tackle this task effectively using DuckDB, we will proceed in several steps:

1. **Extract Ordered Sequences of Activities per Case**: We'll create a sequence for each `case_id` by sorting activities based on the `timestamp`.
2. **Aggregate and Count Cases Per Variant**: Next, group cases by their complete activity sequences to identify unique process variants.
3. **Identify Top K Variants By Frequency**: Determine which process variants are most common among all cases.
4. **Filter Original Events to Top K Variants**: Finally, return events from the original `event_log` that belong solely to these top K variants.

### Step-by-Step Solution

#### 1. Extract Ordered Sequences of Activities per Case
We’ll start by creating a query that extracts each case's activity sequence based on timestamps. We'll use a Common Table Expression (CTE) for clarity:

```sql
WITH ordered_events AS (
    SELECT
        case_id,
        activity,
        timestamp,
        LAG(activity) OVER (PARTITION BY case_id ORDER BY timestamp) AS prev_activity,
        ROW_NUMBER() OVER (PARTITION BY case_id ORDER BY timestamp) AS seq_number
    FROM event_log
)
SELECT
    case_id,
    activity
FROM ordered_events
WHERE seq_number = 1 OR prev_activity IS NULL;
```

This query creates a sequence of activities for each `case_id` by using the `ROW_NUMBER()` window function to generate sequential numbers (`seq_number`). We keep only the first event in each sequence (where `seq_number=1`) or events that have no predecessor (`prev_activity IS NULL`).

#### 2. Aggregate and Count Cases Per Variant
Next, we’ll group these sequences by activity order and count occurrences:

```sql
WITH ordered_events AS (
    SELECT
        case_id,
        activity,
        LAG(activity) OVER (PARTITION BY case_id ORDER BY timestamp) AS prev_activity
    FROM event_log
),
variant_counts AS (
    SELECT
        STRING_AGG(activity, ',' ORDER BY CASE WHEN prev_activity IS NULL THEN 0 ELSE 1 END) AS variant_sequence,
        COUNT(DISTINCT case_id) AS case_count
    FROM ordered_events
    GROUP BY case_id
)
SELECT DISTINCT variant_sequence
FROM variant_counts;
```

Here we use `STRING_AGG` to concatenate activities per case into a unique sequence (variant). We then count how many cases correspond to each distinct activity sequence.

#### 3. Identify Top K Variants By Frequency
Now, let's determine the top `K` variants by frequency:

```sql
WITH ordered_events AS (
    SELECT
        case_id,
        activity,
        LAG(activity) OVER (PARTITION BY case_id ORDER BY timestamp) AS prev_activity
    FROM event_log
),
variant_counts AS (
    SELECT
        STRING_AGG(activity, ',' ORDER BY CASE WHEN prev_activity IS NULL THEN 0 ELSE 1 END) AS variant_sequence,
        COUNT(DISTINCT case_id) AS case_count
    FROM ordered_events
    GROUP BY case_id
)
SELECT variant_sequence
FROM variant_counts
ORDER BY case_count DESC
LIMIT K;
```

Finally, we order the variants by their count in descending order and limit the result to `K` variants.

#### 4. Filter Original Events to Top K Variants
The final step involves filtering the original events such that only those belonging to cases with top `K` variants are returned:

```sql
WITH ordered_events AS (
    SELECT
        case_id,
        activity,
        timestamp
    FROM event_log
),
top_k_variants AS (
    SELECT variant_sequence
    FROM (
        WITH ordered_events AS (
            SELECT
                case_id,
                activity,
                LAG(activity) OVER (PARTITION BY case_id ORDER BY timestamp) AS prev_activity
            FROM event_log
        ),
        variant_counts AS (
            SELECT
                STRING_AGG(activity, ',' ORDER BY CASE WHEN prev_activity IS NULL THEN 0 ELSE 1 END) AS variant_sequence,
                COUNT(DISTINCT case_id) AS case_count
            FROM ordered_events
            GROUP BY case_id
        )
        SELECT variant_sequence
        FROM variant_counts
        ORDER BY case_count DESC
        LIMIT K
    ) top_k
)
SELECT *
FROM event_log
WHERE EXISTS (
    SELECT 1
    FROM top_k_variants tk
    WHERE STRING_AGG(event_log.activity, ',' ORDER BY timestamp) = tk.variant_sequence
);
```

In this final query:
- **`ordered_events`** extracts ordered events per case.
- **`top_k_variants`** computes the `K` most frequent variants.
- The outermost `SELECT` filters rows from `event_log`, keeping only those whose activity sequence (as determined by `STRING_AGG`) matches one of the top K variants.

### Summary
The final solution effectively addresses each requirement step-by-step:
1. **Ordered Sequences**: Extracted using window functions to establish a case-specific order.
2. **Aggregated and Counted Variants**: Created unique variant sequences per `case_id` and counted occurrences.
3. **Top K Variants Determination**: Identified the most frequent variants by sorting counts in descending order and limiting results.
4. **Final Filtering**: Ensured only events from these top variants are returned, maintaining their original context within `event_log`.

The query leverages DuckDB's advanced SQL features such as window functions (`ROW_NUMBER`, `LAG`), string aggregation (`STRING_AGG`), and conditional ordering to achieve the desired outcome efficiently.