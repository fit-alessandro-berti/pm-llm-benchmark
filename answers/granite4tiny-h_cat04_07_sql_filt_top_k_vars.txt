To address the task effectively, we'll break it down into several steps within our SQL query, leveraging DuckDB's capabilities for handling event logs stored in a table named `event_log`. The goal is to identify unique process variants based on activity sequences, count occurrences of each variant, and then extract events from cases that belong to the top K variants.

### Step 1: Extract Ordered Sequence of Activities per Case

First, we need to ensure that for each case (`case_id`), we order its activities by `timestamp`. This can be achieved using a window function in SQL:

```sql
WITH OrderedEvents AS (
    SELECT
        case_id,
        activity,
        timestamp,
        ROW_NUMBER() OVER (PARTITION BY case_id ORDER BY timestamp) AS rn
    FROM event_log
)
```

### Step 2: Group Activities by `case_id` and Formulate Activity Sequences

Next, we'll group these ordered events back into their respective cases to form activity sequences. However, since SQL doesn't directly concatenate arrays or strings in a straightforward manner across groups without additional aggregation functions, we'll use string aggregation (e.g., `STRING_AGG`) for simplicity:

```sql
, ActivitySequences AS (
    SELECT
        case_id,
        STRING_AGG(activity, '->') OVER (PARTITION BY case_id ORDER BY rn) AS sequence
    FROM OrderedEvents
)
```

### Step 3: Aggregate Cases by Their Unique Sequence

Now, we aggregate cases by these sequences to count how many cases follow each unique activity sequence:

```sql
, VariantCounts AS (
    SELECT
        sequence,
        COUNT(DISTINCT case_id) AS case_count
    FROM ActivitySequences
    GROUP BY sequence
)
```

### Step 4: Determine Top K Variants

To find the top K variants based on their frequency (number of cases), we use a subquery or CTE to rank these variants:

```sql
, TopKVariants AS (
    SELECT
        sequence,
        case_count
    FROM VariantCounts
    ORDER BY case_count DESC
    LIMIT 10 -- Assuming you want the top K variants by default; replace '10' with your desired K value.
)
```

### Step 5: Filter and Return Events from Top K Variants

Finally, we need to filter back to our original event log, selecting only those events that belong to cases which are part of these top K variants:

```sql
SELECT
    e.*
FROM event_log e
JOIN ActivitySequences a ON e.case_id = a.case_id
WHERE a.sequence IN (SELECT sequence FROM TopKVariants);
```

### Full Query

Combining all steps, the complete SQL query to achieve our goal would be:

```sql
WITH OrderedEvents AS (
    SELECT
        case_id,
        activity,
        timestamp,
        ROW_NUMBER() OVER (PARTITION BY case_id ORDER BY timestamp) AS rn
    FROM event_log
),
ActivitySequences AS (
    SELECT
        case_id,
        STRING_AGG(activity, '->') OVER (PARTITION BY case_id ORDER BY rn) AS sequence
    FROM OrderedEvents
),
VariantCounts AS (
    SELECT
        sequence,
        COUNT(DISTINCT case_id) AS case_count
    FROM ActivitySequences
    GROUP BY sequence
),
TopKVariants AS (
    SELECT
        sequence,
        case_count
    FROM VariantCounts
    ORDER BY case_count DESC
    LIMIT 10 -- Adjust the limit to your desired K value.
)
SELECT
    e.*
FROM event_log e
JOIN ActivitySequences a ON e.case_id = a.case_id
WHERE a.sequence IN (SELECT sequence FROM TopKVariants);
```

This query systematically extracts and analyzes activity sequences within cases, identifies the most frequent ones as top variants, and then filters back to retrieve events from those cases, effectively following your task's requirements. Adjustments may be needed based on specific requirements or SQL dialect differences in handling string aggregation across partitions (e.g., some databases might use `GROUP_CONCAT` instead of `STRING_AGG`).