First, to figure out the sequence of activities for each case, it's necessary to sort the events by their timestamp. Using a window function like `ARRAY_AGG(activity ORDER BY timestamp)` within each case_id groups activities into an ordered array, representing the variant for that case.

Next, counting how many cases follow each variant is straightforward: group by the array of activities and count the distinct case_ids. But to filter for only the top K most frequent variants, the ordering and limiting must be applied to the counts.

However, the tricky part is that the final result must include all the original events for cases belonging to these top K variants. If the top K are selected from the counts table and then joined back to the original log, care must be taken to preserve all events for those cases, not just the first event per case. This means using an `IN` clause or joining the list of case_ids from the top variants back to the original event log.

An efficient way is to first compute the counts per variant, select the top K, and collect the case_ids that belong to those variants. Then, filter the original event log to include only those case_ids. This two-step process ensures all events for the relevant cases are retained.

Here's how the query comes together:

```sql
WITH variant_counts AS (
  SELECT
    ARRAY_AGG(activity ORDER BY timestamp) AS variant,
    COUNT(DISTINCT case_id) AS case_count
  FROM event_log
  GROUP BY case_id
),
top_k_variants AS (
  SELECT variant
  FROM variant_counts
  ORDER BY case_count DESC
  LIMIT K
)
SELECT el.*
FROM event_log el
WHERE ARRAY_AGG(el.activity ORDER BY el.timestamp) IN (SELECT variant FROM top_k_variants);
```

Actually, that last part doesn't quite work because the array aggregation in the WHERE clause isn't valid. Instead, the set of case_ids belonging to the top K variants needs to be identified, and the original log filtered by those case_ids:

```sql
WITH case_variants AS (
  SELECT
    case_id,
    ARRAY_AGG(activity ORDER BY timestamp) AS variant
  FROM event_log
  GROUP BY case_id
),
variant_counts AS (
  SELECT
    variant,
    COUNT(DISTINCT case_id) AS case_count
  FROM case_variants
  GROUP BY variant
),
top_k_variants AS (
  SELECT variant
  FROM variant_counts
  ORDER BY case_count DESC
  LIMIT K
),
top_case_ids AS (
  SELECT case_id
  FROM case_variants
  WHERE variant IN (SELECT variant FROM top_k_variants)
)
SELECT el.*
FROM event_log el
WHERE el.case_id IN (SELECT case_id FROM top_case_ids);
```

This approach ensures that for each case, the ordered sequence of activities is computed, the top K variants by frequency are selected, and all events for those cases are returned from the original log. If K is 1, only cases matching the most common variant are returned; if K is greater, the top K most frequent variants are included. This method is robust even if multiple variants share the same frequency, as the `LIMIT` will arbitrarily pick among them, which is acceptable given the problem constraints.