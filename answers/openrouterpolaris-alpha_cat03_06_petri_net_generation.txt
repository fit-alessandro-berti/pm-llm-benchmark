Here is one possible accepting Petri net encoding your scenario.

It models:

- Linear flow: C  CR  DV  FC  CA  optional AP  P  N  CL
- Loop DV  RDS: incomplete documents cause re-submission and re-verification.
- Loop FC  II: in-depth investigations can repeat multiple times.
- Approval (AP) as a distinct step before Payment (P); you can later extend this with guards/branches if needed.

Python code:

```python
from pm4py.objects.petri_net.obj import PetriNet, Marking
from pm4py.objects.petri_net.utils import petri_utils

# Create Petri net
net = PetriNet("Insurance_Claim_Process")

# Places
p_start = PetriNet.Place("p_start")                  # new claim arrives
p_after_C = PetriNet.Place("p_after_C")              # after claim creation/registration trigger
p_after_CR = PetriNet.Place("p_after_CR")            # after Claim Registration
p_after_DV = PetriNet.Place("p_after_DV")            # after Document Verification
p_need_docs = PetriNet.Place("p_need_docs")          # waiting for (re-)document submission
p_after_RDS = PetriNet.Place("p_after_RDS")          # after Re-Document Submission
p_after_FC = PetriNet.Place("p_after_FC")            # after Fraud Check
p_in_investigation = PetriNet.Place("p_in_investigation")  # during In-depth Investigation loop
p_after_II = PetriNet.Place("p_after_II")            # after each In-depth Investigation
p_after_CA = PetriNet.Place("p_after_CA")            # after Claim Assessment
p_after_AP = PetriNet.Place("p_after_AP")            # after Approval (if required)
p_after_P = PetriNet.Place("p_after_P")              # after Payment
p_after_N = PetriNet.Place("p_after_N")              # after Notification
p_closed = PetriNet.Place("p_closed")                # final closed claim

net.places.update({
    p_start, p_after_C, p_after_CR, p_after_DV,
    p_need_docs, p_after_RDS,
    p_after_FC, p_in_investigation, p_after_II,
    p_after_CA, p_after_AP, p_after_P, p_after_N,
    p_closed
})

# Transitions (labeled with activity names)
t_C = PetriNet.Transition("t_C", "C")                # Insurance Claim (claim filed)
t_CR = PetriNet.Transition("t_CR", "CR")             # Claim Registration
t_DV = PetriNet.Transition("t_DV", "DV")             # Document Verification
t_RDS = PetriNet.Transition("t_RDS", "RDS")          # Re-Document Submission
t_FC = PetriNet.Transition("t_FC", "FC")             # Fraud Check
t_II = PetriNet.Transition("t_II", "II")             # In-depth Investigation
t_CA = PetriNet.Transition("t_CA", "CA")             # Claim Assessment
t_AP = PetriNet.Transition("t_AP", "AP")             # Approval
t_P = PetriNet.Transition("t_P", "P")                # Payment
t_N = PetriNet.Transition("t_N", "N")                # Notification
t_CL = PetriNet.Transition("t_CL", "CL")             # Closure

net.transitions.update({
    t_C, t_CR, t_DV, t_RDS,
    t_FC, t_II, t_CA, t_AP,
    t_P, t_N, t_CL
})

# Arcs: main sequence and loops

# Start -> C
petri_utils.add_arc_from_to(p_start, t_C, net)
petri_utils.add_arc_from_to(t_C, p_after_C, net)

# C -> CR
petri_utils.add_arc_from_to(p_after_C, t_CR, net)
petri_utils.add_arc_from_to(t_CR, p_after_CR, net)

# CR -> DV
petri_utils.add_arc_from_to(p_after_CR, t_DV, net)
petri_utils.add_arc_from_to(t_DV, p_after_DV, net)

# DV -> (ok) -> FC
petri_utils.add_arc_from_to(p_after_DV, t_FC, net)
petri_utils.add_arc_from_to(t_FC, p_after_FC, net)

# DV -> (not ok) -> RDS loop:
# If documents incomplete after DV, go to need_docs, then after RDS back to DV
# (implemented as: DV can also lead to need_docs; RDS consumes need_docs and enables DV again)
petri_utils.add_arc_from_to(p_after_DV, t_RDS, net)        # decision to ask for re-submission
petri_utils.add_arc_from_to(t_RDS, p_need_docs, net)
petri_utils.add_arc_from_to(p_need_docs, t_DV, net)        # after re-submission, verify again

# FC -> (doubt) -> II loop:
# From after_FC we can go into investigation; II can be repeated; exit back to FC
petri_utils.add_arc_from_to(p_after_FC, t_II, net)
petri_utils.add_arc_from_to(t_II, p_after_II, net)

# II result goes back to FC for re-evaluation (enabling multiple II cycles)
petri_utils.add_arc_from_to(p_after_II, t_FC, net)

# From FC (when clear) proceed to CA (using p_after_FC as input)
petri_utils.add_arc_from_to(p_after_FC, t_CA, net)
petri_utils.add_arc_from_to(t_CA, p_after_CA, net)

# CA -> AP -> P
petri_utils.add_arc_from_to(p_after_CA, t_AP, net)
petri_utils.add_arc_from_to(t_AP, p_after_AP, net)

petri_utils.add_arc_from_to(p_after_AP, t_P, net)
petri_utils.add_arc_from_to(t_P, p_after_P, net)

# P -> N -> CL
petri_utils.add_arc_from_to(p_after_P, t_N, net)
petri_utils.add_arc_from_to(t_N, p_after_N, net)

petri_utils.add_arc_from_to(p_after_N, t_CL, net)
petri_utils.add_arc_from_to(t_CL, p_closed, net)

# Initial marking: new claim available at start
im = Marking()
im[p_start] = 1

# Final marking: claim closed
fm = Marking()
fm[p_closed] = 1
```

This defines an accepting Petri net where:

- The process starts with a token in p_start.
- All plausible sequences (with document re-submissions and repeated investigations) that eventually go through P  N  CL lead to a token in p_closed, matching the final marking.