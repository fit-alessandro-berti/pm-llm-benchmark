```python
from pm4py.objects.powl.obj import StrictPartialOrder, OperatorPOWL, Transition, SilentTransition
from pm4py.objects.process_tree.obj import Operator

# Define the transition nodes for activities
SR = Transition(label="SR")
CS = Transition(label="CS")
DA = Transition(label="DA")
ACI = Transition(label="ACI")
BNC = Transition(label="BNC")
DR = Transition(label="D&R")
CD = Transition(label="CD")
MD = Transition(label="MD")
QA = Transition(label="QA")
SA = Transition(label="SA")
GLA = Transition(label="GLA")

# Define the partial order for concurrent DA and ACI (no order between them)
po_da_aci = StrictPartialOrder(nodes=[DA, ACI])

# Define the partial order for concurrent QA and SA (no order between them)
po_qa_sa = StrictPartialOrder(nodes=[QA, SA])

# Define the loop node: * (BNC, D&R)
loop_node = OperatorPOWL(operator=Operator.LOOP, children=[BNC, DR])

# Define the exclusive choice node: X (CD, MD)
choice_node = OperatorPOWL(operator=Operator.XOR, children=[CD, MD])

# Define the root partial order encompassing the entire process
root = StrictPartialOrder(nodes=[SR, CS, po_da_aci, loop_node, choice_node, po_qa_sa, GLA])

# Add the ordering edges to enforce the sequence and dependencies
root.order.add_edge(SR, CS)  # CS after SR
root.order.add_edge(CS, po_da_aci)  # Parallel DA/ACI after CS (both start after CS)
root.order.add_edge(po_da_aci, loop_node)  # Loop after parallel DA/ACI (loop starts after both complete)
root.order.add_edge(loop_node, choice_node)  # Choice after loop
root.order.add_edge(choice_node, po_qa_sa)  # Parallel QA/SA after choice (both start after choice)
root.order.add_edge(po_qa_sa, GLA)  # GLA after parallel QA/SA (GLA starts after both complete)
```