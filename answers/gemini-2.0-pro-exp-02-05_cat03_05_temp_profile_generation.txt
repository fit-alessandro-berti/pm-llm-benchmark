```python
import math

# Helper constants for time estimation (in seconds)
MINUTE = 60
HOUR = 60 * MINUTE
DAY = 24 * HOUR
WEEK = 7 * DAY

# Estimating plausible average times and standard deviations for a complex global supply chain
# These are *estimates* based on the process description. Real values would come from event logs.

temporal_profile = {
    # --- Pairs with short/medium separation ---
    # Supplier Selection to Order Placement: Usually follows relatively quickly after selection, but selection itself can take time. Assume time from *end* of SS to *start* of OP.
    ('SS', 'OP'): (3 * DAY, 1 * DAY),  # Avg: 3 days, Std Dev: 1 day

    # Order Placement to Receive Components: Major potential delay (supplier lead time, global shipping). High variability.
    ('OP', 'RC'): (6 * WEEK, 2 * WEEK), # Avg: 6 weeks, Std Dev: 2 weeks

    # Receive Components to Quality Inspection: Internal handling, usually quick unless backlog.
    ('RC', 'QI'): (1 * DAY, 0.5 * DAY), # Avg: 1 day, Std Dev: 0.5 days

    # Quality Inspection to Component Assembly: Depends on inspection outcome and batch size. Potential delay if issues found.
    ('QI', 'CA'): (2 * DAY, 1 * DAY), # Avg: 2 days, Std Dev: 1 day

    # Component Assembly to Product Testing: Depends on assembly complexity and line availability.
    ('CA', 'PT'): (5 * DAY, 2 * DAY), # Avg: 5 days, Std Dev: 2 days

    # Product Testing to Packaging: Depends on testing duration and results (rework?).
    ('PT', 'PK'): (1.5 * DAY, 1 * DAY), # Avg: 1.5 days, Std Dev: 1 day

    # Packaging to Warehouse Storage: Usually fast, internal movement.
    ('PK', 'WS'): (0.5 * DAY, 0.25 * DAY), # Avg: 0.5 days, Std Dev: 0.25 days

    # Warehouse Storage to Distribution: Highly variable, depends on demand, shipping schedules, batching.
    ('WS', 'DT'): (1 * WEEK, 1 * WEEK), # Avg: 1 week, Std Dev: 1 week (High relative variability)

    # Distribution to After-Sales Support: Time from shipping until first potential support need. Variable.
    # This represents the time from the *start* of DT to the *start* of the first AS activity for that product instance.
    ('DT', 'AS'): (4 * WEEK, 2 * WEEK), # Avg: 4 weeks, Std Dev: 2 weeks

    # --- Pairs with longer separation ---
    # Supplier Selection to Receive Components: Includes SS->OP and OP->RC. Variability dominated by OP->RC.
    ('SS', 'RC'): ( (3 * DAY) + (6 * WEEK), math.ceil(math.sqrt((1*DAY)**2 + (2*WEEK)**2)) ), # Approx Avg: 6.5 weeks, Combined Std Dev

    # Quality Inspection to Product Testing: Spans QI->CA and CA->PT.
    ('QI', 'PT'): ( (2 * DAY) + (5 * DAY), math.ceil(math.sqrt((1*DAY)**2 + (2*DAY)**2)) ), # Avg: 7 days, Combined Std Dev

    # Component Assembly to Warehouse Storage: Spans CA->PT, PT->PK, PK->WS.
    ('CA', 'WS'): ( (5 * DAY) + (1.5 * DAY) + (0.5 * DAY), math.ceil(math.sqrt((2*DAY)**2 + (1*DAY)**2 + (0.25*DAY)**2)) ), # Avg: 7 days, Combined Std Dev

    # Order Placement to Quality Inspection: Spans OP->RC and RC->QI. Variability dominated by OP->RC.
    ('OP', 'QI'): ( (6 * WEEK) + (1 * DAY), math.ceil(math.sqrt((2*WEEK)**2 + (0.5*DAY)**2)) ), # Approx Avg: 6 weeks + 1 day, Combined Std Dev

    # Receive Components to Distribution: Spans RC->QI, QI->CA, CA->PT, PT->PK, PK->WS, WS->DT. Significant accumulated time and variability.
    ('RC', 'DT'): ( (1*DAY) + (2*DAY) + (5*DAY) + (1.5*DAY) + (0.5*DAY) + (1*WEEK),
                   math.ceil(math.sqrt((0.5*DAY)**2 + (1*DAY)**2 + (2*DAY)**2 + (1*DAY)**2 + (0.25*DAY)**2 + (1*WEEK)**2)) ), # Approx Avg: 2.7 weeks, Combined Std Dev

    # Supplier Selection to Distribution: Near full process span before AS. High accumulated time and variability.
    ('SS', 'DT'): ( (3*DAY) + (6*WEEK) + (1*DAY) + (2*DAY) + (5*DAY) + (1.5*DAY) + (0.5*DAY) + (1*WEEK),
                   math.ceil(math.sqrt((1*DAY)**2 + (2*WEEK)**2 + (0.5*DAY)**2 + (1*DAY)**2 + (2*DAY)**2 + (1*DAY)**2 + (0.25*DAY)**2 + (1*WEEK)**2)) ), # Approx Avg: 9 weeks, Combined Std Dev

    # Component Assembly to After-Sales Support: From mid-process to post-delivery.
    ('CA', 'AS'): ( (5*DAY) + (1.5*DAY) + (0.5*DAY) + (1*WEEK) + (4*WEEK),
                    math.ceil(math.sqrt((2*DAY)**2 + (1*DAY)**2 + (0.25*DAY)**2 + (1*WEEK)**2 + (2*WEEK)**2)) ), # Approx Avg: 6 weeks, Combined Std Dev

    # Order Placement to After-Sales Support: Spans most of the process. Very high accumulated time and variability.
    ('OP', 'AS'): ( (6*WEEK) + (1*DAY) + (2*DAY) + (5*DAY) + (1.5*DAY) + (0.5*DAY) + (1*WEEK) + (4*WEEK),
                   math.ceil(math.sqrt((2*WEEK)**2 + (0.5*DAY)**2 + (1*DAY)**2 + (2*DAY)**2 + (1*DAY)**2 + (0.25*DAY)**2 + (1*WEEK)**2 + (2*WEEK)**2)) ), # Approx Avg: 11.5 weeks, Combined Std Dev
}

# Print the dictionary (optional, for verification)
# import pprint
# pprint.pprint(temporal_profile)

# Example: Accessing data for ('OP', 'RC')
# avg_op_rc, stdev_op_rc = temporal_profile[('OP', 'RC')]
# print(f"Average time between OP and RC: {avg_op_rc / DAY:.1f} days")
# print(f"Std Dev time between OP and RC: {stdev_op_rc / DAY:.1f} days")
```

**Explanation:**

1.  **Activity Pairs:** The dictionary includes pairs representing direct succession (e.g., `('SS', 'OP')`, `('OP', 'RC')`) as well as pairs separated by multiple steps (e.g., `('SS', 'RC')`, `('QI', 'PT')`, `('RC', 'DT')`, `('SS', 'DT')`, `('OP', 'AS')`). This addresses the requirement to consider activities that *eventually* follow each other and adds complexity.
2.  **Time Estimations (Average):**
    *   Times are estimated based on the nature of the activities in a complex, global, high-tech supply chain.
    *   Steps involving external parties, shipping, or complex processing (`OP` to `RC`, `CA` to `PT`, `WS` to `DT`, `DT` to `AS`) are given longer average times (weeks).
    *   Internal handling or simpler steps (`RC` to `QI`, `PK` to `WS`) are given shorter average times (days or fractions of days).
    *   For longer gaps, averages are roughly additive based on the intermediate steps (though in reality, process variations might alter this).
3.  **Time Estimations (Standard Deviation):**
    *   Standard deviations reflect the *variability* expected.
    *   Steps with high uncertainty (supplier lead times, shipping, quality issues, demand fluctuations affecting storage) are given higher standard deviations, often a significant fraction of the average time (e.g., `('OP', 'RC')`, `('WS', 'DT')`).
    *   More predictable internal steps have lower standard deviations relative to their averages.
    *   For longer gaps, standard deviations are estimated using the formula for the standard deviation of a sum of *independent* random variables (variances add, so `stdev = sqrt(sum(stdev_i^2))`). This provides a more principled estimate than simply adding standard deviations, acknowledging that variability accumulates but not linearly.
4.  **Units:** All times are provided in seconds, as requested, using helper constants (`DAY`, `WEEK`) for clarity during estimation.
5.  **Format:** The output is a Python dictionary with `(activity1, activity2)` tuples as keys and `(average_time_seconds, std_dev_seconds)` tuples as values.