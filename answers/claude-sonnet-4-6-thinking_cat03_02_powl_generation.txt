## POWL Model for Corporate Network Provisioning Process

### Step-by-Step Analysis

| Step | Structure | POWL Construct |
|------|-----------|----------------|
| 1 | SR then CS (sequential) | Partial Order edge |
| 2 | DA  ACI (concurrent) | `StrictPartialOrder` (no edges) |
| 3 | BNC  optional D&R, repeat | `*(BNC, D&R)` |
| 4 | CD **or** MD | `X(CD, MD)` |
| 5–6 | QA  SA  GLA | `StrictPartialOrder` with edges |

---

### Python Code

```python
import pm4py
from pm4py.objects.powl.obj import (
    StrictPartialOrder,
    OperatorPOWL,
    Transition,
    SilentTransition,
)
from pm4py.objects.process_tree.obj import Operator


#  1. Define all atomic activities 

SR  = Transition(label="SR")   # Service Request verification
CS  = Transition(label="CS")   # Contract Setup

DA  = Transition(label="DA")   # Datacenter Allocation
ACI = Transition(label="ACI")  # Access Control Initialization

BNC = Transition(label="BNC")  # Base Network Configuration
DR  = Transition(label="D&R")  # Debug & Reconfigure

CD  = Transition(label="CD")   # Containerized Deployment
MD  = Transition(label="MD")   # Monolithic Deployment

QA  = Transition(label="QA")   # Quality Assurance
SA  = Transition(label="SA")   # Security Audit
GLA = Transition(label="GLA")  # Go-Live Approval


#  2. Concurrent block: DA  ACI 
# No ordering edges  both activities are fully concurrent.

concurrent_da_aci = StrictPartialOrder(nodes=[DA, ACI])
# (no edges added — DA and ACI execute in any order / in parallel)


#  3. Loop: BNC then optionally D&R, repeating until stable 
# *(BNC, D&R)    execute BNC; either exit OR execute D&R then BNC again.

loop_config = OperatorPOWL(
    operator=Operator.LOOP,
    children=[BNC, DR],
)


#  4. Exclusive choice: Containerized OR Monolithic deployment 

xor_deploy = OperatorPOWL(
    operator=Operator.XOR,
    children=[CD, MD],
)


#  5–6. Final partial order: QA  SA, both must finish before GLA 
# QA and SA have no ordering between them (concurrent).
# GLA depends on BOTH QA and SA being completed first.

po_final = StrictPartialOrder(nodes=[QA, SA, GLA])
po_final.order.add_edge(QA, GLA)   # GLA waits for QA
po_final.order.add_edge(SA, GLA)   # GLA waits for SA
# QA and SA themselves have no edge  they are concurrent


#  Root: assemble the full process as a top-level partial order 
#
#  SR  CS  concurrent_da_aci  loop_config  xor_deploy  po_final
#
# Each arrow represents a strict sequential dependency.

root = StrictPartialOrder(
    nodes=[SR, CS, concurrent_da_aci, loop_config, xor_deploy, po_final],
)

root.order.add_edge(SR,               CS)                # CS only after SR
root.order.add_edge(CS,               concurrent_da_aci) # DA/ACI only after CS
root.order.add_edge(concurrent_da_aci, loop_config)      # loop only after DAACI
root.order.add_edge(loop_config,       xor_deploy)       # deploy only after loop
root.order.add_edge(xor_deploy,        po_final)         # QA/SA/GLA only after deploy
```

---

### Explanation of Key Design Decisions

```
SR
 
 
CS
 
 

  StrictPartialOrder (no edges)  
   DA            ACI                concurrent

 
 
*(BNC, D&R)                           loop until stable
 
 
X(CD, MD)                             exactly one deployment chosen
 
 

  StrictPartialOrder                      
   QA                                  
         GLA                          
   SA                                    QASA  GLA

```

| Construct | Reason |
|-----------|--------|
| `concurrent_da_aci` with no edges | DA and ACI are independent — no ordering needed |
| `*(BNC, DR)` | BNC must run at least once; D&R is the optional "redo" body |
| `X(CD, MD)` | Exactly one deployment strategy is chosen — strict XOR |
| `po_final` with two edges into GLA | QA and SA can run concurrently but GLA needs both done |
| Single top-level `StrictPartialOrder` | Chains all phases sequentially at the outermost level |