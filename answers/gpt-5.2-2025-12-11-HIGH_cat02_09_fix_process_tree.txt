## 1) What’s wrong with the current (underfitting) model?

The problem is the **PARALLEL (AND) block** that contains:

- `Create_Purchase_Order`
- `Receive_Goods`
- `Receive_Invoice`
- `Match_Invoice_to_PO`
- `Pay_Invoice`

Putting these in parallel means the model allows **any interleaving / ordering** among them, including clearly incorrect behavior such as:

- Paying before the invoice is received (`Pay_Invoice` before `Receive_Invoice`)
- Paying before matching (`Pay_Invoice` before `Match_Invoice_to_PO`)
- Matching before invoice or goods exist (`Match_Invoice_to_PO` before `Receive_Invoice` and/or `Receive_Goods`)
- Receiving goods or invoice before the PO exists (`Receive_*` before `Create_Purchase_Order`)
- Creating the PO after downstream steps

In a normal Procure-to-Pay flow, these constraints should hold:

**Strict sequence (must be ordered):**
- `Create_Purchase_Requisition`  `Approve_Purchase_Requisition`  `Create_Purchase_Order`

**Preconditions / gating:**
- `Match_Invoice_to_PO` should happen **only after** both `Receive_Goods` and `Receive_Invoice` have occurred (and after PO exists).
- `Pay_Invoice` should happen **only after** the match.
- `Close_Case` should happen **only after** payment (in this simplified model).

**Potential concurrency (the only reasonable parallelism here):**
- `Receive_Goods` and `Receive_Invoice` may occur in either order (and can be modeled as parallel / order-independent), but **matching must wait for both**.

---

## 2) Corrected (fixed) process tree model

This version keeps **all the same activities** but replaces the overly-broad parallel block with a domain-consistent structure:

- Upstream steps in sequence
- Only `Receive_Goods` and `Receive_Invoice` in parallel (order-independent)
- Then match, pay, close in sequence

```python
from pm4py.objects.process_tree.obj import Operator, ProcessTree

# Define activities
create_req = ProcessTree(label="Create_Purchase_Requisition")
approve_req = ProcessTree(label="Approve_Purchase_Requisition")
create_po = ProcessTree(label="Create_Purchase_Order")
receive_goods = ProcessTree(label="Receive_Goods")
receive_invoice = ProcessTree(label="Receive_Invoice")
match_invoice = ProcessTree(label="Match_Invoice_to_PO")
pay_invoice = ProcessTree(label="Pay_Invoice")
close_case = ProcessTree(label="Close_Case")

# Only these two can be order-independent; matching requires both to be completed.
receipts_parallel = ProcessTree(operator=Operator.PARALLEL, children=[
    receive_goods,
    receive_invoice
])

# Enforced Procure-to-Pay order
root = ProcessTree(operator=Operator.SEQUENCE, children=[
    create_req,
    approve_req,
    create_po,
    receipts_parallel,
    match_invoice,
    pay_invoice,
    close_case
])
```

---

## 3) Why the updated tree conforms and prevents unwanted behavior

This fixed tree enforces the intended logic by construction:

- **No downstream activity can happen before upstream prerequisites**, because everything is placed in a **SEQUENCE** up to PO creation.
- The only “out-of-order” freedom allowed is **between `Receive_Goods` and `Receive_Invoice`**, which is realistic (either can arrive first).
- `Match_Invoice_to_PO` is placed **after** the parallel receipts block, which guarantees that **both goods receipt and invoice receipt have occurred** before matching is possible.
- `Pay_Invoice` is **after** matching, preventing payment before match.
- `Close_Case` is last, preventing premature closure.

Result: the model no longer permits the underfitting behaviors (e.g., pay-before-invoice, match-before-receipt, receive-before-PO) while still allowing the only commonly acceptable flexibility (invoice and goods can be received in either order).