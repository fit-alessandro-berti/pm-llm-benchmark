Here's a DuckDB SQL query that solves this problem by identifying top K process variants and returning their events:

```sql
WITH case_sequences AS (
  -- Step 1: Construct ordered activity sequences per case
  SELECT 
    case_id,
    STRING_AGG(activity, ' -> ' ORDER BY timestamp) AS activity_sequence
  FROM event_log
  GROUP BY case_id
),
variant_counts AS (
  -- Step 2: Count cases per variant and rank by frequency
  SELECT 
    activity_sequence,
    COUNT(*) as case_count,
    DENSE_RANK() OVER (ORDER BY COUNT(*) DESC) as variant_rank
  FROM case_sequences
  GROUP BY activity_sequence
),
top_k_variants AS (
  -- Step 3: Filter to top K variants (change K value as needed)
  SELECT 
    activity_sequence,
    case_count
  FROM variant_counts
  WHERE variant_rank <= 5  -- K = 5, adjust this value as needed
),
top_k_cases AS (
  -- Step 4: Get case_ids belonging to top K variants
  SELECT 
    cs.case_id
  FROM case_sequences cs
  INNER JOIN top_k_variants tkv ON cs.activity_sequence = tkv.activity_sequence
)
-- Step 5: Return all events from cases in top K variants
SELECT 
  el.*
FROM event_log el
INNER JOIN top_k_cases tkc ON el.case_id = tkc.case_id
ORDER BY el.case_id, el.timestamp;
```

**Explanation of the approach:**

1. **`case_sequences` CTE**: 
   - Groups events by `case_id` and uses `STRING_AGG()` with `ORDER BY timestamp` to create ordered activity sequences
   - The `' -> '` delimiter clearly shows the sequence flow, but you can change this to any delimiter

2. **`variant_counts` CTE**:
   - Groups by the complete activity sequence to identify unique variants
   - Uses `COUNT(*)` to get the number of cases per variant
   - Uses `DENSE_RANK()` to rank variants by frequency (descending order)

3. **`top_k_variants` CTE**:
   - Filters to only the top K variants using `WHERE variant_rank <= K`
   - Change `5` to your desired K value

4. **`top_k_cases` CTE**:
   - Joins back to the original sequences to get the `case_id`s that belong to top K variants

5. **Final SELECT**:
   - Returns all events from the original log for cases in top K variants
   - Maintains original event order within each case

**Alternative approach using LIST aggregate function** (if you prefer arrays over strings):

```sql
WITH case_sequences AS (
  SELECT 
    case_id,
    LIST(activity ORDER BY timestamp) AS activity_sequence
  FROM event_log
  GROUP BY case_id
),
-- ... rest of the CTEs remain similar, but join on array equality
```

**Key advantages of this solution:**
- Handles edge cases like empty cases or single-activity cases
- Uses window functions for efficient ranking
- Maintains the original event data structure in the output
- Easily adjustable K value for top variants
- Clear, modular CTE structure for readability and debugging

The query will return all events from cases that follow the most common process variants, allowing you to analyze the dominant process patterns in your event log.