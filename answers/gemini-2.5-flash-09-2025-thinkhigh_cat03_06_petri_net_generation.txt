This solution constructs the accepting Petri net by defining places, the 10 required labeled transitions representing the activities, and silent transitions (unlabeled) where necessary to manage the complex splits and joins required for the loops (DV/RDS and FC/II).

```python
from pm4py.objects.petri_net.obj import PetriNet, Marking
from pm4py.objects.petri_net.utils import petri_utils

# 1. Initialize Petri Net
net = PetriNet(name="Insurance_Claim_Process")

# 2. Define Places (States)
p_s = PetriNet.Place("P_Start")           # Claim filed
p_reg = PetriNet.Place("P_Registered")    # After CR, before DV loop start
p_dv_decide = PetriNet.Place("P_DV_Decide") # After DV, decision point for RDS or proceeding
p_fc_start = PetriNet.Place("P_FC_Start")   # Input place for Fraud Check phase (receives tokens from DV success or II re-loop)
p_fc_decide = PetriNet.Place("P_FC_Decide") # After FC, decision point for II or CA
p_ca_ready = PetriNet.Place("P_CA_Ready")   # After successful FC/II loop, ready for CA
p_ap_ready = PetriNet.Place("P_AP_Ready")   # After CA, ready for AP
p_p_ready = PetriNet.Place("P_P_Ready")     # After AP, ready for P
p_n_ready = PetriNet.Place("P_N_Ready")     # After P, ready for N
p_cl_ready = PetriNet.Place("P_CL_Ready")   # After N, ready for CL
p_e = PetriNet.Place("P_End")             # Claim closed

net.places.update([p_s, p_reg, p_dv_decide, p_fc_start, p_fc_decide, p_ca_ready, 
                   p_ap_ready, p_p_ready, p_n_ready, p_cl_ready, p_e])


# 3. Define Transitions (Activities, Labeled)
t_cr = PetriNet.Transition(name="t_cr", label="Claim Registration (CR)")
t_dv = PetriNet.Transition(name="t_dv", label="Document Verification (DV)")
t_rds = PetriNet.Transition(name="t_rds", label="Re-Document Submission (RDS)")
t_fc = PetriNet.Transition(name="t_fc", label="Fraud Check (FC)")
t_ii = PetriNet.Transition(name="t_ii", label="In-depth Investigation (II)")
t_ca = PetriNet.Transition(name="t_ca", label="Claim Assessment (CA)")
t_ap = PetriNet.Transition(name="t_ap", label="Approval (AP)")
t_p = PetriNet.Transition(name="t_p", label="Payment (P)")
t_n = PetriNet.Transition(name="t_n", label="Notification (N)")
t_cl = PetriNet.Transition(name="t_cl", label="Closure (CL)")

net.transitions.update([t_cr, t_dv, t_rds, t_fc, t_ii, t_ca, t_ap, t_p, t_n, t_cl])

# 4. Define Silent Transitions for Routing (Unlabeled)
# t_skip_doc: Transition if DV is successful, moves token to FC phase
t_skip_doc = PetriNet.Transition(name="t_skip_doc")
# t_reloop_fc: Transition if II is done, moves token back to FC start
t_reloop_fc = PetriNet.Transition(name="t_reloop_fc")

net.transitions.update([t_skip_doc, t_reloop_fc])

# 5. Define Arcs (Control Flow)

# Initial sequence: Start -> CR -> Registered
petri_utils.add_arc_from_to(p_s, t_cr, net)
petri_utils.add_arc_from_to(t_cr, p_reg, net)

# --- DV/RDS Loop ---
petri_utils.add_arc_from_to(p_reg, t_dv, net)
petri_utils.add_arc_from_to(t_dv, p_dv_decide, net)

# 5a. Loop Back (Documents incomplete): DV_Decide -> RDS -> Registered
petri_utils.add_arc_from_to(p_dv_decide, t_rds, net)
petri_utils.add_arc_from_to(t_rds, p_reg, net)

# 5b. Exit Loop (Documents complete): DV_Decide -> Silent -> FC_Start
petri_utils.add_arc_from_to(p_dv_decide, t_skip_doc, net)
petri_utils.add_arc_from_to(t_skip_doc, p_fc_start, net)

# --- FC/II Loop ---
# FC_Start is the common input place for FC
petri_utils.add_arc_from_to(p_fc_start, t_fc, net)
petri_utils.add_arc_from_to(t_fc, p_fc_decide, net)

# 5c. Loop Back (Investigation needed): FC_Decide -> II -> Silent -> FC_Start
petri_utils.add_arc_from_to(p_fc_decide, t_ii, net)
petri_utils.add_arc_from_to(t_ii, t_reloop_fc, net)
petri_utils.add_arc_from_to(t_reloop_fc, p_fc_start, net) # Loops back to re-run FC

# 5d. Exit Loop (Fraud check passed): FC_Decide -> CA
petri_utils.add_arc_from_to(p_fc_decide, t_ca, net)
petri_utils.add_arc_from_to(t_ca, p_ca_ready, net)

# --- Assessment, Approval, Payment ---
petri_utils.add_arc_from_to(p_ca_ready, t_ap, net)
petri_utils.add_arc_from_to(t_ap, p_ap_ready, net)
petri_utils.add_arc_from_to(p_ap_ready, t_p, net)
petri_utils.add_arc_from_to(t_p, p_p_ready, net)

# --- Notification and Closure ---
petri_utils.add_arc_from_to(p_p_ready, t_n, net)
petri_utils.add_arc_from_to(t_n, p_n_ready, net)
petri_utils.add_arc_from_to(p_n_ready, t_cl, net)
petri_utils.add_arc_from_to(t_cl, p_e, net)

# 6. Define Initial and Final Markings

# Initial marking: Token in P_Start
im = Marking()
im[p_s] = 1

# Final marking: Token in P_End (Claim closed)
fm = Marking()
fm[p_e] = 1

# Output verification (Optional, for debugging)
# print("Petri Net Construction Complete.")
# print(f"Initial Marking: {im}")
# print(f"Final Marking: {fm}")
```