Anomalies seen in the temporal profile
- R  P: Mean  25h with very low STDEV (1h). Approvals appear to occur on a rigid cadence, suggestive of a batch or scheduled job.
- P  N: Very long mean (7 days) and high variability (±2 days). Indicates queueing, backlog, or inconsistent notifier behavior.
- A  C: Fast closure (2h on average). Implies some claims close without visible E or P in between, possibly early withdrawals, duplicates, or auto-closure.
- E  N: Extremely short mean (5 minutes). Either notification is automated immediately after evaluation, or notification is sent before proper approval in some cases.

Hypotheses
- R  P low variance: Daily batch approval window; SLA timer that auto-approves after a fixed delay; approval by “system” resource at fixed times.
- P  N long/variable: Manual notification backlog; different channels (email vs mail) with different SLAs; regional or claim-type routing delays; notifier role turnover/shifts.
- A  C quick close: Auto-closure of incomplete/duplicate claims; customer withdrawal recorded as Close; rejection path not explicitly modeled (closing without P).
- E  N too fast (and potentially before P): Auto-notify of “evaluation received” (premature notification); mislabeling N type (e.g., internal notification logged as customer notification); parallel steps with missing prerequisite checks.

Verification SQL (PostgreSQL)

Note: The CTEs below are reusable. They (a) compute the first occurrence of activities per claim and (b) compute “eventually-followed” pair durations (second event strictly after first).

1) Reusable pair-duration engine with the given temporal profile and z-score outlier detection
-- Adjust zeta if needed
WITH params AS (
  SELECT 3.0::numeric AS zeta
),
profile AS (
  -- avg and sd in seconds
  SELECT * FROM (VALUES
    ('R','A',  3600::numeric,    600::numeric),
    ('R','E', 86400::numeric,  28800::numeric),
    ('R','P', 90000::numeric,   3600::numeric),
    ('A','C',  7200::numeric,   3600::numeric),
    ('E','N',   300::numeric,     60::numeric),
    ('E','C',  3600::numeric,   3000::numeric),
    ('P','N', 604800::numeric, 172800::numeric),
    ('N','C',  1800::numeric,    300::numeric)
  ) AS v(a1, a2, avg_sec, sd_sec)
),
claims_list AS (
  SELECT DISTINCT claim_id FROM claim_events
),
pair_durations AS (
  -- For each claim and each (a1,a2), get t1 = earliest a1, t2 = earliest a2 strictly after t1
  SELECT
    cl.claim_id, p.a1, p.a2, p.avg_sec, p.sd_sec,
    t1.t1, t2.t2,
    EXTRACT(EPOCH FROM (t2.t2 - t1.t1))::numeric AS dur_sec
  FROM claims_list cl
  CROSS JOIN profile p
  LEFT JOIN LATERAL (
    SELECT MIN(ce."timestamp") AS t1
    FROM claim_events ce
    WHERE ce.claim_id = cl.claim_id AND ce.activity = p.a1
  ) AS t1 ON TRUE
  LEFT JOIN LATERAL (
    SELECT MIN(ce."timestamp") AS t2
    FROM claim_events ce
    WHERE ce.claim_id = cl.claim_id
      AND ce.activity = p.a2
      AND t1.t1 IS NOT NULL
      AND ce."timestamp" > t1.t1
  ) AS t2 ON TRUE
  WHERE t1.t1 IS NOT NULL AND t2.t2 IS NOT NULL
),
pair_outliers AS (
  SELECT pd.*,
         CASE WHEN sd_sec = 0 THEN NULL ELSE (pd.dur_sec - pd.avg_sec) / sd_sec END AS z
  FROM pair_durations pd
)
SELECT *
FROM pair_outliers, params
WHERE z IS NOT NULL AND ABS(z) > params.zeta
ORDER BY ABS(z) DESC
LIMIT 200;


2) R  P: spot outliers and test for “batch/scheduled” approvals
-- Claims far from the tight band (avg ± 2*sd) for R->P
WITH pd AS (
  SELECT *
  FROM (
    -- reuse pair_durations CTE from query (1) or inline again
    WITH profile AS (
      SELECT 'R'::text AS a1, 'P'::text AS a2, 90000::numeric AS avg_sec, 3600::numeric AS sd_sec
    ),
    claims_list AS (SELECT DISTINCT claim_id FROM claim_events),
    pair_durations AS (
      SELECT
        cl.claim_id, p.a1, p.a2, p.avg_sec, p.sd_sec,
        t1.t1 AS r_time, t2.t2 AS p_time,
        EXTRACT(EPOCH FROM (t2.t2 - t1.t1))::numeric AS dur_sec
      FROM claims_list cl
      CROSS JOIN profile p
      LEFT JOIN LATERAL (
        SELECT MIN(ce."timestamp") AS t1
        FROM claim_events ce
        WHERE ce.claim_id = cl.claim_id AND ce.activity = p.a1
      ) AS t1 ON TRUE
      LEFT JOIN LATERAL (
        SELECT MIN(ce."timestamp") AS t2
        FROM claim_events ce
        WHERE ce.claim_id = cl.claim_id
          AND ce.activity = p.a2
          AND t1.t1 IS NOT NULL
          AND ce."timestamp" > t1.t1
      ) AS t2 ON TRUE
      WHERE t1.t1 IS NOT NULL AND t2.t2 IS NOT NULL
    )
    SELECT * FROM pair_durations
  ) s
)
SELECT pd.claim_id, pd.dur_sec,
       (pd.dur_sec - pd.avg_sec) / pd.sd_sec AS z,
       c.claim_type
FROM pd
JOIN claims c USING (claim_id)
WHERE ABS((pd.dur_sec - pd.avg_sec) / pd.sd_sec) > 2
ORDER BY z DESC;

-- Are approvals batched at fixed times of day?
WITH first_p AS (
  SELECT DISTINCT ON (claim_id)
    claim_id, "timestamp" AS p_time
  FROM claim_events
  WHERE activity = 'P'
  ORDER BY claim_id, "timestamp"
)
SELECT to_char(p_time, 'HH24:MI') AS approval_time_of_day,
       COUNT(*) AS approvals
FROM first_p
GROUP BY 1
ORDER BY approvals DESC
LIMIT 24;

-- Are many R->P durations almost identical (±30 min)?
WITH rp AS (
  SELECT ce1.claim_id,
         MIN(ce1."timestamp") AS r_time,
         MIN(ce2."timestamp") AS p_time
  FROM claim_events ce1
  JOIN claim_events ce2
    ON ce2.claim_id = ce1.claim_id AND ce2.activity = 'P' AND ce2."timestamp" > ce1."timestamp"
  WHERE ce1.activity = 'R'
  GROUP BY ce1.claim_id
)
SELECT
  COUNT(*) FILTER (WHERE ABS(EXTRACT(EPOCH FROM (p_time - r_time)) - 90000) <= 1800) AS within_30min_of_avg,
  COUNT(*) AS total
FROM rp;


3) P  N: long/variable delays; correlate by notifier, claim type, and region of approver
-- Extremes: notify > 10 days or < 1 hour after approval
WITH pn AS (
  SELECT
    p.claim_id, p.p_time, n.n_time,
    EXTRACT(EPOCH FROM (n.n_time - p.p_time)) AS sec_pn,
    p.p_resource, n.n_resource
  FROM
    (SELECT DISTINCT ON (claim_id)
       claim_id, "timestamp" AS p_time, resource AS p_resource
     FROM claim_events
     WHERE activity = 'P'
     ORDER BY claim_id, "timestamp") p
  JOIN
    (SELECT DISTINCT ON (claim_id)
       claim_id, "timestamp" AS n_time, resource AS n_resource
     FROM claim_events
     WHERE activity = 'N'
     ORDER BY claim_id, "timestamp") n
    ON n.claim_id = p.claim_id AND n.n_time > p.p_time
)
SELECT pn.claim_id, c.claim_type, c.claim_amount, pn.sec_pn/3600.0 AS hours_p_to_n,
       pn.n_resource AS notifier,
       a.region AS approver_region, a.specialization AS approver_spec
FROM pn
LEFT JOIN claims c USING (claim_id)
LEFT JOIN adjusters a ON lower(a.name) = lower(pn.p_resource)
WHERE sec_pn > 10*24*3600 OR sec_pn < 3600
ORDER BY sec_pn DESC;

-- Aggregated view: average P->N delay by notifier and approver region
WITH pn AS (
  SELECT
    p.claim_id, p.p_time, n.n_time,
    EXTRACT(EPOCH FROM (n.n_time - p.p_time)) AS sec_pn,
    p.p_resource, n.n_resource
  FROM
    (SELECT DISTINCT ON (claim_id) claim_id, "timestamp" AS p_time, resource AS p_resource
     FROM claim_events WHERE activity = 'P' ORDER BY claim_id, "timestamp") p
  JOIN
    (SELECT DISTINCT ON (claim_id) claim_id, "timestamp" AS n_time, resource AS n_resource
     FROM claim_events WHERE activity = 'N' ORDER BY claim_id, "timestamp") n
    ON n.claim_id = p.claim_id AND n.n_time > p.p_time
)
SELECT
  COALESCE(n_resource, 'unknown') AS notifier,
  COALESCE(a.region, 'unknown') AS approver_region,
  COUNT(*) AS cnt,
  ROUND(AVG(sec_pn)/3600.0, 2) AS avg_hours,
  ROUND(PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY sec_pn)/3600.0, 2) AS p50_hours,
  ROUND(PERCENTILE_CONT(0.9) WITHIN GROUP (ORDER BY sec_pn)/3600.0, 2) AS p90_hours
FROM pn
LEFT JOIN adjusters a ON lower(a.name) = lower(pn.p_resource)
GROUP BY 1,2
ORDER BY avg_hours DESC;


4) A  C: fast closures without E or P in between
-- Claims closed within 2 hours of assignment AND no E or P between A and C
WITH first_a AS (
  SELECT DISTINCT ON (claim_id) claim_id, "timestamp" AS a_time
  FROM claim_events
  WHERE activity = 'A'
  ORDER BY claim_id, "timestamp"
),
first_c AS (
  SELECT DISTINCT ON (claim_id) claim_id, "timestamp" AS c_time, resource AS c_resource, additional_info
  FROM claim_events
  WHERE activity = 'C'
  ORDER BY claim_id, "timestamp"
)
SELECT ac.claim_id, c.claim_type,
       ac.a_time, ac.c_time,
       ROUND(EXTRACT(EPOCH FROM (ac.c_time - ac.a_time))/3600.0, 2) AS hours_a_to_c,
       fc.c_resource, fc.additional_info
FROM (
  SELECT a.claim_id, a.a_time, c.c_time
  FROM first_a a
  JOIN first_c c ON c.claim_id = a.claim_id
  WHERE c.c_time > a.a_time
    AND EXTRACT(EPOCH FROM (c.c_time - a.a_time)) <= 2*3600
) ac
JOIN claims c USING (claim_id)
JOIN first_c fc ON fc.claim_id = ac.claim_id
WHERE NOT EXISTS (
  SELECT 1 FROM claim_events ce
  WHERE ce.claim_id = ac.claim_id
    AND ce.activity IN ('E','P')
    AND ce."timestamp" > ac.a_time
    AND ce."timestamp" < ac.c_time
)
ORDER BY hours_a_to_c;


5) E  N: very fast notifications and order violations relative to approval
-- N within 5 minutes of E and (P missing or happens after N)
WITH first_e AS (
  SELECT DISTINCT ON (claim_id) claim_id, "timestamp" AS e_time, resource AS e_resource
  FROM claim_events WHERE activity = 'E' ORDER BY claim_id, "timestamp"
),
first_n AS (
  SELECT DISTINCT ON (claim_id) claim_id, "timestamp" AS n_time, resource AS n_resource
  FROM claim_events WHERE activity = 'N' ORDER BY claim_id, "timestamp"
),
first_p AS (
  SELECT DISTINCT ON (claim_id) claim_id, "timestamp" AS p_time
  FROM claim_events WHERE activity = 'P' ORDER BY claim_id, "timestamp"
)
SELECT en.claim_id, c.claim_type,
       ROUND(EXTRACT(EPOCH FROM (en.n_time - en.e_time)), 0) AS sec_e_to_n,
       en.e_resource, en.n_resource, p.p_time
FROM (
  SELECT e.claim_id, e.e_time, n.n_time, e.e_resource, n.n_resource
  FROM first_e e
  JOIN first_n n ON n.claim_id = e.claim_id AND n.n_time > e.e_time
  WHERE EXTRACT(EPOCH FROM (n.n_time - e.e_time)) <= 5*60
) en
LEFT JOIN first_p p ON p.claim_id = en.claim_id
JOIN claims c USING (claim_id)
WHERE p.p_time IS NULL OR p.p_time > en.n_time
ORDER BY sec_e_to_n;


6) Order conformance checks for the intended R  A  E  P  N  C sequence
-- N before P (violates intended order)
SELECT ce1.claim_id
FROM claim_events ce1
JOIN claim_events ce2
  ON ce2.claim_id = ce1.claim_id
WHERE ce1.activity = 'N'
  AND ce2.activity = 'P'
  AND ce1."timestamp" < ce2."timestamp"
GROUP BY ce1.claim_id;

-- C before P or C before E (premature closure)
SELECT ceC.claim_id,
       MIN(ceC."timestamp") AS first_close,
       MIN(ceP."timestamp") AS first_approve,
       MIN(ceE."timestamp") AS first_eval
FROM claim_events ceC
LEFT JOIN claim_events ceP ON ceP.claim_id = ceC.claim_id AND ceP.activity = 'P'
LEFT JOIN claim_events ceE ON ceE.claim_id = ceC.claim_id AND ceE.activity = 'E'
WHERE ceC.activity = 'C'
GROUP BY ceC.claim_id
HAVING MIN(ceC."timestamp") < COALESCE(MIN(ceP."timestamp"), 'infinity'::timestamp)
    OR MIN(ceC."timestamp") < COALESCE(MIN(ceE."timestamp"), 'infinity'::timestamp);


7) Segment analysis: outlier rate by claim type and region (example for P  N)
WITH params AS (SELECT 3.0::numeric AS zeta),
pn AS (
  SELECT
    cl.claim_id, c.claim_type,
    p."timestamp" AS p_time, p.resource AS p_resource,
    n."timestamp" AS n_time, n.resource AS n_resource,
    EXTRACT(EPOCH FROM (n."timestamp" - p."timestamp"))::numeric AS dur_sec
  FROM claims cl
  JOIN claim_events p ON p.claim_id = cl.claim_id AND p.activity = 'P'
  JOIN claim_events n ON n.claim_id = cl.claim_id AND n.activity = 'N' AND n."timestamp" > p."timestamp"
  QUALIFY ROW_NUMBER() OVER (PARTITION BY cl.claim_id, p.activity ORDER BY p."timestamp") = 1 -- if your PG version supports QUALIFY; if not, use DISTINCT ON pattern
),
pn_tagged AS (
  SELECT pn.*,
         (pn.dur_sec - 604800.0) / 172800.0 AS z           -- using profile (avg=604800, sd=172800)
  FROM pn
)
SELECT
  c.claim_type,
  COALESCE(a.region, 'unknown') AS approver_region,
  COUNT(*) AS total,
  COUNT(*) FILTER (WHERE ABS(z) > (SELECT zeta FROM params)) AS outliers,
  ROUND(100.0 * COUNT(*) FILTER (WHERE ABS(z) > (SELECT zeta FROM params)) / NULLIF(COUNT(*),0), 2) AS outlier_pct
FROM pn_tagged pn
JOIN claims c USING (claim_id)
LEFT JOIN adjusters a ON lower(a.name) = lower(pn.p_resource)
GROUP BY c.claim_type, approver_region
ORDER BY outlier_pct DESC, total DESC;

Practical follow-ups
- If R  P shows a sharp approval time-of-day peak and low variance, inspect P resources; if dominated by “system” or a single user and fixed clock times, it likely confirms batch scheduling.
- If P  N extremes cluster by notifier or region, review staffing/shift calendars and channel SLAs; check additional_info for channel or error codes.
- For A  C fast closes, sample additional_info for Close events to discover reasons (withdrawn, duplicate, incomplete).
- For E  N immediate notifications that precede P, review whether N is an internal acknowledgment vs final customer notification; consider splitting N into distinct event types.