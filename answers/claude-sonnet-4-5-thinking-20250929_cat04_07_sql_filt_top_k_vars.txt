# DuckDB SQL Query for Top K Process Variants

Here's a comprehensive solution with multiple approaches:

## **Solution 1: Complete Query with STRING_AGG (Most Readable)**

```sql
WITH case_variants AS (
    -- Step 1: Extract ordered sequence of activities per case
    SELECT 
        case_id,
        STRING_AGG(activity, ' -> ' ORDER BY timestamp) AS variant
    FROM event_log
    GROUP BY case_id
),
variant_counts AS (
    -- Step 2: Count cases per variant
    SELECT 
        variant,
        COUNT(*) AS case_count
    FROM case_variants
    GROUP BY variant
),
top_k_variants AS (
    -- Step 3: Identify top K variants
    SELECT variant
    FROM variant_counts
    ORDER BY case_count DESC
    LIMIT 5  -- Replace 5 with K
)
-- Step 4: Return all events from cases in top K variants
SELECT el.*
FROM event_log el
INNER JOIN case_variants cv ON el.case_id = cv.case_id
INNER JOIN top_k_variants tkv ON cv.variant = tkv.variant
ORDER BY el.case_id, el.timestamp;
```

---

## **Solution 2: Optimized with LIST (Better Performance)**

```sql
WITH case_variants AS (
    -- Use LIST to create array of activities (more efficient)
    SELECT 
        case_id,
        LIST(activity ORDER BY timestamp) AS variant_list
    FROM event_log
    GROUP BY case_id
),
variant_counts AS (
    -- Count and rank variants
    SELECT 
        variant_list,
        COUNT(*) AS case_count,
        ARRAY_AGG(case_id) AS case_ids  -- Collect all case_ids for this variant
    FROM case_variants
    GROUP BY variant_list
    ORDER BY case_count DESC
    LIMIT 5  -- Replace 5 with K
)
-- Filter events using UNNEST for efficient lookup
SELECT el.*
FROM event_log el
WHERE el.case_id IN (
    SELECT UNNEST(case_ids) 
    FROM variant_counts
)
ORDER BY el.case_id, el.timestamp;
```

---

## **Solution 3: With Variant Statistics (Enriched Output)**

```sql
WITH case_variants AS (
    SELECT 
        case_id,
        STRING_AGG(activity, ' -> ' ORDER BY timestamp) AS variant
    FROM event_log
    GROUP BY case_id
),
variant_counts AS (
    SELECT 
        variant,
        COUNT(*) AS case_count,
        ROW_NUMBER() OVER (ORDER BY COUNT(*) DESC) AS variant_rank
    FROM case_variants
    GROUP BY variant
),
top_k_variants AS (
    SELECT variant, case_count, variant_rank
    FROM variant_counts
    WHERE variant_rank <= 5  -- Replace 5 with K
)
-- Return events with variant metadata
SELECT 
    el.*,
    tkv.variant,
    tkv.case_count,
    tkv.variant_rank
FROM event_log el
INNER JOIN case_variants cv ON el.case_id = cv.case_id
INNER JOIN top_k_variants tkv ON cv.variant = tkv.variant
ORDER BY tkv.variant_rank, el.case_id, el.timestamp;
```

---

## **Solution 4: Parameterized with Variable K**

```sql
-- Set the K parameter
SET VARIABLE k_value = 5;

WITH case_variants AS (
    SELECT 
        case_id,
        STRING_AGG(activity, ' -> ' ORDER BY timestamp) AS variant
    FROM event_log
    GROUP BY case_id
),
variant_stats AS (
    SELECT 
        variant,
        COUNT(*) AS case_count,
        COUNT(*) * 100.0 / SUM(COUNT(*)) OVER () AS percentage
    FROM case_variants
    GROUP BY variant
    ORDER BY case_count DESC
    LIMIT getvariable('k_value')
)
SELECT el.*
FROM event_log el
WHERE el.case_id IN (
    SELECT cv.case_id
    FROM case_variants cv
    INNER JOIN variant_stats vs ON cv.variant = vs.variant
)
ORDER BY el.case_id, el.timestamp;
```

---

## **Key DuckDB Features Used:**

1. **`STRING_AGG(column, delimiter ORDER BY ...)`** - Concatenates strings with ordering
2. **`LIST(column ORDER BY ...)`** - Creates ordered arrays (more efficient than strings)
3. **`ARRAY_AGG()`** - Aggregates values into an array
4. **`UNNEST()`** - Expands arrays back into rows
5. **`ROW_NUMBER() OVER (ORDER BY ...)`** - Rankings for top-K selection
6. **CTEs (WITH clauses)** - For query readability and modularity

---

## **Example Usage:**

```sql
-- Create sample data
CREATE TABLE event_log (
    case_id VARCHAR,
    activity VARCHAR,
    timestamp TIMESTAMP
);

INSERT INTO event_log VALUES
    ('C1', 'Start', '2024-01-01 10:00:00'),
    ('C1', 'Review', '2024-01-01 10:30:00'),
    ('C1', 'Approve', '2024-01-01 11:00:00'),
    ('C2', 'Start', '2024-01-01 09:00:00'),
    ('C2', 'Review', '2024-01-01 09:30:00'),
    ('C2', 'Approve', '2024-01-01 10:00:00'),
    ('C3', 'Start', '2024-01-01 08:00:00'),
    ('C3', 'Review', '2024-01-01 08:30:00'),
    ('C3', 'Reject', '2024-01-01 09:00:00');

-- Run the query (Solution 1) with K=2
```

**Choose Solution 1 for readability, Solution 2 for performance on large datasets!**