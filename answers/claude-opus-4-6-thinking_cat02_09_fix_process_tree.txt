# Fixing the Underfitting Procure-to-Pay Process Tree

## 1. Issues Identified in the Current Model

The root cause of the underfitting is the **`PARALLEL` (AND) block** wrapping five activities that should mostly be sequential:

```
 (PARALLEL)
 Create_Purchase_Order         Can fire in ANY order
 Receive_Goods                
 Receive_Invoice              
 Match_Invoice_to_PO          
 Pay_Invoice                  
```

This allows **all of the following unwanted behaviors**:

| Unwanted Trace (Example) | Why It's Wrong |
|---|---|
| Pay_Invoice  Create_Purchase_Order | Paying before a PO even exists |
| Match_Invoice_to_PO  Receive_Invoice | Matching before the invoice arrives |
| Pay_Invoice  Receive_Goods | Paying before confirming delivery |
| Receive_Goods  Create_Purchase_Order | Receiving goods with no PO |
| Match_Invoice_to_PO  Receive_Goods | Matching before confirming receipt |

**Key domain constraints violated:**
- `Create_Purchase_Order` must precede `Receive_Goods` (you can't receive goods without a PO).
- `Receive_Invoice` and `Receive_Goods` must **both** complete before `Match_Invoice_to_PO` (3-way match requires PO, goods receipt, and invoice).
- `Match_Invoice_to_PO` must precede `Pay_Invoice` (no payment without a verified match).
- `Pay_Invoice` must precede `Close_Case`.

## 2. Corrected Process Tree Model

The key insight is that after the PO is created, **Receive Goods** and **Receive Invoice** are genuinely independent events (goods ship from the supplier; the invoice arrives separately). These two — and *only* these two — may occur in either order or concurrently. Everything else is strictly sequential.

```python
from pm4py.objects.process_tree.obj import Operator, ProcessTree

# Define activities (unchanged)
create_req = ProcessTree(label="Create_Purchase_Requisition")
approve_req = ProcessTree(label="Approve_Purchase_Requisition")
create_po = ProcessTree(label="Create_Purchase_Order")
receive_goods = ProcessTree(label="Receive_Goods")
receive_invoice = ProcessTree(label="Receive_Invoice")
match_invoice = ProcessTree(label="Match_Invoice_to_PO")
pay_invoice = ProcessTree(label="Pay_Invoice")
close_case = ProcessTree(label="Close_Case")

# FIXED: Only Receive_Goods and Receive_Invoice are parallel
# (they are independent arrivals); everything else is strictly sequential.
parallel_receive = ProcessTree(operator=Operator.PARALLEL, children=[
    receive_goods,
    receive_invoice
])

root = ProcessTree(operator=Operator.SEQUENCE, children=[
    create_req,        # Step 1
    approve_req,       # Step 2
    create_po,         # Step 3
    parallel_receive,  # Step 4 & 5 (either order)
    match_invoice,     # Step 6 (only after BOTH receipts)
    pay_invoice,       # Step 7
    close_case         # Step 8
])
```

### Visual Representation

```
  SEQUENCE
 Create_Purchase_Requisition
 Approve_Purchase_Requisition
 Create_Purchase_Order
   PARALLEL
    Receive_Goods
    Receive_Invoice
 Match_Invoice_to_PO
 Pay_Invoice
 Close_Case
```

## 3. How the Fixed Model Enforces Correct Behavior

### Constraint-by-Constraint Validation

| Domain Rule | How the Model Enforces It |
|---|---|
| Requisition before approval | Both in the top-level `SEQUENCE`, `create_req` at index 0, `approve_req` at index 1 |
| Approval before PO creation | `approve_req` (index 1) precedes `create_po` (index 2) in `SEQUENCE` |
| PO before any receiving | `create_po` (index 2) precedes `parallel_receive` (index 3) in `SEQUENCE` |
| Both goods & invoice received before matching | `PARALLEL` operator requires **all** children to complete before the sequence advances to `match_invoice` (index 4) |
| Goods & invoice may arrive in either order | `PARALLEL` operator allows `Receive_Goods` and `Receive_Invoice` to interleave freely |
| Matching before payment | `match_invoice` (index 4) precedes `pay_invoice` (index 5) in `SEQUENCE` |
| Payment before closing | `pay_invoice` (index 5) precedes `close_case` (index 6) in `SEQUENCE` |

### Allowed Traces (Exactly 2)

The model now permits only these two valid traces:

```
1. Create_Req  Approve_Req  Create_PO  Receive_Goods  Receive_Invoice  Match  Pay  Close
2. Create_Req  Approve_Req  Create_PO  Receive_Invoice  Receive_Goods  Match  Pay  Close
```

Both are domain-appropriate. Every unwanted trace (e.g., paying before matching, matching before receiving) is **structurally impossible** because the `SEQUENCE` operator enforces strict ordering, and the `PARALLEL` block is scoped to only the two genuinely independent activities.