<think>
We need to construct an accepting Petri net for the insurance claim management process described. Let's break down the process:

1. **Claim Registration (CR)**: Start of the process
2. **Document Verification (DV)**: After CR
3. **Re-Document Submission (RDS)**: Loop from DV if documents incomplete, back to DV after re-submission
4. **Fraud Check (FC)**: After DV
5. **In-depth Investigation (II)**: Loop from FC if fraud suspected, back to FC after investigation
6. **Claim Assessment (CA)**: After FC
7. **Approval (AP)**: After CA, but only if amount exceeds threshold
8. **Payment (P)**: After AP (or after CA if no approval needed)
9. **Notification (N)**: After P
10. **Closure (CL)**: After N, end of process

We need to create:
- Places representing states
- Transitions for each activity (with labels)
- Arcs connecting them
- Initial marking (token in start place)
- Final marking (token in end place)

Let's design the flow:

Start place (source) -> CR -> after_CR place -> DV -> after_DV place

From after_DV:
- If documents OK: -> FC -> after_FC place
- If documents incomplete: -> RDS -> back to DV

From after_FC:
- If no fraud: -> CA -> after_CA place
- If fraud suspected: -> II -> back to FC

From after_CA:
- If needs approval: -> AP -> after_AP place
- If no approval needed: -> P
- Wait, the description says "Approval (AP): The claim must be approved by a senior manager if the amount surpasses a certain threshold." This suggests AP is only needed sometimes. But Petri nets typically model optional paths. We need to model two paths from CA: one that goes through AP, and one that skips AP.

Actually, let's re-read: "The claim must be approved by a senior manager if the amount surpasses a certain threshold." This means sometimes we need AP, sometimes we don't. So after CA, we could have:
- If approval needed: CA -> AP -> P
- If approval not needed: CA -> P directly

But how to model this in a Petri net? We could use two transitions after CA, or have a place after CA that leads to either AP or P. Since transitions represent activities, and AP is an activity that may or may not happen, we need a branching point after CA.

Let me think about the structure:
- After CA, we have a place (let's call it after_CA)
- From after_CA, we could have two possible transitions:
  - If approval needed: AP (Approval) -> after_AP -> P
  - If approval not needed: P directly

But this is tricky because we need to model the choice. In Petri nets, choices are typically modeled by having multiple transitions enabled from the same place, and the choice is non-deterministic. For a deterministic choice based on data (like amount threshold), we'd need colored Petri nets or inhibitor arcs, but the problem doesn't mention that. So we'll just model both paths as possible.

Actually, a simpler approach: always have the AP step, but it could be instantaneous if threshold not met? No, that doesn't make sense.

Let me reconsider the process flow. The description says:
1. CR
2. DV
3. FC
4. CA
5. AP (if amount surpasses threshold)
6. P
7. N
8. CL

So AP is conditional. To model this, after CA we can have a place, then two transitions:
- One labeled "Approval" (for when needed)
- One labeled "Skip Approval" (for when not needed)

But the problem says "Approval (AP)" is a step, so it should be a transition with label "Approval". The alternative path is just proceeding to Payment directly.

Better design:
- After CA, we go to place "pending_approval_or_payment"
- From there, two transitions:
  - "Approval" transition (with label "Approval") -> place "after_approval"
  - "Skip Approval" transition (maybe with label None or "Skip Approval") -> place "after_approval"
- Then from "after_approval" -> Payment

Wait, but "Skip Approval" isn't really an activity in the process description. The process just bypasses AP if not needed. So perhaps:
- After CA, we have a place "after_CA"
- From "after_CA", either:
  - Transition "Approval" (label="Approval") -> place "after_AP"
  - Or directly to Payment transition

But then Payment would need to be connected from both "after_AP" and "after_CA". That's okay - a transition can have multiple input places.

Let me sketch the full structure:

Places:
- source (start)
- after_CR
- after_DV
- after_FC
- after_CA
- after_AP (optional)
- after_P
- after_N
- sink (end)

Transitions:
- CR (Claim Registration)
- DV (Document Verification)
- RDS (Re-Document Submission)
- FC (Fraud Check)
- II (In-depth Investigation)
- CA (Claim Assessment)
- AP (Approval)
- P (Payment)
- N (Notification)
- CL (Closure)

Arcs:
- source -> CR -> after_CR
- after_CR -> DV -> after_DV
- after_DV -> FC -> after_FC
- after_DV -> RDS -> after_DV (loop)
- after_FC -> CA -> after_CA
- after_FC -> II -> after_FC (loop)

Now for the conditional approval:
Two options:
Option 1: After CA, we have a choice:
- after_CA -> AP -> after_AP -> P
- after_CA -> P directly (if no approval needed)

But this means P has two possible input places. That's fine. So:
- after_CA -> AP -> after_AP -> P -> after_P
- after_CA -> P (directly) -> after_P

Then:
- after_P -> N -> after_N
- after_N -> CL -> sink

The loops:
- DV loop: after_DV -> RDS -> back to DV's input place (after_DV)
  Wait, no. The loop should be: from DV, if documents incomplete, go to RDS, then back to DV again.
  So: after_DV place -> RDS transition -> back to DV transition's input place?

Actually, let's think about the loop more carefully. The sequence is:
... -> DV -> after_DV -> (choice point) -> either FC or RDS

If we go to RDS, then after RDS we should come back to the input of DV. So:

Better structure for the DV loop:
- Place before_DV (or just use previous place)
- Transition DV
- Place after_DV
- From after_DV, we have a branch:
  - If docs OK: go to FC
  - If docs incomplete: go to RDS
- After RDS: go back to before_DV (so DV can fire again)

So we'd need a place "before_DV" that is the input to DV.

Similarly for FC loop:
- Place before_FC (or after_DV)
- Transition FC
- Place after_FC
- From after_FC:
  - If no fraud: go to CA
  - If fraud: go to II
- After II: go back to before_FC

Let me redesign with explicit "waiting" places:

Places:
- source (initial marking)
- waiting_for_CR
- waiting_for_DV
- waiting_for_FC
- waiting_for_CA
- waiting_for_AP (optional)
- waiting_for_P
- waiting_for_N
- waiting_for_CL
- sink (final marking)

Transitions:
- CR (source -> waiting_for_CR -> CR -> waiting_for_DV)
Wait, that's not right. Let's be more systematic.

Standard pattern: place -> transition -> place -> transition -> place ...

So:
source (initial marking with 1 token)
CR transition
p1 (after CR)
DV transition
p2 (after DV)
FC transition
p3 (after FC)
CA transition
p4 (after CA)
AP transition (optional)
p5 (after AP)
P transition
p6 (after P)
N transition
p7 (after N)
CL transition
sink (final marking)

Now for the loops:
1. DV-RDS loop:
   - From p2 (after DV), we can either go to FC or to RDS
   - RDS should go back to the input of DV (which is p1)
   So: p2 -> RDS -> p1

2. FC-II loop:
   - From p3 (after FC), we can either go to CA or to II
   - II should go back to the input of FC (which is p2)
   So: p3 -> II -> p2

3. AP is conditional:
   - From p4 (after CA), we can either go to AP or directly to P
   - If we go to AP: p4 -> AP -> p5 -> P
   - If we skip AP: p4 -> P directly
   - So P would have arcs from both p5 and p4

Let me write this out more clearly:

```python
# Places
source = PetriNet.Place("source")
after_CR = PetriNet.Place("after_CR")
after_DV = PetriNet.Place("after_DV")
after_FC = PetriNet.Place("after_FC")
after_CA = PetriNet.Place("after_CA")
after_AP = PetriNet.Place("after_AP")
after_P = PetriNet.Place("after_P")
after_N = PetriNet.Place("after_N")
sink = PetriNet.Place("sink")

# Transitions
CR = PetriNet.Transition("CR", "Claim Registration")
DV = PetriNet.Transition("DV", "Document Verification")
RDS = PetriNet.Transition("RDS", "Re-Document Submission")
FC = PetriNet.Transition("FC", "Fraud Check")
II = PetriNet.Transition("II", "In-depth Investigation")
CA = PetriNet.Transition("CA", "Claim Assessment")
AP = PetriNet.Transition("AP", "Approval")
P = PetriNet.Transition("P", "Payment")
N = PetriNet.Transition("N", "Notification")
CL = PetriNet.Transition("CL", "Closure")

# Arcs
source -> CR -> after_CR
after_CR -> DV -> after_DV
after_DV -> FC -> after_FC
after_DV -> RDS -> after_CR  # loop back to before DV
after_FC -> CA -> after_CA
after_FC -> II -> after_DV  # loop back to before FC
after_CA -> AP -> after_AP -> P -> after_P
after_CA -> P -> after_P  # direct path skipping AP
after_P -> N -> after_N
after_N -> CL -> sink
```

Wait, the loop arcs are wrong. Let me reconsider.

When we go from after_DV to RDS, RDS should fire and put tokens back into the place that is the input to DV. The input to DV is after_CR. So:
- after_DV -> RDS -> after_CR

Similarly, for the FC-II loop:
- The input to FC is after_DV
- after_FC -> II -> after_DV

That makes more sense.

Now for the conditional AP:
- After CA, we have after_CA
- From after_CA, we can either:
  - Go to AP -> after_AP -> P
  - Go directly to P
- So P has two input places: after_AP and after_CA

But wait, that means P would fire when it gets a token from either place. But if we go the AP route, we need to wait for both after_AP token AND after_CA token? No, that's not right.

Actually, in Petri nets, a transition can have multiple input arcs. It requires tokens from ALL input places to fire. So if P has arcs from both after_CA and after_AP, it would need tokens from BOTH, which is not what we want.

The correct way is:
- P should have only one input place (or rather, the tokens should converge to a single place before P)

Better design for the conditional AP:
- after_CA is a place
- From after_CA, we have two possible transitions:
  - AP (if approval needed) -> after_AP
  - Skip_AP (if no approval needed) -> after_AP
- Then from after_AP -> P

But "Skip_AP" is not an activity in the description. The problem says "The claim must be approved by a senior manager if the amount surpasses a certain threshold." It doesn't say there's a "skip" activity.

Alternative: We could have two different Payment transitions:
- P_after_AP (Payment after approval)
- P_direct (Direct payment)

But the problem describes "Payment (P)" as a single activity.

Let me think about this differently. In process modeling, conditional branches are often modeled as:
- Activity A -> Place p
- From p, there are two transitions:
  - Transition B (with condition)
  - Transition C (with condition)
But since we don't have conditions in basic Petri nets, we just have both transitions possible.

The simplest approach that matches the description:
- After CA, we always go to AP
- But AP might be "instant" if threshold not met? No, that doesn't make sense.

Actually, re-reading the problem: "The claim must be approved by a senior manager if the amount surpasses a certain threshold." This is a business rule. In a Petri net model, we can model this as:
- After CA, there's a place
- From that place, we can either fire "Approval" transition (if needed) or directly fire "Payment" transition (if not needed)

But as I realized, if both transitions share the same input place, they compete for the token. This models a non-deterministic choice, which is standard in Petri nets.

So the final structure would be:
- after_CA (place)
- Transition AP (label="Approval") -> after_AP (place)
- Transition P (label="Payment") -> after_P (place)

But wait, then P would directly consume from after_CA, not from after_AP. That would mean the Approval transition doesn't lead to Payment.

No, that's wrong. Let me draw it:

```
after_CA (place)
   |          \
   |           \
   AP           P
   |            \
after_AP         after_P
   |             /
   |            /
   +----> P ----
```

This is getting confusing. Let's be precise:

Option 1 (simplest, but maybe not ideal):
- after_CA -> AP -> after_AP -> P -> after_P
- after_CA -> P -> after_P (skip AP)

This means P appears twice in the net, which is not ideal but could work if we give them the same label.

Option 2 (better structure):
- Have a "merge" place before P:
- after_CA -> AP -> pending_payment
- after_CA -> Skip_Approval -> pending_payment
- pending_payment -> P -> after_P

But Skip_Approval is not a real activity.

Option 3 (most standard):
- Model it as a silent transition (no label) for the skip path:
- after_CA -> AP -> after_AP -> P -> after_P
- after_CA -> silent_transition -> after_AP (skip path)

But the silent transition would need to produce the same after_AP place.

Actually, the most standard way in Petri nets to model a choice is:
- Place p
- Two transitions t1 and t2 that both consume from p
- t1 leads to place p1
- t2 leads to place p2
- Then maybe p1 and p2 converge later

For our case:
- after_CA (place)
- Transition AP -> after_AP (place)
- Transition P_direct -> after_P (place)  # skipping AP

But then we need:
- after_AP -> P -> after_P

So P does appear, but only on the AP path. The direct path would skip P entirely, which is wrong because Payment is always required.

Let me reconsider one more time. The correct structure should ensure Payment always happens:

```
after_CA (place)
   / \
  /   \
 AP    P_direct
 |      |
after_AP after_P
  \    /
   \  /
    P
    |
   after_P
```

This is still wrong. Let me be extremely precise:

We want:
- CA always happens
- Then, either:
  - AP happens, then P happens
  - P happens directly

So:
- after_CA is a place with one token after CA fires
- From after_CA, we have a choice: either fire AP or fire P
- If we fire AP, it consumes the token from after_CA and produces a token in after_AP
- Then from after_AP, we fire P
- If we fire P directly, it consumes the token from after_CA and produces token in after_P

So Payment is modeled by two different transitions (but with the same label). Let's check if pm4py allows multiple transitions with the same label. I think it does.

So the final structure:

Places:
- source (initial)
- after_CR
- after_DV
- after_FC
- after_CA
- after_AP (optional intermediate)
- after_P
- after_N
- sink (final)

Transitions:
- CR
- DV
- RDS (loop back to DV input)
- FC
- II (loop back to FC input)
- CA
- AP (approval path)
- P1 (payment after approval, label="Payment")
- P2 (direct payment, label="Payment")
- N
- CL

Arcs:
- source -> CR -> after_CR
- after_CR -> DV -> after_DV
- after_FC -> II -> after_DV  # FC-II loop
- after_DV -> RDS -> after_CR  # DV-RDS loop
- after_DV -> FC -> after_FC
- after_FC -> CA -> after_CA
- after_CA -> AP -> after_AP
- after_AP -> P1 -> after_P
- after_CA -> P2 -> after_P
- after_P -> N -> after_N
- after_N -> CL -> sink

This should work. Let me double-check the loops:

DV-RDS loop:
- Start: after_CR has token
- DV fires: consumes from after_CR, produces in after_DV
- If documents incomplete: RDS fires: consumes from after_DV, produces in after_CR
- So DV can fire again
- This loop works

FC-II loop:
- Start: after_DV has token
- FC fires: consumes from after_DV, produces in after_FC
- If fraud suspected: II fires: consumes from after_FC, produces in after_DV
- So FC can fire again
- This loop works

AP conditional:
- After CA: after_CA has token
- Choice 1: AP fires: consumes from after_CA, produces in after_AP, then P1 fires (needs token from after_AP)
- Choice 2: P2 fires: consumes from after_CA, produces in after_P directly
- This models the conditional approval correctly

One issue: If we choose the AP path, we need to fire P1, but P2 is also enabled (if we consider label only). But since P2 requires token from after_CA which is consumed by AP, P2 won't be enabled after AP fires.

Wait, no. After CA fires, we have one token in after_CA. Then both AP and P2 are enabled. If we fire AP, it consumes the token from after_CA, so P2 is no longer enabled. If we fire P2, it consumes the token, so AP is no longer enabled. This is correct.

After AP fires, we have a token in after_AP, and P1 is enabled. P1 fires and produces token in after_P.

So the model is correct.

Now let me write the Python code. The example shows:
```python
net = PetriNet(name="example")
source = PetriNet.Place(name="source")
sink = PetriNet.Place(name="sink")
execute_activity = PetriNet.Transition(name="execute_activity", label="Execute Activity")
net.places.add(source)
net.places.add(sink)
net.transitions.add(execute_activity)
petri_utils.add_arc_from_to(source, execute_activity, net)
petri_utils.add_arc_from_to(execute_activity, sink, net)
```

So we need to:
1. Create PetriNet
2. Create all places
3. Create all transitions
4. Add places to net.places
5. Add transitions to net.transitions
6. Add arcs using petri_utils.add_arc_from_to
7. Create initial and final markings

Let's write the complete code:

```python
from pm4py.objects.petri_net.obj import PetriNet, Marking
from pm4py.objects.petri_net.utils import petri_utils

# Create the Petri net
net = PetriNet(name="insurance_claim_process")

# Create places
source = PetriNet.Place("source")
after_CR = PetriNet.Place("after_CR")
after_DV = PetriNet.Place("after_DV")
after_FC = PetriNet.Place("after_FC")
after_CA = PetriNet.Place("after_CA")
after_AP = PetriNet.Place("after_AP")
after_P = PetriNet.Place("after_P")
after_N = PetriNet.Place("after_N")
sink = PetriNet.Place("sink")

# Add places to the net
net.places.add(source)
net.places.add(after_CR)
net.places.add(after_DV)
net.places.add(after_FC)
net.places.add(after_CA)
net.places.add(after_AP)
net.places.add(after_P)
net.places.add(after_N)
net.places.add(sink)

# Create transitions
CR = PetriNet.Transition("CR", "Claim Registration")
DV = PetriNet.Transition("DV", "Document Verification")
RDS = PetriNet.Transition("RDS", "Re-Document Submission")
FC = PetriNet.Transition("FC", "Fraud Check")
II = PetriNet.Transition("II", "In-depth Investigation")
CA = PetriNet.Transition("CA", "Claim Assessment")
AP = PetriNet.Transition("AP", "Approval")
P1 = PetriNet.Transition("P1", "Payment")
P2 = PetriNet.Transition("P2", "Payment")
N = PetriNet.Transition("N", "Notification")
CL = PetriNet.Transition("CL", "Closure")

# Add transitions to the net
net.transitions.add(CR)
net.transitions.add(DV)
net.transitions.add(RDS)
net.transitions.add(FC)
net.transitions.add(II)
net.transitions.add(CA)
net.transitions.add(AP)
net.transitions.add(P1)
net.transitions.add(P2)
net.transitions.add(N)
net.transitions.add(CL)

# Add arcs
# Main flow
petri_utils.add_arc_from_to(source, CR, net)
petri_utils.add_arc_from_to(CR, after_CR, net)
petri_utils.add_arc_from_to(after_CR, DV, net)
petri_utils.add_arc_from_to(DV, after_DV, net)
petri_utils.add_arc_from_to(after_DV, FC, net)
petri_utils.add_arc_from_to(FC, after_FC, net)
petri_utils.add_arc_from_to(after_FC, CA, net)
petri_utils.add_arc_from_to(CA, after_CA, net)
petri_utils.add_arc_from_to(after_CA, AP, net)
petri_utils.add_arc_from_to(AP, after_AP, net)
petri_utils.add_arc_from_to(after_AP, P1, net)
petri_utils.add_arc_from_to(after_CA, P2, net)
petri_utils.add_arc_from_to(P1, after_P, net)
petri_utils.add_arc_from_to(P2, after_P, net)
petri_utils.add_arc_from_to(after_P, N, net)
petri_utils.add_arc_from_to(N, after_N, net)
petri_utils.add_arc_from_to(after_N, CL, net)
petri_utils.add_arc_from_to(CL, sink, net)

# Loops
# DV-RDS loop: after_DV -> RDS -> after_CR
petri_utils.add_arc_from_to(after_DV, RDS, net)
petri_utils.add_arc_from_to(RDS, after_CR, net)

# FC-II loop: after_FC -> II -> after_DV
petri_utils.add_arc_from_to(after_FC, II, net)
petri_utils.add_arc_from_to(II, after_DV, net)

# Initial marking
im = Marking()
im[source] = 1

# Final marking
fm = Marking()
fm[sink] = 1
```

Wait, I have an issue. The arcs for P1 and P2 are wrong. Let me trace:

After AP fires, we go to after_AP place. Then we need to go to P1.
So: after_AP -> P1 -> after_P

After CA, we can go directly to P2.
So: after_CA -> P2 -> after_P

The code above has:
```python
petri_utils.add_arc_from_to(after_AP, P1, net)  # after_AP -> P1
petri_utils.add_arc_from_to(after_CA, P2, net)  # after_CA -> P2
petri_utils.add_arc_from_to(P1, after_P, net)   # P1 -> after_P
petri_utils.add_arc_from_to(P2, after_P, net)   # P2 -> after_P
```

This looks correct.

But I need to verify the loop arcs again. The example shows:
```python
petri_utils.add_arc_from_to(source, execute_activity, net)
petri_utils.add_arc_from_to(execute_activity, sink, net)
```

So the pattern is: place -> transition -> place

For the DV-RDS loop:
- We are at after_DV (place)
- RDS (transition) fires
- It puts token back into after_CR (place)

So: after_DV -> RDS -> after_CR

This is correct. It means after document verification, if re-submission is needed, we go back to the state we were in after claim registration, which makes sense because we need to re-verify documents.

For the FC-II loop:
- We are at after_FC (place)
- II (transition) fires
- It puts token back into after_DV (place)

So: after_FC -> II -> after_DV

This also makes sense. After fraud check, if investigation is needed, we go back to after document verification state (presumably to re-evaluate documents after investigation).

Actually, let me reconsider the semantics. After FC, if investigation is needed, shouldn't we go back to before FC? The description says: "if the Fraud Check (FC) raises doubts, an additional In-depth Investigation (II) is performed. This can happen multiple times before proceeding to Claim Assessment (CA)."

So the loop is: FC -> II -> FC (again), not FC -> II -> DV.

Let me correct this:

The flow is:
... -> DV -> FC -> (choice) -> either CA or II
If II: II -> back to before FC

So the input to FC is after_DV.
The output of FC is after_FC.
From after_FC, we can go to II or CA.
If II fires, it should put token back into after_DV (the input of FC).

So my original design was correct: after_FC -> II -> after_DV

Now let me double-check the DV-RDS loop:
... -> CR -> DV -> (choice) -> either FC or RDS
If RDS: RDS -> back to before DV

So the input to DV is after_CR.
The output of DV is after_DV.
From after_DV, we can go to FC or RDS.
If RDS fires, it should put token back into after_CR.

So: after_DV -> RDS -> after_CR is correct.

Good, the loops are correct.

Now one final thing: The problem mentions the imports and usage. Let me make sure my code uses the correct API. The example uses:
- `PetriNet.Place(name="...")`
- `PetriNet.Transition(name="...", label="...")`
- `net.places.add(...)`
- `net.transitions.add(...)`
- `petri_utils.add_arc_from_to(from, to, net)`

My code uses all of these correctly.

Let me also add comments to explain the loops and conditional paths clearly.

One more consideration: Should I add silent (tau) transitions for the loops? No, the problem says RDS and II are activities, so they should be labeled transitions.

Let me also check if there's any issue with having two transitions with the same label "Payment". In process mining and Petri nets, it's common to have multiple transitions with the same label representing the same activity in different contexts. pm4py should handle this fine.

Let me review the complete code once more for any logical errors.

Process flow:
1. Claim arrives (token in source)
2. CR fires -> token in after_CR
3. DV fires -> token in after_DV
   - At after_DV, two transitions enabled: FC and RDS
   - If RDS fires: consumes token from after_DV, produces token in after_CR (loop back to step 2)
   - If FC fires: consumes token from after_DV, produces token in after_FC (proceed to step 4)
4. FC fires -> token in after_FC
   - At after_FC, two transitions enabled: CA and II
   - If II fires: consumes token from after_FC, produces token in after_DV (loop back to step 3)
   - If CA fires: consumes token from after_FC, produces token in after_CA (proceed to step 5)
5. CA fires -> token in after_CA
   - At after_CA, two transitions enabled: AP and P2
   - If AP fires: consumes token from after_CA, produces token in after_AP
     - At after_AP, P1 is enabled
     - P1 fires: consumes token from after_AP, produces token in after_P
   - If P2 fires: consumes token from after_CA, produces token in after_P (direct payment)
6. N fires -> token in after_N
7. CL fires -> token in sink

This looks correct. The process can loop multiple times on DV-RDS and FC-II, and there's a choice between approval path and direct payment.

Let me make one final improvement: add more descriptive names to places to make it clearer.

Actually, the place names are fine. But I could add comments explaining the conditional and loop structures more clearly in the code.

Let me also verify that I have all the required activities from the scenario:
- Claim Registration (CR) 
- Document Verification (DV) 
- Re-Document Submission (RDS) 
- Fraud Check (FC) 
- In-depth Investigation (II) 
- Claim Assessment (CA) 
- Approval (AP) 
- Payment (P)  (two transitions P1 and P2 with same label)
- Notification (N) 
- Closure (CL) 

All present.

Final check on the final marking: The token ends up in sink after CL fires. So fm[sink] = 1 is correct.

The initial marking: im[source] = 1 is correct.

The code looks complete and correct. Let me format it nicely with comments.
</think>
```python
from pm4py.objects.petri_net.obj import PetriNet, Marking
from pm4py.objects.petri_net.utils import petri_utils

# Create the Petri net for the insurance claim management process
net = PetriNet(name="insurance_claim_process")

# Define all places representing process states
source = PetriNet.Place("source")                    # Initial state: new claim arrived
after_CR = PetriNet.Place("after_CR")               # After claim registration
after_DV = PetriNet.Place("after_DV")               # After document verification
after_FC = PetriNet.Place("after_FC")               # After fraud check
after_CA = PetriNet.Place("after_CA")               # After claim assessment
after_AP = PetriNet.Place("after_AP")               # After approval (optional path)
after_P = PetriNet.Place("after_P")                 # After payment
after_N = PetriNet.Place("after_N")                 # After notification
sink = PetriNet.Place("sink")                       # Final state: claim closed

# Add places to the net
net.places.update([source, after_CR, after_DV, after_FC, after_CA, 
                   after_AP, after_P, after_N, sink])

# Define all transitions representing activities
CR = PetriNet.Transition("CR", "Claim Registration")
DV = PetriNet.Transition("DV", "Document Verification")
RDS = PetriNet.Transition("RDS", "Re-Document Submission")
FC = PetriNet.Transition("FC", "Fraud Check")
II = PetriNet.Transition("II", "In-depth Investigation")
CA = PetriNet.Transition("CA", "Claim Assessment")
AP = PetriNet.Transition("AP", "Approval")
P1 = PetriNet.Transition("P1", "Payment")           # Payment after approval
P2 = PetriNet.Transition("P2", "Payment")           # Direct payment (skip approval)
N = PetriNet.Transition("N", "Notification")
CL = PetriNet.Transition("CL", "Closure")

# Add transitions to the net
net.transitions.update([CR, DV, RDS, FC, II, CA, AP, P1, P2, N, CL])

# Build the main sequential flow
petri_utils.add_arc_from_to(source, CR, net)
petri_utils.add_arc_from_to(CR, after_CR, net)
petri_utils.add_arc_from_to(after_CR, DV, net)
petri_utils.add_arc_from_to(DV, after_DV, net)
petri_utils.add_arc_from_to(after_DV, FC, net)
petri_utils.add_arc_from_to(FC, after_FC, net)
petri_utils.add_arc_from_to(after_FC, CA, net)
petri_utils.add_arc_from_to(CA, after_CA, net)

# Branching for conditional approval: either approval path or direct payment
petri_utils.add_arc_from_to(after_CA, AP, net)
petri_utils.add_arc_from_to(AP, after_AP, net)
petri_utils.add_arc_from_to(after_AP, P1, net)
petri_utils.add_arc_from_to(after_CA, P2, net)

# Converge both payment paths
petri_utils.add_arc_from_to(P1, after_P, net)
petri_utils.add_arc_from_to(P2, after_P, net)

# Continue with final steps
petri_utils.add_arc_from_to(after_P, N, net)
petri_utils.add_arc_from_to(N, after_N, net)
petri_utils.add_arc_from_to(after_N, CL, net)
petri_utils.add_arc_from_to(CL, sink, net)

# Loop: Re-Document Submission (RDS) returns to before Document Verification
# This allows multiple iterations when documents are incomplete
petri_utils.add_arc_from_to(after_DV, RDS, net)
petri_utils.add_arc_from_to(RDS, after_CR, net)

# Loop: In-depth Investigation (II) returns to before Fraud Check
# This allows multiple investigation iterations when fraud is suspected
petri_utils.add_arc_from_to(after_FC, II, net)
petri_utils.add_arc_from_to(II, after_DV, net)

# Define initial marking: one token in source place (new claim arrives)
im = Marking()
im[source] = 1

# Define final marking: one token in sink place (claim successfully closed)
fm = Marking()
fm[sink] = 1
```