```sql
WITH ordered_events AS (
    SELECT
        *,
        ROW_NUMBER() OVER (PARTITION BY case_id ORDER BY timestamp) AS seq_num
    FROM event_log
),
direct_sequences AS (
    SELECT
        a.case_id,
        b.timestamp AS create_ts,
        c.timestamp AS confirm_ts,
        DATE_DIFF('day', b.timestamp, c.timestamp) AS days_between_create_confirm
    FROM ordered_events a
    JOIN ordered_events b
      ON a.case_id = b.case_id
     AND b.seq_num = a.seq_num + 1
    JOIN ordered_events c
      ON a.case_id = c.case_id
     AND c.seq_num = a.seq_num + 2
    WHERE a.activity = 'Approve Purchase Requisition'
      AND b.activity = 'Create Order'
      AND c.activity = 'Confirm Order'
),
violating_cases AS (
    SELECT DISTINCT case_id
    FROM direct_sequences
    WHERE days_between_create_confirm > 5
)
SELECT e.*
FROM event_log e
WHERE e.case_id NOT IN (SELECT case_id FROM violating_cases)
ORDER BY e.case_id, e.timestamp;
```

This query:

- Assigns a sequential number to each event within a case, ordered by timestamp.
- Identifies direct successions of the three required activities with no intervening events (by joining on consecutive sequence numbers).
- Calculates the number of days between 'Create Order' and 'Confirm Order' using `DATE_DIFF`.
- Marks cases as violating if this duration exceeds 5 days.
- Returns all events from non-violating cases only.

The use of `DATE_DIFF('day', ...)` counts whole days between the timestamps (ignoring time-of-day fractions), which aligns with typical interpretations of "more than 5 days" in process mining contexts. If fractional days should be considered (e.g., via an exact interval), replace the calculation with `c.timestamp - b.timestamp > INTERVAL '5 days'`.