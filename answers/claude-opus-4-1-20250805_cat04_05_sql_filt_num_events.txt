Here's a DuckDB SQL query that accomplishes this task:

```sql
WITH case_counts AS (
    SELECT 
        case_id,
        COUNT(*) as event_count
    FROM event_log
    GROUP BY case_id
    HAVING COUNT(*) <= 6
)
SELECT 
    el.*
FROM event_log el
INNER JOIN case_counts cc
    ON el.case_id = cc.case_id
ORDER BY el.case_id, el.timestamp;
```

**Alternative approach using a window function:**

```sql
SELECT *
FROM (
    SELECT 
        *,
        COUNT(*) OVER (PARTITION BY case_id) as events_per_case
    FROM event_log
) t
WHERE events_per_case <= 6
ORDER BY case_id, timestamp;
```

**Explanation:**

**First approach (CTE with JOIN):**
1. The CTE `case_counts` calculates the number of events for each `case_id`
2. The `HAVING` clause filters to keep only cases with 6 or fewer events
3. The main query joins back to the original table to retrieve all columns for the filtered cases
4. Results are ordered by case_id and timestamp for clarity

**Second approach (Window function):**
1. Uses `COUNT(*) OVER (PARTITION BY case_id)` to add the count of events per case to each row
2. Filters rows where the count is 6 or less
3. More concise and often more efficient as it requires only one pass through the data

Both queries will return the complete event records (all columns) for only those cases that contain 6 or fewer events total.