```python
import pm4py
from pm4py.objects.powl.obj import StrictPartialOrder, OperatorPOWL, Transition, SilentTransition
from pm4py.objects.process_tree.obj import Operator

# Define atomic transitions
OR = Transition(label="OR")
MS = Transition(label="MS")
QS = Transition(label="QS")
AS = Transition(label="AS")
IQC = Transition(label="IQC")
TST = Transition(label="TST")
RT = Transition(label="RT")
PK = Transition(label="PK")
LB = Transition(label="LB")
DP = Transition(label="DP")
D = Transition(label="D")
tau = SilentTransition()

# IQC loop: *(IQC, tau) for 1+ IQC
loop_IQC = OperatorPOWL(operator=Operator.LOOP, children=[IQC, tau])

# Optional multiple IQC: X(tau, loop_IQC) for 0+ IQC
optional_IQC = OperatorPOWL(operator=Operator.XOR, children=[tau, loop_IQC])

# Assembly cycle: AS --> optional_IQC (sequential)
cycle = StrictPartialOrder(nodes=[AS, optional_IQC])
cycle.order.add_edge(AS, optional_IQC)

# Assembly loop: *(cycle, tau) for 1+ cycles
assembly_loop = OperatorPOWL(operator=Operator.LOOP, children=[cycle, tau])

# Test loop: *(TST, RT)
test_loop = OperatorPOWL(operator=Operator.LOOP, children=[TST, RT])

# Optional LB: X(LB, tau)
choice_LB = OperatorPOWL(operator=Operator.XOR, children=[LB, tau])

# Root partial order for the main sequential flow
root = StrictPartialOrder(nodes=[OR, MS, QS, assembly_loop, test_loop, PK, choice_LB, DP, D])

# Add ordering edges for sequential execution
root.order.add_edge(OR, MS)
root.order.add_edge(MS, QS)
root.order.add_edge(QS, assembly_loop)
root.order.add_edge(assembly_loop, test_loop)
root.order.add_edge(test_loop, PK)
root.order.add_edge(PK, choice_LB)
root.order.add_edge(choice_LB, DP)
root.order.add_edge(DP, D)
```