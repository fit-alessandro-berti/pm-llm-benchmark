## Analysis of the Event Log

**Identifying structural patterns:**

| Pattern | Evidence |
|---|---|
| **OR  MS  QS** always sequential | All 5 cases |
| **AS/IQC loop**: AS repeats after IQC; IQC itself can repeat consecutively | Case 3: `AS, IQC, IQC, AS, IQC, AS`; Case 5: `AS, IQC, AS, IQC, AS` |
| **TST/RT loop**: TST repeats after RT failure | Case 5: `TST, RT, TST, RT, TST` |
| **LB is optional** (skippable) | Case 2 has no LB |
| **PK  DP  D** always sequential | All 5 cases |

**Derived sub-models:**
- Inner IQC repetition: `*(IQC, )`  one or more IQCs
- AS+IQC assembly loop: `*(AS, *(IQC, ))`  AS, then optionally (one-or-more-IQCs then AS) repeated
- Testing loop: `*(TST, RT)`  TST, then optionally (RT then TST) repeated
- Optional labeling: `X(LB, skip)`

---

## Final POWL Model

```python
import pm4py
from pm4py.objects.powl.obj import StrictPartialOrder, OperatorPOWL, Transition, SilentTransition
from pm4py.objects.process_tree.obj import Operator

#  Leaf activities 
OR  = Transition(label="OR")   # Order Received
MS  = Transition(label="MS")   # Material Sourcing
QS  = Transition(label="QS")   # Quality Screening
AS  = Transition(label="AS")   # Assembly
IQC = Transition(label="IQC")  # In-line Quality Check
TST = Transition(label="TST")  # Testing
RT  = Transition(label="RT")   # Re-Testing
PK  = Transition(label="PK")   # Packaging
LB  = Transition(label="LB")   # Labeling (optional)
DP  = Transition(label="DP")   # Distribution Planning
D   = Transition(label="D")    # Dispatch

#  Silent transitions 
tau  = SilentTransition()   # loop-back enabler inside IQC repetition
skip = SilentTransition()   # represents skipping LB

#  Sub-models 

# 1. IQC can repeat one or more times: *(IQC, )
#    Semantics: do IQC, then either exit OR do  (silent) and IQC again
iqc_loop = OperatorPOWL(operator=Operator.LOOP, children=[IQC, tau])

# 2. Assembly + inline-QC loop: *(AS, *(IQC, ))
#    Semantics: do AS, then either exit OR do (one-or-more IQCs) then AS again
as_iqc_loop = OperatorPOWL(operator=Operator.LOOP, children=[AS, iqc_loop])

# 3. Testing + re-testing loop: *(TST, RT)
#    Semantics: do TST, then either exit OR do RT and TST again
tst_rt_loop = OperatorPOWL(operator=Operator.LOOP, children=[TST, RT])

# 4. Optional labeling: X(LB, skip)
#    Semantics: either perform LB or silently skip it
lb_xor = OperatorPOWL(operator=Operator.XOR, children=[LB, skip])

#  Root: strict total order (fully sequential process) 
root = StrictPartialOrder(
    nodes=[OR, MS, QS, as_iqc_loop, tst_rt_loop, PK, lb_xor, DP, D]
)

root.order.add_edge(OR,          MS)
root.order.add_edge(MS,          QS)
root.order.add_edge(QS,          as_iqc_loop)
root.order.add_edge(as_iqc_loop, tst_rt_loop)
root.order.add_edge(tst_rt_loop, PK)
root.order.add_edge(PK,          lb_xor)
root.order.add_edge(lb_xor,      DP)
root.order.add_edge(DP,          D)
```

---

## Visual Summary

```
OR  MS  QS  *(AS, *(IQC, ))  *(TST, RT)  PK  X(LB, skip)  DP  D
```

| Node | Meaning |
|---|---|
| `*(AS, *(IQC, ))` | Assembly loop: AS executed, then zero or more rounds of (one-or-more IQC checks  AS again) |
| `*(TST, RT)` | Testing loop: TST executed, then zero or more rounds of (RT  TST again) |
| `X(LB, skip)` | Exclusive choice: label the product **or** silently skip labeling |

### Trace Verification

| Case | AS/IQC trace | TST/RT trace | LB |
|---|---|---|---|
| 1 | AS, IQC, AS | TST, RT, TST |  |
| 2 | AS, IQC, AS | TST | skipped |
| 3 | AS, **IQC, IQC**, AS, IQC, AS | TST, RT, TST |  |
| 4 | AS (no IQC) | TST |  |
| 5 | AS, IQC, AS, IQC, AS | TST, RT, TST, RT, TST |  |