# Analysis and Fix of the Underfitting Procure-to-Pay Process Tree

## 1. Issues with the Current Model

### Problem Identification

The current model has a **parallel block (AND operator)** containing five activities that should actually follow a strict sequence:

```
parallel_block = ProcessTree(operator=Operator.PARALLEL, children=[
    create_po,
    receive_goods,
    receive_invoice,
    match_invoice,
    pay_invoice
])
```

### Unwanted Behaviors Allowed by the Current Model:

| Unwanted Behavior | Why It's Wrong |
|-------------------|----------------|
| **Pay Invoice before Receiving Goods** | Payment should only occur after goods are verified received |
| **Pay Invoice before Matching** | Invoice must be matched to PO to verify amounts before payment |
| **Match Invoice before Receiving Invoice** | Cannot match an invoice that hasn't arrived |
| **Match Invoice before Creating PO** | Nothing to match against without a PO |
| **Receive Goods before Creating PO** | Goods are ordered via PO; can't receive what wasn't ordered |

### Domain Logic Requirements:

The Procure-to-Pay process has **strict sequential dependencies**:

1. **Create Purchase Requisition**  must come first (identifies the need)
2. **Approve Purchase Requisition**  authorization gate
3. **Create Purchase Order**  formalizes the order with supplier
4. **Receive Goods**  physical receipt of ordered items
5. **Receive Invoice**  supplier sends bill (can happen around same time as goods)
6. **Match Invoice to PO**  three-way match (PO, goods receipt, invoice)
7. **Pay Invoice**  only after successful match
8. **Close Case**  finalize the process

## 2. Corrected Process Tree Model

```python
from pm4py.objects.process_tree.obj import Operator, ProcessTree

# Define activities
create_req = ProcessTree(label="Create_Purchase_Requisition")
approve_req = ProcessTree(label="Approve_Purchase_Requisition")
create_po = ProcessTree(label="Create_Purchase_Order")
receive_goods = ProcessTree(label="Receive_Goods")
receive_invoice = ProcessTree(label="Receive_Invoice")
match_invoice = ProcessTree(label="Match_Invoice_to_PO")
pay_invoice = ProcessTree(label="Pay_Invoice")
close_case = ProcessTree(label="Close_Case")

# CORRECTED STRUCTURE:
# All activities in strict sequence following the standard P2P flow

root = ProcessTree(operator=Operator.SEQUENCE, children=[
    create_req,        # Step 1: Identify need
    approve_req,       # Step 2: Get authorization
    create_po,         # Step 3: Place order with supplier
    receive_goods,     # Step 4: Receive physical goods
    receive_invoice,   # Step 5: Receive supplier's invoice
    match_invoice,     # Step 6: Three-way match
    pay_invoice,       # Step 7: Release payment
    close_case         # Step 8: Close the case
])
```

### Visual Representation:

```
                             (SEQUENCE)
                                  
    
                                                    
                                                    
 Create  Approve Create Receive Receive Match   Pay   Close
  Req     Req     PO    Goods  Invoice Invoice Invoice Case
```

## 3. Alternative Model (If Some Flexibility is Desired)

In real-world scenarios, **Receive Goods** and **Receive Invoice** can sometimes happen in either order or concurrently. Here's a model that allows this realistic flexibility while maintaining other constraints:

```python
from pm4py.objects.process_tree.obj import Operator, ProcessTree

# Define activities
create_req = ProcessTree(label="Create_Purchase_Requisition")
approve_req = ProcessTree(label="Approve_Purchase_Requisition")
create_po = ProcessTree(label="Create_Purchase_Order")
receive_goods = ProcessTree(label="Receive_Goods")
receive_invoice = ProcessTree(label="Receive_Invoice")
match_invoice = ProcessTree(label="Match_Invoice_to_PO")
pay_invoice = ProcessTree(label="Pay_Invoice")
close_case = ProcessTree(label="Close_Case")

# Parallel block ONLY for goods and invoice receipt (both needed before matching)
receive_parallel = ProcessTree(operator=Operator.PARALLEL, children=[
    receive_goods,
    receive_invoice
])

# Main sequence with controlled parallelism
root = ProcessTree(operator=Operator.SEQUENCE, children=[
    create_req,         # Step 1
    approve_req,        # Step 2
    create_po,          # Step 3
    receive_parallel,   # Steps 4-5 (can happen in any order, both must complete)
    match_invoice,      # Step 6 (only after both goods AND invoice received)
    pay_invoice,        # Step 7
    close_case          # Step 8
])
```

### Visual Representation of Alternative:

```
                         (SEQUENCE)
                              
    
                                                       
                                                       
 Create  Approve Create              Match   Pay   Close
  Req     Req     PO                Invoice Invoice Case
                                       
                                       
             (PARALLEL)                
                                       
                         
                                      
                                      
       Receive       Receive 
        Goods        Invoice
```

## 4. How the Fixed Model Ensures Conformance

| Constraint | How It's Enforced |
|------------|-------------------|
| **No payment before goods receipt** | `pay_invoice` comes after `receive_goods` in sequence |
| **No payment before invoice matching** | `pay_invoice` comes after `match_invoice` in sequence |
| **No matching before PO creation** | `match_invoice` comes after `create_po` in sequence |
| **No PO without approval** | `create_po` comes after `approve_req` in sequence |
| **Case closes only after payment** | `close_case` is the final activity in sequence |
| **Three-way match integrity** | In alternative model, PARALLEL ensures both goods AND invoice arrive before matching |

### Summary of Fix:

- **Original Issue**: Overly permissive PARALLEL operator allowed 5! = 120 different orderings
- **Fix**: Replace PARALLEL with SEQUENCE to enforce exactly 1 valid ordering (or limited flexibility in alternative model)
- **Result**: Model now only accepts traces that follow legitimate Procure-to-Pay business logic