# Analysis of POWL Process Model Anomalies

## 1. Identified Anomalies

### Anomaly 1: Unbounded Loop Between Evaluate (E) and Approve (P)
```
loop = OperatorPOWL(operator=Operator.LOOP, children=[E, P])
```
The `LOOP` operator allows the sequence EP to repeat indefinitely. This means a claim could be evaluated and approved multiple times before progressing, which contradicts a standard linear approval process.

### Anomaly 2: Optional Customer Notification via XOR Skip
```
xor = OperatorPOWL(operator=Operator.XOR, children=[N, skip])
```
The XOR gate allows the process to **completely bypass** notifying the customer (N) by choosing the silent transition (`skip`). In a well-designed claims process, notification should be mandatory.

### Anomaly 3: Premature Claim Closure via Partial Order Shortcut
```
root.order.add_edge(A, C)  # Direct edge from Assign Adjuster to Close Claim
# Missing: root.order.add_edge(xor, C)   never added
```
Two compounding problems:
- A direct ordering edge from `A  C` bypasses evaluation, approval, and notification entirely
- The edge `xor  C` is **never added**, meaning C has no ordering constraint requiring the XOR (notification step) to complete first

---

## 2. Hypotheses on Why Anomalies Exist

### Hypothesis 1: Incomplete Business Rule Implementation
| Anomaly | Scenario |
|---------|----------|
| E/P Loop | A new policy requiring "re-evaluation after conditional approval" was partially coded. The loop was added but never bounded with an exit condition or counter. |
| Skip Notification | A legacy fast-track process existed where low-value claims skipped notification. When consolidating workflows, this exception path was incorrectly preserved as a universal option. |

### Hypothesis 2: Miscommunication Between Departments
The claims operations team may have communicated to the IT/workflow team that:
- *"Sometimes we need to re-approve after new information arrives"*  Implemented as unbounded loop instead of a structured rework subprocess
- *"Notification is handled externally for some claim types"*  Modeled as an optional skip rather than a conditional branch based on claim type

### Hypothesis 3: Technical Errors in Workflow System
The premature closure anomaly (`A  C` direct edge) is most consistent with a **copy-paste or drag-drop error** in the process modeler's GUI — an edge was accidentally created between the wrong nodes, and the missing `xor  C` constraint was simply forgotten during model construction.

### Hypothesis 4: Inadequate Process Modeler Constraints
The POWL tool used here applies **minimal validation** — it doesn't enforce that all nodes in a `StrictPartialOrder` must have a complete ordering path from start to end. A tool with stronger conformance checking would have flagged that `C` is reachable via both `A  C` (short path) and the intended full path.

---

## 3. Database Verification Queries

### Query 1: Claims Closed Without Evaluation or Approval
*Tests Anomaly 3 — premature closure*

```sql
-- Claims that have a Close event but lack either an Evaluate or Approve event
SELECT 
    c.claim_id,
    c.customer_id,
    c.claim_type,
    c.claim_amount,
    c.submission_date,
    -- Flag which mandatory steps are missing
    MAX(CASE WHEN ce.activity = 'E' THEN 1 ELSE 0 END) AS has_evaluate,
    MAX(CASE WHEN ce.activity = 'P' THEN 1 ELSE 0 END) AS has_approve,
    MAX(CASE WHEN ce.activity = 'N' THEN 1 ELSE 0 END) AS has_notify,
    MAX(CASE WHEN ce.activity = 'C' THEN 1 ELSE 0 END) AS has_close
FROM claims c
JOIN claim_events ce ON c.claim_id = ce.claim_id
GROUP BY 
    c.claim_id, c.customer_id, c.claim_type, c.claim_amount, c.submission_date
HAVING 
    MAX(CASE WHEN ce.activity = 'C' THEN 1 ELSE 0 END) = 1  -- Was closed
    AND (
        MAX(CASE WHEN ce.activity = 'E' THEN 1 ELSE 0 END) = 0  -- Never evaluated
        OR MAX(CASE WHEN ce.activity = 'P' THEN 1 ELSE 0 END) = 0  -- Never approved
    )
ORDER BY c.submission_date DESC;
```

### Query 2: Claims Where Closure Happened Before Evaluation or Approval
*Tests Anomaly 3 — timing of premature closure (not just presence/absence)*

```sql
-- Claims where the Close timestamp precedes Evaluate or Approve timestamps
WITH event_times AS (
    SELECT
        claim_id,
        MIN(CASE WHEN activity = 'A' THEN timestamp END) AS assign_time,
        MIN(CASE WHEN activity = 'E' THEN timestamp END) AS first_eval_time,
        MIN(CASE WHEN activity = 'P' THEN timestamp END) AS first_approve_time,
        MIN(CASE WHEN activity = 'N' THEN timestamp END) AS notify_time,
        MIN(CASE WHEN activity = 'C' THEN timestamp END) AS close_time
    FROM claim_events
    GROUP BY claim_id
)
SELECT
    et.claim_id,
    c.claim_type,
    c.claim_amount,
    et.assign_time,
    et.first_eval_time,
    et.first_approve_time,
    et.notify_time,
    et.close_time,
    -- Diagnostic flags
    CASE WHEN et.close_time < et.first_eval_time  
              OR et.first_eval_time IS NULL         THEN 'YES' ELSE 'NO' END AS closed_before_eval,
    CASE WHEN et.close_time < et.first_approve_time 
              OR et.first_approve_time IS NULL      THEN 'YES' ELSE 'NO' END AS closed_before_approve,
    CASE WHEN et.close_time < et.notify_time        
              OR et.notify_time IS NULL             THEN 'YES' ELSE 'NO' END AS closed_before_notify,
    -- Time gap analysis
    EXTRACT(EPOCH FROM (et.close_time - et.assign_time))/3600 AS hours_assign_to_close
FROM event_times et
JOIN claims c ON et.claim_id = c.claim_id
WHERE 
    et.close_time IS NOT NULL
    AND (
        et.close_time < et.first_eval_time
        OR et.first_eval_time IS NULL
        OR et.close_time < et.first_approve_time
        OR et.first_approve_time IS NULL
    )
ORDER BY et.close_time DESC;
```

### Query 3: Claims Approved Multiple Times (Loop Verification)
*Tests Anomaly 1 — repeated E/P cycles*

```sql
-- Identify claims with multiple Approve events, with full cycle details
WITH approval_counts AS (
    SELECT
        claim_id,
        COUNT(*) FILTER (WHERE activity = 'E') AS eval_count,
        COUNT(*) FILTER (WHERE activity = 'P') AS approve_count,
        -- Detect alternating E/P patterns indicative of loop execution
        STRING_AGG(activity, '  ' ORDER BY timestamp) AS activity_sequence
    FROM claim_events
    WHERE activity IN ('E', 'P', 'R', 'A', 'N', 'C')
    GROUP BY claim_id
)
SELECT
    ac.claim_id,
    c.claim_type,
    c.claim_amount,
    ac.eval_count,
    ac.approve_count,
    ac.activity_sequence,
    -- Flag suspicious patterns
    CASE 
        WHEN ac.approve_count > 1 AND ac.eval_count > 1 THEN 'REPEATED_EVAL_APPROVE_CYCLE'
        WHEN ac.approve_count > 1 AND ac.eval_count = 1 THEN 'MULTIPLE_APPROVALS_SINGLE_EVAL'
        WHEN ac.approve_count > 1                       THEN 'MULTIPLE_APPROVALS'
        ELSE 'NORMAL'
    END AS anomaly_type
FROM approval_counts ac
JOIN claims c ON ac.claim_id = c.claim_id
WHERE ac.approve_count > 1
ORDER BY ac.approve_count DESC, ac.eval_count DESC;
```

### Query 4: Frequency of Skipped Customer Notifications
*Tests Anomaly 2 — quantifies how often notification is bypassed*

```sql
-- Overall skip rate for notification, broken down by claim type
WITH closed_claims AS (
    SELECT 
        c.claim_id,
        c.claim_type,
        c.claim_amount,
        MAX(CASE WHEN ce.activity = 'N' THEN 1 ELSE 0 END) AS was_notified,
        MAX(CASE WHEN ce.activity = 'P' THEN 1 ELSE 0 END) AS was_approved,
        MAX(CASE WHEN ce.activity = 'C' THEN 1 ELSE 0 END) AS was_closed
    FROM claims c
    JOIN claim_events ce ON c.claim_id = ce.claim_id
    GROUP BY c.claim_id, c.claim_type, c.claim_amount
    HAVING MAX(CASE WHEN ce.activity = 'C' THEN 1 ELSE 0 END) = 1  -- Only closed claims
)
SELECT
    claim_type,
    COUNT(*)                                          AS total_closed_claims,
    SUM(was_notified)                                 AS notified_count,
    COUNT(*) - SUM(was_notified)                      AS skipped_notification_count,
    ROUND(
        100.0 * (COUNT(*) - SUM(was_notified)) / COUNT(*), 2
    )                                                 AS skip_rate_pct,
    -- Among those skipped: were they at least approved?
    SUM(CASE WHEN was_notified = 0 AND was_approved = 1 THEN 1 ELSE 0 END) AS skipped_but_approved,
    SUM(CASE WHEN was_notified = 0 AND was_approved = 0 THEN 1 ELSE 0 END) AS skipped_and_not_approved
FROM closed_claims
GROUP BY claim_type

UNION ALL

SELECT
    'TOTAL'                                           AS claim_type,
    COUNT(*)                                          AS total_closed_claims,
    SUM(was_notified)                                 AS notified_count,
    COUNT(*) - SUM(was_notified)                      AS skipped_notification_count,
    ROUND(
        100.0 * (COUNT(*) - SUM(was_notified)) / COUNT(*), 2
    )                                                 AS skip_rate_pct,
    SUM(CASE WHEN was_notified = 0 AND was_approved = 1 THEN 1 ELSE 0 END) AS skipped_but_approved,
    SUM(CASE WHEN was_notified = 0 AND was_approved = 0 THEN 1 ELSE 0 END) AS skipped_and_not_approved
FROM closed_claims
ORDER BY claim_type;
```

### Query 5: Comprehensive Conformance Check Against Ideal Process
*Holistic view combining all anomaly checks*

```sql
-- Full conformance audit per claim against the ideal 6-step process
WITH claim_activities AS (
    SELECT
        claim_id,
        MAX(CASE WHEN activity = 'R' THEN timestamp END) AS receive_time,
        MAX(CASE WHEN activity = 'A' THEN timestamp END) AS assign_time,
        MIN(CASE WHEN activity = 'E' THEN timestamp END) AS first_eval_time,
        MAX(CASE WHEN activity = 'E' THEN timestamp END) AS last_eval_time,
        MIN(CASE WHEN activity = 'P' THEN timestamp END) AS first_approve_time,
        MAX(CASE WHEN activity = 'P' THEN timestamp END) AS last_approve_time,
        MAX(CASE WHEN activity = 'N' THEN timestamp END) AS notify_time,
        MAX(CASE WHEN activity = 'C' THEN timestamp END) AS close_time,
        COUNT(CASE WHEN activity = 'E' THEN 1 END)        AS eval_count,
        COUNT(CASE WHEN activity = 'P' THEN 1 END)        AS approve_count
    FROM claim_events
    GROUP BY claim_id
)
SELECT
    ca.claim_id,
    c.claim_type,
    c.claim_amount,
    -- Conformance violation flags
    CASE WHEN ca.receive_time  IS NULL                           THEN 1 ELSE 0 END AS missing_receive,
    CASE WHEN ca.assign_time   IS NULL                           THEN 1 ELSE 0 END AS missing_assign,
    CASE WHEN ca.first_eval_time IS NULL                         THEN 1 ELSE 0 END AS missing_evaluate,
    CASE WHEN ca.first_approve_time IS NULL                      THEN 1 ELSE 0 END AS missing_approve,
    CASE WHEN ca.notify_time   IS NULL                           THEN 1 ELSE 0 END AS missing_notify,
    CASE WHEN ca.close_time    IS NULL                           THEN 1 ELSE 0 END AS missing_close,
    -- Sequence violation flags  
    CASE WHEN ca.close_time < ca.first_eval_time                 THEN 1 ELSE 0 END AS close_before_eval,
    CASE WHEN ca.close_time < ca.first_approve_time              THEN 1 ELSE 0 END AS close_before_approve,
    CASE WHEN ca.first_approve_time < ca.first_eval_time         THEN 1 ELSE 0 END AS approve_before_eval,
    CASE WHEN ca.close_time < ca.notify_time                     THEN 1 ELSE 0 END AS close_before_notify,
    -- Loop anomaly flags
    CASE WHEN ca.eval_count    > 1                               THEN 1 ELSE 0 END AS repeated_evaluation,
    CASE WHEN ca.approve_count > 1                               THEN 1 ELSE 0 END AS repeated_approval,
    -- Summary: total number of violations per claim
    (
        CASE WHEN ca.receive_time       IS NULL                  THEN 1 ELSE 0 END +
        CASE WHEN ca.assign_time        IS NULL                  THEN 1 ELSE 0 END +
        CASE WHEN ca.first_eval_time    IS NULL                  THEN 1 ELSE 0 END +
        CASE WHEN ca.first_approve_time IS NULL                  THEN 1 ELSE 0 END +
        CASE WHEN ca.notify_time        IS NULL                  THEN 1 ELSE 0 END +
        CASE WHEN ca.close_time < ca.first_eval_time             THEN 1 ELSE 0 END +
        CASE WHEN ca.close_time < ca.first_approve_time          THEN 1 ELSE 0 END +
        CASE WHEN ca.approve_count > 1                           THEN 1 ELSE 0 END
    )                                                             AS total_violations
FROM claim_activities ca
JOIN claims c ON ca.claim_id = c.claim_id
ORDER BY total_violations DESC, ca.claim_id;
```

---

## Summary of Findings Framework

```

 Anomaly                      Hypothesis                    Verification Query                

 E/P Loop (unbounded)         Partial rework rule impl.     Query 3: approve_count > 1        
 Skip Notification (XOR)      Legacy fast-track preserved   Query 4: notification skip rate   
 Premature Close (AC edge)   Modeler drag-drop error       Query 1 & 2: close before E/P    
 Missing xorC constraint     Forgotten ordering edge       Query 2: timing analysis          
 All combined                 —                             Query 5: conformance audit        

```

The queries above progressively build from simple presence/absence checks to temporal ordering violations and finally a holistic conformance score per claim, enabling both **detection of anomalies** and **quantification of their business impact**.