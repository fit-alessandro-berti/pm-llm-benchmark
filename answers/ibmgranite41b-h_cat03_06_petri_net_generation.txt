To construct an accepting Petri net for the described insurance claim management process, we will follow these steps:

1. **Define Places**: Represent each state of the process as a place.
2. **Add Transitions**: Each activity in the scenario becomes a transition.
3. **Create Arcs**: Connect places to transitions according to the flow of the process.
4. **Initial and Final Markings**: Define initial and final states for tokens.

Let's implement this using Python with `pm4py`.

```python
from pm4py.objects.petri_net.obj import PetriNet, Marking
from pm4py.objects.petri_net.utils import petri_utils

# Step 1: Create a new Petri Net object
net = PetriNet(name="Insurance Claim Process")

# Define places for each state in the process
source_place = PetriNet.Place(name="Start")
document_verification_place = PetriNet.Place(name="Document Verification")
fraud_check_place = PetriNet.Place(name="Fraud Check")
claim_assessment_place = PetriNet.Place(name="Claim Assessment")
approval_place = PetriNet.Place(name="Approval")
payment_place = PetriNet.Place(name="Payment")
notification_place = PetriNet.Place(name="Notification")
closure_place = PetriNet.Place(name="Closed")

# Add source place
net.places.add(source_place)

# Define transitions and add arcs from the start to each state
transitions = [
    "Document Verification",
    "Fraud Check",
    "Claim Assessment",
    "Approval",
    "Payment",
    "Notification",
    "Closure"
]

for transition in transitions:
    net.transitions.add(transition)
petri_utils.add_arc_from_to(source_place, transitions[0], net)

# Step 2: Connect places to the respective transitions
net.places.add(document_verification_place)
petri_utils.add_arc_from_to(source_place, document_verification_place, net)

net.places.add(fraud_check_place)
petri_utils.add_arc_from_to(document_verification_place, fraud_check_place, net)

net.places.add(claim_assessment_place)
petri_utils.add_arc_from_to(fraud_check_place, claim_assessment_place, net)

net.places.add(approval_place)
petri_utils.add_arc_from_to(claim_assessment_place, approval_place, net)

# Handling re-submission of documents
doc_verification_resub_place = PetriNet.Place(name="Re-Document Submission")
petri_utils.add_arc_from_to(document_verification_place, doc_verification_resub_place, net)

net.places.add(payment_place)
petri_utils.add_arc_from_to(approval_place, payment_place, net)

net.places.add(notification_place)
petri_utils.add_arc_from_to(payment_place, notification_place, net)

net.places.add(closure_place)
petri_utils.add_arc_from_to(notification_place, closure_place, net)

# Step 3: Define the initial marking (im) and final marking (fm)
initial_marking = Marking()
initial_marking[source_place] = 1

final_marking = Marking()
final_marking[closure_place] = 1

print("Initial Marking:", initial_marking)
print("Final Marking:", final_marking)

# Step 4: Remove the sink place since it's not necessary for marking
petri_utils.remove_place(net, closure_place)
del fm[closure_place]
```

### Explanation:

- **Places**: We define `source`, `document_verification`, `fraud_check`, `claim_assessment`, `approval`, `payment`, `notification`, and `closure` as places representing the process states.
  
- **Transitions**: Each activity (e.g., "Document Verification", "Fraud Check") is represented by a transition, labeled with its corresponding name.

- **Arcs**: We connect each place to its respective transition using arcs. This forms the logical sequence of claim processing activities from start to closure.

- **Initial Marking (`im`)**: The process starts when one token (representing an incoming insurance claim) is placed in `source_place`.

- **Final Marking (`fm`)**: The final state, where a single token remains at `closure_place`, indicating that the entire processing chain has been completed and closed.

This code constructs the Petri net for the described process according to your requirements.