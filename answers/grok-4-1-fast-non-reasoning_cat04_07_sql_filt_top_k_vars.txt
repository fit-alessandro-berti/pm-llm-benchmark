```sql
WITH case_sequences AS (
  -- Step 1: Extract ordered sequence of activities for each case
  SELECT 
    case_id,
    LIST_AGG(activity ORDER BY timestamp) AS activity_sequence
  FROM event_log
  GROUP BY case_id
),

variant_stats AS (
  -- Step 2 & 3: Group by sequence (variant) and count frequency, then get top K
  SELECT 
    activity_sequence,
    COUNT(*) as variant_frequency,
    ROW_NUMBER() OVER (ORDER BY COUNT(*) DESC) as variant_rank
  FROM case_sequences
  GROUP BY activity_sequence
),

top_k_variants AS (
  -- Select only top K variants (K is a parameter - adjust as needed)
  SELECT activity_sequence
  FROM variant_stats 
  WHERE variant_rank <= 10  -- Set K=10 here, modify as needed
)

-- Step 4: Return all events from cases belonging to top K variants
SELECT e.*
FROM event_log e
WHERE e.case_id IN (
  SELECT cs.case_id
  FROM case_sequences cs
  JOIN top_k_variants tv ON cs.activity_sequence = tv.activity_sequence
)
ORDER BY e.case_id, e.timestamp;
```

**Key features of this solution:**

1. **`case_sequences` CTE**: Uses `LIST_AGG(activity ORDER BY timestamp)` to create the ordered activity sequence for each `case_id` as a LIST (array).

2. **`variant_stats` CTE**: Groups identical sequences together and counts their frequency, using `ROW_NUMBER()` to rank by frequency (descending).

3. **`top_k_variants` CTE**: Filters to only the top K variants (K=10 in this example - easily adjustable).

4. **Final SELECT**: Joins back to the original `event_log` to return all events for cases matching the top K variants, preserving original order.

**Customization:**
- Change `WHERE variant_rank <= 10` to your desired K value
- The query preserves all original columns and ordering
- Returns complete events (not just sequences) for the filtered cases
- Handles ties correctly via `ROW_NUMBER()`

**Example output**: All rows from `event_log` where `case_id` belongs to one of the top 10 most frequent process variants, ordered by `case_id` and `timestamp`.