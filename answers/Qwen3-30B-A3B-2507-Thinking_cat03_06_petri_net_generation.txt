<think>
We are going to model the insurance claim process as a Petri net.

Steps:
1. We have a start: "Insurance Claim (C)" which we can model as an initial token in a start place.
2. The process steps:
- Claim Registration (CR)
- Document Verification (DV)
- Fraud Check (FC)
- Claim Assessment (CA)
- Approval (AP) [only if threshold is exceeded]
- Payment (P)
- Notification (N)
- Closure (CL)

Additional possibilities:
- After DV, if documents are incomplete, we have Re-Document Submission (RDS) which leads back to DV.
- After FC, if doubts, we have In-depth Investigation (II) which leads back to FC (multiple times).

We'll model:
- A place for each state (before an activity, after an activity, etc.)
- Transitions for each activity (with the activity name as label)

We note that:
- The initial state: token in a start place (we'll call it "start").
- The process starts with Claim Registration (CR).

Let's define the places and transitions:

Places:
- start: initial token (we'll have a place for the start)
- cr: after Claim Registration (so that we can have the token move to the next step)
- dv: after Document Verification (this place will also be the place that can lead to re-submission)
- rds: after Re-Document Submission (which leads back to dv? but note: re-submission is a step that happens after DV fails, so we need a place that represents the state of having to re-submit)

However, note: the problem says that if documents are incomplete after DV, we have RDS before continuing. So:

We have:
dv -> (if complete) -> fc
dv -> (if incomplete) -> rds -> dv

Similarly for fraud check:
fc -> (if no doubts) -> ca
fc -> (if doubts) -> ii -> fc [and ii might happen multiple times]

We can model the re-submission and in-depth investigation as loops.

Proposed structure:

start -> [CR] -> cr
cr -> [DV] -> dv
dv -> [if complete] -> fc
dv -> [if incomplete] -> rds -> dv [so we have a transition for RDS that goes from dv to dv? but note: RDS is a step that happens after dv fails, so we need a place for the incomplete state?]

However, note: the problem says "Re-Document Submission (RDS)" is a step. So we have a transition for RDS.

How to model:

We can have:
After DV, if the documents are incomplete, we go to a state that triggers RDS. But note: RDS is a step that the customer does, so we have a transition for RDS that leads to a re-submission (which then goes back to DV).

So:
We have a place "dv_incomplete" that is marked when DV fails? But the problem doesn't specify an explicit place for "incomplete", so we can model the decision as a split.

We'll use a place for the state after DV (dv) and then from dv we have two transitions:
- one for "complete" (which we label as "DV_complete") leading to fc
- one for "incomplete" (which we label as "DV_incomplete") leading to a place that triggers RDS.

However, note: the problem says "Re-Document Submission (RDS)" is a step. So we should have a transition for RDS.

Let's break down:

After DV, if the documents are incomplete, we have:
dv -> (DV_incomplete) -> [RDS] -> (after RDS) -> dv [so RDS leads to dv?]

But note: RDS is the step of re-submitting the documents, and then we go back to DV. So:

dv -> (DV_incomplete) -> rds_transition -> dv

However, the problem says "Re-Document Submission (RDS)" is a step, so we have a transition labeled "RDS" that takes the token from a place (after DV fails) to a place that then leads to DV? Actually, we can have:

Place: dv (after DV)
Transition: dv_complete (label="DV_complete") -> leads to fc
Transition: dv_incomplete (label="DV_incomplete") -> leads to a place called "rds_wait" (or we can skip a place and go directly to RDS transition? but we need a place for the state after the incomplete decision)

Alternatively, we can have:

We have a place "dv" (meaning the claim is at DV stage and we have a token here).
Then we have two transitions from dv:
- "DV_complete" (which will be labeled as "DV" but note: the problem says the step is DV, and then we have a condition for complete/incomplete) -> but we are modeling the activity as a transition, so the DV activity is the transition. The condition is a choice.

Actually, the DV activity (transition) will be fired, and then we have two possibilities: either the documents are complete (so we go to FC) or incomplete (so we go to RDS). So:

We have a place after DV: let's call it "dv_after"
Then from "dv_after", we have two transitions:
- "DV_complete" (but note: the activity name is DV, so we don't want to label the transition as DV again) -> actually, the transition for the DV activity is already fired. The decision is after DV.

How about:

We model the DV activity as a transition. After DV, we have a place "dv_done". Then we split from "dv_done" to two places: one for "documents complete" and one for "documents incomplete". But note, we don't want to model the decision as a place? We can use a choice (a place that can be marked by either the complete or incomplete branch).

Standard way: use a place that is the result of DV, and then two transitions from that place.

So:

Place: dv_after
Transition: dv_complete (label="DV_complete") -> leads to fc_before
Transition: dv_incomplete (label="DV_incomplete") -> leads to rds_before

Then we have a transition for RDS (label="RDS") that goes from rds_before to dv_after.

Similarly for FC:

Place: fc_after
Transition: fc_no_doubt (label="FC_no_doubt") -> leads to ca_before
Transition: fc_doubt (label="FC_doubt") -> leads to ii_before

Transition: ii (label="II") that goes from ii_before to fc_after.

However, note: the problem says "In-depth Investigation (II) can happen multiple times", so we have a loop: fc_after -> fc_doubt -> ii_before -> ii -> fc_after.

But note: the transition for II is a single transition that leads from ii_before to fc_after.

Now, for the main flow:

start -> [CR] -> cr_after
cr_after -> [DV] -> dv_after
dv_after -> [DV_complete] -> fc_after (and also dv_after -> [DV_incomplete] -> rds_before)
rds_before -> [RDS] -> dv_after

fc_after -> [FC_no_doubt] -> ca_after
fc_after -> [FC_doubt] -> ii_before
ii_before -> [II] -> fc_after

ca_after -> [CA] -> ca_after? Actually, CA is a transition. So:

ca_after (which is the place after CA) -> [AP] (if needed) -> ap_before

But note: Approval (AP) is conditional: only if the amount surpasses a threshold. So:

We have a place after CA: ca_after.
Then from ca_after, we have two transitions:
- ap_needed (label="AP_needed") -> leads to ap_before
- ap_not_needed (label="AP_not_needed") -> leads to p_before

Then, for the approval:
ap_before -> [AP] -> ap_after
ap_after -> p_before

But note: the problem says "if the amount surpasses a certain threshold", so we have a condition. We model the condition as a split.

Then:
p_before -> [P] -> p_after
p_after -> [N] -> n_after
n_after -> [CL] -> cl_after

And the final marking should have a token in cl_after (or a place for the closed claim).

We'll have a final place: "closed".

So the final marking: closed = 1.

We also have an initial marking: token in "start".

Now, let's list all the places we need:

start
cr_after
dv_after
dv_incomplete_place (we don't need a separate place for incomplete, because we have the transition dv_incomplete leading to rds_before, and then rds_before is a place)
rds_before
fc_after
fc_doubt_place (again, we have a transition fc_doubt leading to ii_before)
ii_before
ca_after
ap_needed_place (we don't need a place, we have a transition ap_needed leading to ap_before)
ap_before
ap_after
p_before
p_after
n_after
closed

However, note: we don't need to model the "doubt" or "complete" as places, just as transitions from the after places.

So we'll have:

Places:
start
cr_after
dv_after
rds_before
fc_after
ii_before
ca_after
ap_before
ap_after
p_before
p_after
n_after
closed

Transitions:

CR: from start to cr_after
DV: from cr_after to dv_after
DV_complete: from dv_after to fc_after
DV_incomplete: from dv_after to rds_before
RDS: from rds_before to dv_after
FC: from fc_after to ... wait, note: the fraud check activity is the transition that leads to fc_after? Actually, the activity "Fraud Check" is a transition that we fire to get to fc_after.

But note: we have a place "fc_after" meaning after fraud check. So the transition for Fraud Check (FC) should be:

We have a place "fc_before" (which we don't have in our list) -> but wait, we don't have a place for "before FC". We have:

We get to fc_after from dv_after via DV_complete.

Actually, we don't have a separate place for "before FC". The activity FC is the transition that we fire to get to fc_after? But note: the fraud check is an activity that happens, so we should have a transition for FC.

How about:

We have a place "fc_before" that is the state before fraud check? But we don't have that. Instead, we have:

dv_after -> (DV_complete) -> fc_before? and then FC transition from fc_before to fc_after.

However, the problem states that the activity is "Fraud Check (FC)", so we need a transition labeled "FC". So:

We need a place "fc_before" (which we don't have in our current list) and then the transition FC (label="FC") from fc_before to fc_after.

Similarly, for Claim Assessment (CA): we have a place "ca_before" and transition CA.

So let's adjust:

After DV_complete, we go to fc_before, then FC transition to fc_after.

Similarly, for CA: we have a place after FC (fc_after) and then we go to ca_before? But note: the problem says "Claim Assessment (CA)" is the next step. So:

fc_after -> (FC_no_doubt) -> ca_before
fc_after -> (FC_doubt) -> ii_before [and then II transition leads to fc_before?]

Actually, the II is an investigation that happens after FC, and then we go back to FC (so to fc_before? or to the state before FC? but note: we are going to redo the fraud check, so we need to go back to the point before FC).

So:

After FC_doubt, we go to ii_before, then II transition to fc_before.

Now, the place "fc_before" is the state where we are about to do the fraud check. So when we go back to fc_before, we can do FC again.

Therefore, we need:

Place: fc_before

Similarly, for the main flow:

We have:
dv_after -> DV_complete -> fc_before
fc_before -> [FC] -> fc_after

And for the loop:
fc_after -> FC_doubt -> ii_before
ii_before -> [II] -> fc_before

Now, for Claim Assessment:

We have:
fc_after -> FC_no_doubt -> ca_before
ca_before -> [CA] -> ca_after

Then for Approval:

ca_after -> (if threshold exceeded) -> ap_before
ca_after -> (if not) -> p_before

So we need:

Place: ap_before

Then:
ap_before -> [AP] -> ap_after
ap_after -> p_before

Then:
p_before -> [P] -> p_after
p_after -> [N] -> n_after
n_after -> [CL] -> closed

Now, let's list all places and transitions:

Places:
start
cr_after
dv_after
rds_before
fc_before
fc_after
ii_before
ca_before
ca_after
ap_before
ap_after
p_before
p_after
n_after
closed

Transitions:
CR: start -> cr_after
DV: cr_after -> dv_after
DV_complete: dv_after -> fc_before
DV_incomplete: dv_after -> rds_before
RDS: rds_before -> dv_after
FC: fc_before -> fc_after
FC_no_doubt: fc_after -> ca_before
FC_doubt: fc_after -> ii_before
II: ii_before -> fc_before
CA: ca_before -> ca_after
AP_needed: ca_after -> ap_before [we'll label it as "AP_needed", but note: the activity is Approval, but the condition is the trigger for the approval step]
AP_not_needed: ca_after -> p_before
AP: ap_before -> ap_after
P: p_before -> p_after
N: p_after -> n_after
CL: n_after -> closed

However, note: the problem says "Approval (AP)" is the activity. So the transition for the approval activity is AP. But we have a condition (if threshold exceeded) that triggers the AP activity. So we have two transitions from ca_after: one for when approval is needed (and then we do AP) and one for when not.

We'll label:
The transition that leads to AP: we can call it "AP_needed" (but the activity is "AP", so the transition for the approval activity is the AP transition). The condition is just a choice.

So we have:

We'll have a transition for the approval activity: we'll call it "AP", and it will be triggered from ap_before.

But the condition that leads to ap_before is a transition we'll label as "AP_needed" (meaning the condition that approval is needed) and then the AP transition (activity) will be the next step.

However, in the problem, the step is called "Approval (AP)", so the activity is the approval. We don't have an activity for the condition. So we can model the condition as a split without an activity.

Therefore, we can have:

ca_after -> (if needed) -> ap_before
ca_after -> (if not) -> p_before

And then the transition for the approval activity (AP) is from ap_before to ap_after.

Similarly, for the other conditions.

Now, note: the problem does not require modeling the condition as an activity, so we can use a split (without a transition) by having two arcs from ca_after to ap_before and to p_before.

But in Petri nets, we can have multiple arcs from a place to two different places (without a transition). However, the standard way is to use a transition for the condition? Actually, we don't need an activity for the condition, so we can have two arcs.

However, in the example code provided, they use transitions to model the activities. The condition is not an activity, so we model it by having two outgoing arcs from the place.

So we can do:

ca_after has two outgoing arcs:
one to ap_before (labeled with the condition "if threshold exceeded", but we don't have a transition for that condition)
one to p_before (labeled "if threshold not exceeded")

But note: the problem says "the claim must be approved by a senior manager if the amount surpasses a certain threshold". So the condition is inherent, and we don't have an activity for the condition.

Therefore, we model the condition as two arcs without a transition.

Similarly for the other conditions (DV and FC).

So we remove the transitions DV_complete, DV_incomplete, FC_no_doubt, FC_doubt? Actually, no: the condition is modeled by the split (multiple arcs). The activities are the transitions.

Therefore, we don't need the transitions for the conditions (like DV_complete). We just have:

dv_after has two outgoing arcs:
one to fc_before (for the complete case) -> we'll label the arc with "complete" but in the code we don't label arcs, we just have the arcs.
one to rds_before (for the incomplete case)

However, the problem says the transition for DV is the activity "DV", so we have a transition for DV (which is the activity) that goes from cr_after to dv_after.

Then, after DV (so at dv_after), we have two choices: complete or incomplete. We model that by having two arcs from dv_after to two different places.

Similarly, for FC: we have a transition for FC (activity) from fc_before to fc_after. Then after FC (fc_after), we have two arcs: one to ca_before (for no doubt) and one to ii_before (for doubt).

So we don't need the transitions DV_complete, DV_incomplete, FC_no_doubt, FC_doubt.

Therefore, we adjust:

Places:
start
cr_after
dv_after
rds_before
fc_before
fc_after
ii_before
ca_before
ca_after
ap_before
ap_after
p_before
p_after
n_after
closed

Transitions (with labels as the activity names):
CR: start -> cr_after
DV: cr_after -> dv_after
RDS: rds_before -> dv_after [but note: RDS is a step that happens after DV fails, so it's an activity that we have to model as a transition]
FC: fc_before -> fc_after
II: ii_before -> fc_before
CA: ca_before -> ca_after
AP: ap_before -> ap_after
P: p_before -> p_after
N: p_after -> n_after
CL: n_after -> closed

And the splits (without transitions) for the conditions:

From dv_after:
arc to fc_before (for complete)
arc to rds_before (for incomplete)

From fc_after:
arc to ca_before (for no doubt)
arc to ii_before (for doubt)

From ca_after:
arc to ap_before (for threshold exceeded)
arc to p_before (for threshold not exceeded)

Now, note: the RDS activity is a transition (labeled "RDS") that goes from rds_before to dv_after.

Similarly, the II activity is a transition (labeled "II") from ii_before to fc_before.

We don't have transitions for the conditions (like "complete" or "doubt") because they are not activities.

Now, let's write the code.

Steps:

1. Create the Petri net.
2. Create all the places.
3. Create all the transitions (with labels).
4. Add arcs (using petri_utils.add_arc_from_to).
5. Define initial marking: token in "start".
6. Define final marking: token in "closed".

Note: We have to assign the names to the places and transitions as we defined.

We'll name the places and transitions as follows:

Places:
start = Place(name="start")
cr_after = Place(name="cr_after")
dv_after = Place(name="dv_after")
rds_before = Place(name="rds_before")
fc_before = Place(name="fc_before")
fc_after = Place(name="fc_after")
ii_before = Place(name="ii_before")
ca_before = Place(name="ca_before")
ca_after = Place(name="ca_after")
ap_before = Place(name="ap_before")
ap_after = Place(name="ap_after")
p_before = Place(name="p_before")
p_after = Place(name="p_after")
n_after = Place(name="n_after")
closed = Place(name="closed")

Transitions:
CR = Transition(name="CR", label="Claim Registration")
DV = Transition(name="DV", label="Document Verification")
RDS = Transition(name="RDS", label="Re-Document Submission")
FC = Transition(name="FC", label="Fraud Check")
II = Transition(name="II", label="In-depth Investigation")
CA = Transition(name="CA", label="Claim Assessment")
AP = Transition(name="AP", label="Approval")
P = Transition(name="P", label="Payment")
N = Transition(name="N", label="Notification")
CL = Transition(name="CL", label="Closure")

Now, add the arcs:

CR: start -> cr_after
DV: cr_after -> dv_after
From dv_after:
dv_after -> fc_before (for complete)
dv_after -> rds_before (for incomplete)
RDS: rds_before -> dv_after
FC: fc_before -> fc_after
From fc_after:
fc_after -> ca_before (for no doubt)
fc_after -> ii_before (for doubt)
II: ii_before -> fc_before
CA: ca_before -> ca_after
From ca_after:
ca_after -> ap_before (for threshold exceeded)
ca_after -> p_before (for threshold not exceeded)
AP: ap_before -> ap_after
P: p_before -> p_after
N: p_after -> n_after
CL: n_after -> closed

Now, let's code accordingly.

Note: The initial marking: im = Marking() with im[start] = 1.
Final marking: fm = Marking() with fm[closed] = 1.

We'll create the net and then add the places and transitions.

Important: The problem says "the initial marking should place a token in a start place", so we have a place named "start".

We'll create the net and then the places and transitions.

Let's write the code.

Note: We are using the pm4py library.

We have to import:
from pm4py.objects.petri_net.obj import PetriNet, Place, Transition, Marking
from pm4py.objects.petri_net.utils import petri_utils

But note: the example uses `PetriNet.Place` and `PetriNet.Transition`.

We'll create the net and then add the places and transitions.

Steps in code:

net = PetriNet(name="Insurance Claim Process")

# Create places
start = Place("start")
cr_after = Place("cr_after")
dv_after = Place("dv_after")
rds_before = Place("rds_before")
fc_before = Place("fc_before")
fc_after = Place("fc_after")
ii_before = Place("ii_before")
ca_before = Place("ca_before")
ca_after = Place("ca_after")
ap_before = Place("ap_before")
ap_after = Place("ap_after")
p_before = Place("p_before")
p_after = Place("p_after")
n_after = Place("n_after")
closed = Place("closed")

# Add places to net
net.places.add(start)
net.places.add(cr_after)
net.places.add(dv_after)
net.places.add(rds_before)
net.places.add(fc_before)
net.places.add(fc_after)
net.places.add(ii_before)
net.places.add(ca_before)
net.places.add(ca_after)
net.places.add(ap_before)
net.places.add(ap_after)
net.places.add(p_before)
net.places.add(p_after)
net.places.add(n_after)
net.places.add(closed)

# Create transitions
CR = Transition("CR", label="Claim Registration")
DV = Transition("DV", label="Document Verification")
RDS = Transition("RDS", label="Re-Document Submission")
FC = Transition("FC", label="Fraud Check")
II = Transition("II", label="In-depth Investigation")
CA = Transition("CA", label="Claim Assessment")
AP = Transition("AP", label="Approval")
P = Transition("P", label="Payment")
N = Transition("N", label="Notification")
CL = Transition("CL", label="Closure")

# Add transitions to net
net.transitions.add(CR)
net.transitions.add(DV)
net.transitions.add(RDS)
net.transitions.add(FC)
net.transitions.add(II)
net.transitions.add(CA)
net.transitions.add(AP)
net.transitions.add(P)
net.transitions.add(N)
net.transitions.add(CL)

# Add arcs
petri_utils.add_arc_from_to(start, CR, net)
petri_utils.add_arc_from_to(CR, cr_after, net)

petri_utils.add_arc_from_to(cr_after, DV, net)
petri_utils.add_arc_from_to(DV, dv_after, net)

petri_utils.add_arc_from_to(dv_after, fc_before, net) # complete
petri_utils.add_arc_from_to(dv_after, rds_before, net) # incomplete

petri_utils.add_arc_from_to(rds_before, RDS, net)
petri_utils.add_arc_from_to(RDS, dv_after, net)

petri_utils.add_arc_from_to(fc_before, FC, net)
petri_utils.add_arc_from_to(FC, fc_after, net)

petri_utils.add_arc_from_to(fc_after, ca_before, net) # no doubt
petri_utils.add_arc_from_to(fc_after, ii_before, net) # doubt

petri_utils.add_arc_from_to(ii_before, II, net)
petri_utils.add_arc_from_to(II, fc_before, net)

petri_utils.add_arc_from_to(ca_before, CA, net)
petri_utils.add_arc_from_to(CA, ca_after, net)

petri_utils.add_arc_from_to(ca_after, ap_before, net) # threshold exceeded
petri_utils.add_arc_from_to(ca_after, p_before, net) # threshold not exceeded

petri_utils.add_arc_from_to(ap_before, AP, net)
petri_utils.add_arc_from_to(AP, ap_after, net)

petri_utils.add_arc_from_to(p_before, P, net)
petri_utils.add_arc_from_to(P, p_after, net)

petri_utils.add_arc_from_to(p_after, N, net)
petri_utils.add_arc_from_to(N, n_after, net)

petri_utils.add_arc_from_to(n_after, CL, net)
petri_utils.add_arc_from_to(CL, closed, net)

Now, initial marking:
im = Marking()
im[start] = 1

Final marking:
fm = Marking()
fm[closed] = 1

However, note: the problem says the final marking should represent a closed claim, so we have a token in the closed place.

We are done.

Let's write the code accordingly.

Note: We are not using the example's removal of a place, so we don't need to remove anything.

We'll output the code.

Important: The problem says "Provide the Python code for constructing the Petri net".

We'll write the code as described.

One note: The place names we used are strings. We are using the string names as the place names.

But note: the Place objects have a `name` attribute. However, in the code above, we are using the string as the name when creating the Place. Then we assign the Place object to a variable (like `start`). When we add to the net, we use the Place object.

This is correct.

Let's write the code.
</think>

To model the insurance claim management process as an accepting Petri net, we need to capture the main workflow, conditional paths (re-submission and in-depth investigation), and the final state. The solution uses places to represent states between activities, transitions for activities with labels, and arcs to define the flow. Conditional splits (for incomplete documents and fraud doubts) are modeled as multiple arcs from a single place without additional transitions.

Here's the complete Python code using `pm4py`:

```python
from pm4py.objects.petri_net.obj import PetriNet, Place, Transition, Marking
from pm4py.objects.petri_net.utils import petri_utils

# Create the Petri net
net = PetriNet(name="Insurance Claim Process")

# Create places
start = Place("start")
cr_after = Place("cr_after")
dv_after = Place("dv_after")
rds_before = Place("rds_before")
fc_before = Place("fc_before")
fc_after = Place("fc_after")
ii_before = Place("ii_before")
ca_before = Place("ca_before")
ca_after = Place("ca_after")
ap_before = Place("ap_before")
ap_after = Place("ap_after")
p_before = Place("p_before")
p_after = Place("p_after")
n_after = Place("n_after")
closed = Place("closed")

# Add places to the net
net.places.add(start)
net.places.add(cr_after)
net.places.add(dv_after)
net.places.add(rds_before)
net.places.add(fc_before)
net.places.add(fc_after)
net.places.add(ii_before)
net.places.add(ca_before)
net.places.add(ca_after)
net.places.add(ap_before)
net.places.add(ap_after)
net.places.add(p_before)
net.places.add(p_after)
net.places.add(n_after)
net.places.add(closed)

# Create transitions with activity labels
CR = Transition("CR", label="Claim Registration")
DV = Transition("DV", label="Document Verification")
RDS = Transition("RDS", label="Re-Document Submission")
FC = Transition("FC", label="Fraud Check")
II = Transition("II", label="In-depth Investigation")
CA = Transition("CA", label="Claim Assessment")
AP = Transition("AP", label="Approval")
P = Transition("P", label="Payment")
N = Transition("N", label="Notification")
CL = Transition("CL", label="Closure")

# Add transitions to the net
net.transitions.add(CR)
net.transitions.add(DV)
net.transitions.add(RDS)
net.transitions.add(FC)
net.transitions.add(II)
net.transitions.add(CA)
net.transitions.add(AP)
net.transitions.add(P)
net.transitions.add(N)
net.transitions.add(CL)

# Add arcs to define the workflow
petri_utils.add_arc_from_to(start, CR, net)
petri_utils.add_arc_from_to(CR, cr_after, net)

petri_utils.add_arc_from_to(cr_after, DV, net)
petri_utils.add_arc_from_to(DV, dv_after, net)

# Conditional split after Document Verification (DV)
petri_utils.add_arc_from_to(dv_after, fc_before, net)  # Documents complete
petri_utils.add_arc_from_to(dv_after, rds_before, net)  # Documents incomplete

petri_utils.add_arc_from_to(rds_before, RDS, net)
petri_utils.add_arc_from_to(RDS, dv_after, net)

petri_utils.add_arc_from_to(fc_before, FC, net)
petri_utils.add_arc_from_to(FC, fc_after, net)

# Conditional split after Fraud Check (FC)
petri_utils.add_arc_from_to(fc_after, ca_before, net)  # No fraud doubts
petri_utils.add_arc_from_to(fc_after, ii_before, net)  # Fraud doubts

petri_utils.add_arc_from_to(ii_before, II, net)
petri_utils.add_arc_from_to(II, fc_before, net)

petri_utils.add_arc_from_to(ca_before, CA, net)
petri_utils.add_arc_from_to(CA, ca_after, net)

# Conditional split after Claim Assessment (CA)
petri_utils.add_arc_from_to(ca_after, ap_before, net)  # Approval needed
petri_utils.add_arc_from_to(ca_after, p_before, net)  # Approval not needed

petri_utils.add_arc_from_to(ap_before, AP, net)
petri_utils.add_arc_from_to(AP, ap_after, net)

petri_utils.add_arc_from_to(p_before, P, net)
petri_utils.add_arc_from_to(P, p_after, net)

petri_utils.add_arc_from_to(p_after, N, net)
petri_utils.add_arc_from_to(N, n_after, net)

petri_utils.add_arc_from_to(n_after, CL, net)
petri_utils.add_arc_from_to(CL, closed, net)

# Define initial marking (token in start place)
im = Marking()
im[start] = 1

# Define final marking (token in closed place)
fm = Marking()
fm[closed] = 1
```

### Key Features of the Model:
1. **Initial State**: Token starts in the `start` place (new claim arrival).
2. **Main Workflow**:
   - `Claim Registration` → `Document Verification` → `Fraud Check` → `Claim Assessment` → `Approval` (conditional) → `Payment` → `Notification` → `Closure`.
3. **Conditional Paths**:
   - **Document Re-submission**: If documents are incomplete after `Document Verification`, the process loops back via `Re-Document Submission` to `Document Verification`.
   - **In-depth Investigation**: If fraud doubts arise after `Fraud Check`, the process loops back via `In-depth Investigation` to `Fraud Check`.
4. **Final State**: Token ends in the `closed` place (claim successfully closed).

### How It Works:
- **Place Names**: Represent states (e.g., `dv_after` = after Document Verification).
- **Transition Labels**: Activities (e.g., `DV` = Document Verification).
- **Arcs**: Define flow (e.g., `dv_after` → `fc_before` for complete documents, `dv_after` → `rds_before` for incomplete documents).
- **Markings**: 
  - `im`: Initial token in `start` (new claim).
  - `fm`: Final token in `closed` (claim closed).

This model accurately captures the process flow, conditional loops, and termination state as required by the scenario. The Petri net can be visualized or analyzed using `pm4py` tools to verify correctness.