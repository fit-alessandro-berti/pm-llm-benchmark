# Analysis and Fix for Underfitting Procure-to-Pay Process Tree

## 1. Issues with the Current Model

The current model has a **PARALLEL (AND) block** containing five critical activities that should **not** execute in arbitrary order. This allows several domain-inappropriate behaviors:

| Unwanted Behavior | Why It's Wrong |
|-------------------|----------------|
| Pay Invoice before Receive Goods | Cannot pay for goods not yet verified as received |
| Pay Invoice before Receive Invoice | Cannot pay an invoice that hasn't arrived |
| Match Invoice to PO before Receive Invoice | Cannot match a non-existent invoice |
| Match Invoice to PO before Create PO | Cannot match to a PO that doesn't exist |
| Receive Goods before Create PO | Goods are delivered against a valid PO |
| Pay Invoice before Match Invoice to PO | Payment requires successful 3-way match verification |

The parallel block essentially removes all control-flow dependencies between these activities, creating an **underfitting** model that permits traces that would never occur in a compliant Procure-to-Pay process.

---

## 2. Corrected Process Tree Model

```python
from pm4py.objects.process_tree.obj import Operator, ProcessTree

# Define activities
create_req = ProcessTree(label="Create_Purchase_Requisition")
approve_req = ProcessTree(label="Approve_Purchase_Requisition")
create_po = ProcessTree(label="Create_Purchase_Order")
receive_goods = ProcessTree(label="Receive_Goods")
receive_invoice = ProcessTree(label="Receive_Invoice")
match_invoice = ProcessTree(label="Match_Invoice_to_PO")
pay_invoice = ProcessTree(label="Pay_Invoice")
close_case = ProcessTree(label="Close_Case")

# FIXED: Enforce strict sequential order as per standard Procure-to-Pay logic
root = ProcessTree(operator=Operator.SEQUENCE, children=[
    create_req,       # Step 1: Create Purchase Requisition
    approve_req,      # Step 2: Approve Purchase Requisition
    create_po,        # Step 3: Create Purchase Order
    receive_goods,    # Step 4: Receive Goods
    receive_invoice,  # Step 5: Receive Invoice
    match_invoice,    # Step 6: Match Invoice to PO
    pay_invoice,      # Step 7: Pay Invoice
    close_case        # Step 8: Close Case
])

# Set parent references for completeness
for child in root.children:
    child.parent = root
```

### Visual Representation of the Fixed Model

```
             (SEQUENCE)
               
    
                                                                                    
 Create     Approve    Create    Receive   Receive    Match      Pay       Close
 Purchase   Purchase   Purchase   Goods    Invoice   Invoice   Invoice    Case
 Requisition Requisition Order                       to PO
```

---

## 3. How the Updated Model Ensures Conformance

| Aspect | How It's Enforced |
|--------|-------------------|
| **Sequential Dependencies** | The `SEQUENCE` operator ensures each activity must complete before the next begins |
| **No Premature Payment** | `Pay_Invoice` can only occur after `Match_Invoice_to_PO` completes |
| **Proper Verification** | `Match_Invoice_to_PO` requires both `Receive_Goods` and `Receive_Invoice` to have occurred |
| **Valid PO Existence** | `Create_Purchase_Order` must complete before goods/invoice activities |
| **Proper Authorization** | `Approve_Purchase_Requisition` must occur before any purchasing activities |
| **Clean Closure** | `Close_Case` is always the final activity |

### Traces Comparison

| Model | Example Allowed Trace | Valid? |
|-------|----------------------|--------|
| **Original (Underfitting)** | Create_Req  Approve_Req  **Pay_Invoice**  Create_PO  ... |  Invalid |
| **Original (Underfitting)** | Create_Req  Approve_Req  Match_Invoice  Receive_Invoice  ... |  Invalid |
| **Fixed Model** | Create_Req  Approve_Req  Create_PO  Receive_Goods  Receive_Invoice  Match_Invoice  Pay_Invoice  Close_Case |  Valid |

---

## Alternative: Slightly More Flexible (But Still Controlled) Model

In real-world scenarios, goods and invoices may arrive in either order. If this flexibility is desired:

```python
# Goods and Invoice can arrive in either order, but both before matching
goods_invoice_parallel = ProcessTree(operator=Operator.PARALLEL, children=[
    receive_goods,
    receive_invoice
])

root = ProcessTree(operator=Operator.SEQUENCE, children=[
    create_req,
    approve_req,
    create_po,
    goods_invoice_parallel,  # Both must occur, order flexible
    match_invoice,
    pay_invoice,
    close_case
])
```

This alternative still prevents paying before matching, and ensures both goods and invoice are received before the matching step—while allowing real-world flexibility in arrival order.