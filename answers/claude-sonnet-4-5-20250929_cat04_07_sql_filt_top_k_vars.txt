# DuckDB SQL Query for Top K Process Variants

Here's a comprehensive solution that extracts process variants and filters events belonging to the top K variants:

```sql
WITH ordered_activities AS (
    -- Step 1: Order activities within each case by timestamp
    SELECT 
        case_id,
        activity,
        timestamp,
        ROW_NUMBER() OVER (PARTITION BY case_id ORDER BY timestamp) as activity_order
    FROM event_log
),

case_variants AS (
    -- Step 2: Create activity sequence (variant) for each case
    SELECT 
        case_id,
        STRING_AGG(activity, ' -> ' ORDER BY timestamp) as variant
    FROM event_log
    GROUP BY case_id
),

variant_counts AS (
    -- Step 3: Count cases per variant
    SELECT 
        variant,
        COUNT(*) as case_count,
        ARRAY_AGG(case_id) as case_ids
    FROM case_variants
    GROUP BY variant
),

top_k_variants AS (
    -- Step 4: Get top K variants by frequency
    SELECT 
        variant,
        case_count,
        UNNEST(case_ids) as case_id
    FROM variant_counts
    ORDER BY case_count DESC, variant
    LIMIT K  -- Replace K with your desired number (e.g., 5, 10)
)

-- Step 5: Return all events from cases in top K variants
SELECT 
    el.case_id,
    el.activity,
    el.timestamp
FROM event_log el
INNER JOIN top_k_variants tkv ON el.case_id = tkv.case_id
ORDER BY el.case_id, el.timestamp;
```

## Alternative Approach (More Efficient for Large Datasets)

```sql
WITH case_variants AS (
    -- Create variant signature for each case
    SELECT 
        case_id,
        LIST(activity ORDER BY timestamp) as variant_list,
        STRING_AGG(activity, ' -> ' ORDER BY timestamp) as variant
    FROM event_log
    GROUP BY case_id
),

variant_frequency AS (
    -- Count frequency of each variant
    SELECT 
        variant,
        COUNT(*) as frequency
    FROM case_variants
    GROUP BY variant
),

top_k_variants AS (
    -- Identify top K variants
    SELECT variant
    FROM variant_frequency
    ORDER BY frequency DESC, variant
    LIMIT K  -- Replace K with desired number
)

-- Filter original events to only top K variant cases
SELECT 
    el.*
FROM event_log el
WHERE el.case_id IN (
    SELECT cv.case_id
    FROM case_variants cv
    INNER JOIN top_k_variants tkv ON cv.variant = tkv.variant
)
ORDER BY el.case_id, el.timestamp;
```

## Parameterized Version (Using DuckDB Prepared Statements)

```sql
PREPARE top_variants AS
WITH case_variants AS (
    SELECT 
        case_id,
        STRING_AGG(activity, ' -> ' ORDER BY timestamp) as variant
    FROM event_log
    GROUP BY case_id
),
variant_counts AS (
    SELECT 
        variant,
        COUNT(*) as case_count
    FROM case_variants
    GROUP BY variant
),
top_k AS (
    SELECT variant
    FROM variant_counts
    ORDER BY case_count DESC, variant
    LIMIT $1
),
filtered_cases AS (
    SELECT cv.case_id
    FROM case_variants cv
    INNER JOIN top_k tk ON cv.variant = tk.variant
)
SELECT el.*
FROM event_log el
WHERE el.case_id IN (SELECT case_id FROM filtered_cases)
ORDER BY el.case_id, el.timestamp;

-- Execute with K=5
EXECUTE top_variants(5);
```

## Query with Variant Statistics

If you also want to see the variant information alongside the events:

```sql
WITH case_variants AS (
    SELECT 
        case_id,
        STRING_AGG(activity, ' -> ' ORDER BY timestamp) as variant
    FROM event_log
    GROUP BY case_id
),
variant_stats AS (
    SELECT 
        variant,
        COUNT(*) as case_count,
        ROW_NUMBER() OVER (ORDER BY COUNT(*) DESC, variant) as variant_rank
    FROM case_variants
    GROUP BY variant
),
top_k_cases AS (
    SELECT 
        cv.case_id,
        vs.variant,
        vs.case_count,
        vs.variant_rank
    FROM case_variants cv
    INNER JOIN variant_stats vs ON cv.variant = vs.variant
    WHERE vs.variant_rank <= K  -- Replace K with desired number
)

SELECT 
    el.case_id,
    el.activity,
    el.timestamp,
    tkc.variant,
    tkc.case_count,
    tkc.variant_rank
FROM event_log el
INNER JOIN top_k_cases tkc ON el.case_id = tkc.case_id
ORDER BY tkc.variant_rank, el.case_id, el.timestamp;
```

## Key Features:

1. **Ordered Sequences**: Uses `ORDER BY timestamp` within aggregations to maintain proper activity order
2. **Variant Identification**: Creates unique variant signatures using `STRING_AGG` or `LIST`
3. **Frequency Counting**: Aggregates cases per variant
4. **Top K Selection**: Uses `ORDER BY ... LIMIT K` to get most frequent variants
5. **Event Filtering**: Joins back to original table to retrieve all matching events

**Note**: Replace `K` with your desired number (e.g., 5, 10, 20) or use the prepared statement approach for dynamic values.