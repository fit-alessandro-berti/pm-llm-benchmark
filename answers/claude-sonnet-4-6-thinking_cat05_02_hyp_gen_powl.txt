# Analysis of the POWL Model: Anomalies, Hypotheses, and Verification

---

## 1. Identifying the Anomalies

### Anomaly 1 — Unbounded Loop Between Evaluate (E) and Approve (P)

```
loop = LOOP(E, P)
```

The `LOOP(E, P)` operator means: *execute E, then either exit OR execute P and loop back to E again — indefinitely*. In a well-governed claims process, a claim should be evaluated once, approved once (if appropriate), and move forward. This structure permits:
- Evaluation without any approval (exit after E)
- Repeated approval of the same claim (P  E  P  E  …)
- Redundant evaluation cycles that delay resolution

This is a **structural anomaly** because it creates a pathway for multiple approvals of the same claim — a major financial control risk.

---

### Anomaly 2 — XOR That May Skip Customer Notification (N)

```
xor = XOR(N, skip)
```

The `XOR(N, skip)` means the process chooses *either* Notify Customer *or* silently do nothing. This makes the mandatory customer notification step **optional**. In insurance, customers are legally entitled to be informed of claim decisions. Silently skipping this step is a compliance and regulatory risk.

---

### Anomaly 3 — Partial Order Allows Premature Claim Closure (C)

```python
root.order.add_edge(R, A)
root.order.add_edge(A, loop)
root.order.add_edge(loop, xor)
root.order.add_edge(A, C)    #  Anomalous edge
# MISSING: root.order.add_edge(xor, C)
```

Two compounding problems exist here:
- A direct edge `A  C` means C **only requires A to have completed** — the loop (E+P) and xor (N) can be bypassed entirely.
- The `xor  C` edge is **missing**, so even if the loop runs, C is not formally constrained to wait for notification.

This means a claim can be: *Received  Adjuster Assigned  Closed* — with no evaluation, no approval, and no notification.

---

## 2. Hypotheses on Why These Anomalies Exist

### Hypothesis A — Partially Implemented Business Rule Changes
> A new policy (e.g., "fast-track closure for low-value claims") was partially encoded: someone added the `A  C` edge to allow quick closure but forgot to gate it on claim type/amount or remove the constraint that full evaluation must precede closure.

### Hypothesis B — Miscommunication Between Departments
> The IT team building the workflow received ambiguous requirements. The claims department said "sometimes adjusters need to re-evaluate after an initial approval when new evidence arrives," so the developer modeled this as an unbounded loop instead of a controlled retry mechanism with a maximum iteration count.

### Hypothesis C — Legacy Process Artifacts / Technical Debt
> The `A  C` edge may be a remnant of an older process where certain claim types (e.g., duplicate submissions, fraudulent claims identified at intake) were immediately closed after adjuster assignment. When the process was updated, this shortcut path was never removed.

### Hypothesis D — Inadequate Constraints in the Process Modelling Tool
> The POWL tool does not enforce business rule validation on the partial order. A modeler may have accidentally added the `A  C` edge or failed to add the `xor  C` edge, and no automated check caught the issue before deployment.

### Hypothesis E — Deliberate but Undocumented Workaround
> Adjusters or system operators may have requested the ability to skip notification for certain internal test claims or voided claims. This was implemented via the `skip` branch but never properly scoped or documented, creating a process-wide loophole.

---

## 3. Database Queries to Verify the Hypotheses

### Query 1 — Claims Closed Without Any Evaluation or Approval

*Detects Anomaly 3: premature closure after just R  A  C*

```sql
-- Claims that have a Close (C) event but no Evaluate (E) AND no Approve (P) event
SELECT
    c.claim_id,
    c.customer_id,
    c.claim_type,
    c.claim_amount,
    c.submission_date,
    ce_close.timestamp   AS closed_at
FROM claims c
JOIN claim_events ce_close
    ON c.claim_id = ce_close.claim_id
    AND ce_close.activity = 'C'
WHERE NOT EXISTS (
    SELECT 1
    FROM claim_events ce_eval
    WHERE ce_eval.claim_id = c.claim_id
      AND ce_eval.activity = 'E'
)
AND NOT EXISTS (
    SELECT 1
    FROM claim_events ce_approve
    WHERE ce_approve.claim_id = c.claim_id
      AND ce_approve.activity = 'P'
)
ORDER BY ce_close.timestamp DESC;
```

---

### Query 2 — Claims Closed Before Evaluation or Approval Occurred (Timestamp Check)

*Detects out-of-sequence execution: C timestamp precedes E or P*

```sql
-- Claims where Close happened BEFORE the first Evaluate or first Approve
SELECT
    c.claim_id,
    c.claim_type,
    c.claim_amount,
    MIN(CASE WHEN ce.activity = 'E' THEN ce.timestamp END) AS first_evaluate_at,
    MIN(CASE WHEN ce.activity = 'P' THEN ce.timestamp END) AS first_approve_at,
    MIN(CASE WHEN ce.activity = 'C' THEN ce.timestamp END) AS first_close_at
FROM claims c
JOIN claim_events ce ON c.claim_id = ce.claim_id
WHERE ce.activity IN ('E', 'P', 'C')
GROUP BY c.claim_id, c.claim_type, c.claim_amount
HAVING
    MIN(CASE WHEN ce.activity = 'C' THEN ce.timestamp END)
    < COALESCE(
        MIN(CASE WHEN ce.activity = 'E' THEN ce.timestamp END),
        MIN(CASE WHEN ce.activity = 'C' THEN ce.timestamp END)
      )
    OR
    MIN(CASE WHEN ce.activity = 'C' THEN ce.timestamp END)
    < COALESCE(
        MIN(CASE WHEN ce.activity = 'P' THEN ce.timestamp END),
        MIN(CASE WHEN ce.activity = 'C' THEN ce.timestamp END)
      )
ORDER BY first_close_at DESC;
```

---

### Query 3 — Claims Approved Multiple Times (Loop Anomaly Verification)

*Detects Anomaly 1: the E  P  E  P loop manifesting as multiple P events per claim*

```sql
-- Claims with more than one Approve (P) event, ordered by frequency
SELECT
    c.claim_id,
    c.customer_id,
    c.claim_type,
    c.claim_amount,
    COUNT(ce.event_id)                          AS approval_count,
    MIN(ce.timestamp)                            AS first_approval_at,
    MAX(ce.timestamp)                            AS last_approval_at,
    MAX(ce.timestamp) - MIN(ce.timestamp)        AS approval_time_span
FROM claims c
JOIN claim_events ce
    ON c.claim_id = ce.claim_id
    AND ce.activity = 'P'
GROUP BY c.claim_id, c.customer_id, c.claim_type, c.claim_amount
HAVING COUNT(ce.event_id) > 1
ORDER BY approval_count DESC, claim_amount DESC;
```

---

### Query 4 — Claims Where Notification Was Skipped Entirely

*Detects Anomaly 2: the XOR chose `skip` (no N event recorded)*

```sql
-- Claims that were fully processed (have C event) but have no Notify (N) event
SELECT
    c.claim_id,
    c.customer_id,
    c.claim_type,
    c.claim_amount,
    c.submission_date,
    -- Show what steps DID occur
    STRING_AGG(ce.activity, '  ' ORDER BY ce.timestamp) AS activity_sequence
FROM claims c
JOIN claim_events ce ON c.claim_id = ce.claim_id
WHERE
    -- Has a Close event (fully processed)
    EXISTS (
        SELECT 1 FROM claim_events
        WHERE claim_id = c.claim_id AND activity = 'C'
    )
    -- But has NO Notify event
    AND NOT EXISTS (
        SELECT 1 FROM claim_events
        WHERE claim_id = c.claim_id AND activity = 'N'
    )
GROUP BY c.claim_id, c.customer_id, c.claim_type, c.claim_amount, c.submission_date
ORDER BY c.submission_date DESC;
```

---

### Query 5 — Notification Skip Rate by Claim Type (Pattern Analysis)

*Determines if skipping N is systematic for certain claim types — supporting Hypothesis E*

```sql
-- Notification skip rate broken down by claim type
SELECT
    c.claim_type,
    COUNT(DISTINCT c.claim_id)                                           AS total_closed_claims,
    COUNT(DISTINCT CASE
        WHEN NOT EXISTS (
            SELECT 1 FROM claim_events ne
            WHERE ne.claim_id = c.claim_id AND ne.activity = 'N'
        ) THEN c.claim_id
    END)                                                                 AS claims_missing_notification,
    ROUND(
        100.0 * COUNT(DISTINCT CASE
            WHEN NOT EXISTS (
                SELECT 1 FROM claim_events ne
                WHERE ne.claim_id = c.claim_id AND ne.activity = 'N'
            ) THEN c.claim_id
        END) / NULLIF(COUNT(DISTINCT c.claim_id), 0),
        2
    )                                                                    AS skip_rate_pct
FROM claims c
WHERE EXISTS (
    SELECT 1 FROM claim_events ce
    WHERE ce.claim_id = c.claim_id AND ce.activity = 'C'
)
GROUP BY c.claim_type
ORDER BY skip_rate_pct DESC;
```

---

### Query 6 — Full Conformance Check: Activity Sequence vs. Ideal Flow

*Identifies which claims followed the ideal RAEPNC path vs. deviant paths*

```sql
-- Classify each closed claim by the sequence of activities it actually followed
WITH claim_sequences AS (
    SELECT
        c.claim_id,
        c.claim_type,
        c.claim_amount,
        STRING_AGG(ce.activity, '' ORDER BY ce.timestamp) AS actual_sequence
    FROM claims c
    JOIN claim_events ce ON c.claim_id = ce.claim_id
    GROUP BY c.claim_id, c.claim_type, c.claim_amount
),
classified AS (
    SELECT
        claim_id,
        claim_type,
        claim_amount,
        actual_sequence,
        CASE
            WHEN actual_sequence = 'RAEPNC'        THEN 'Ideal path'
            WHEN actual_sequence LIKE '%C%'
             AND actual_sequence NOT LIKE '%E%'           THEN 'Closed without evaluation'
            WHEN actual_sequence LIKE '%C%'
             AND actual_sequence NOT LIKE '%P%'           THEN 'Closed without approval'
            WHEN actual_sequence LIKE '%C%'
             AND actual_sequence NOT LIKE '%N%'           THEN 'Closed without notification'
            WHEN actual_sequence ~ '(P.*){2,}'            THEN 'Multiple approvals (loop)'
            ELSE                                               'Other deviant path'
        END AS conformance_category
    FROM claim_sequences
)
SELECT
    conformance_category,
    COUNT(*)                                AS claim_count,
    ROUND(AVG(claim_amount), 2)             AS avg_claim_amount,
    ROUND(100.0 * COUNT(*) / SUM(COUNT(*)) OVER (), 2) AS pct_of_total
FROM classified
GROUP BY conformance_category
ORDER BY claim_count DESC;
```

---

### Query 7 — Adjuster Involvement in Anomalous Cases

*Links anomalous closures to specific adjusters — useful for identifying training gaps or bad actors*

```sql
-- Which adjusters (by name) are associated with prematurely closed claims?
SELECT
    adj.name                        AS adjuster_name,
    adj.specialization,
    adj.region,
    COUNT(DISTINCT c.claim_id)      AS premature_closure_count,
    ROUND(AVG(c.claim_amount), 2)   AS avg_claim_amount
FROM claims c
JOIN claim_events ce_assign
    ON c.claim_id = ce_assign.claim_id
    AND ce_assign.activity = 'A'
JOIN adjusters adj
    ON ce_assign.resource = adj.name   -- resource recorded as adjuster name at assignment
WHERE
    -- Claim was closed
    EXISTS (
        SELECT 1 FROM claim_events WHERE claim_id = c.claim_id AND activity = 'C'
    )
    -- But missing evaluation
    AND NOT EXISTS (
        SELECT 1 FROM claim_events WHERE claim_id = c.claim_id AND activity = 'E'
    )
GROUP BY adj.adjuster_id, adj.name, adj.specialization, adj.region
HAVING COUNT(DISTINCT c.claim_id) > 0
ORDER BY premature_closure_count DESC;
```

---

## Summary Table

| Anomaly | Risk | Hypothesis | Verification Query |
|---|---|---|---|
| `LOOP(E, P)` — repeated approvals | Financial loss, double payment | Partial rule change / miscommunication | Query 3 |
| `XOR(N, skip)` — skipped notification | Regulatory/legal compliance breach | Legacy workaround / undocumented scope | Queries 4, 5 |
| `A  C` direct edge — premature closure | Unresolved claims, customer harm | Technical debt / tool constraint gap | Queries 1, 2 |
| Missing `xor  C` constraint | Closure before notification enforced | Modelling error / incomplete design | Queries 1, 6 |
| Deviant paths overall | Process integrity | Any of the above combined | Queries 6, 7 |

These queries together form a **process conformance audit** that bridges the POWL model's structural anomalies with empirical evidence from real event data, enabling data-driven remediation decisions.