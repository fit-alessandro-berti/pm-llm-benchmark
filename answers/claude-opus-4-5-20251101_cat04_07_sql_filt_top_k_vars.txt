# DuckDB SQL Query for Top K Process Variants

## Solution

```sql
WITH 
-- Step 1: Construct the ordered sequence of activities for each case
case_sequences AS (
    SELECT 
        case_id,
        STRING_AGG(activity, ' -> ' ORDER BY timestamp) AS variant
    FROM event_log
    GROUP BY case_id
),

-- Step 2 & 3: Group by variant, count cases, and rank by frequency
variant_counts AS (
    SELECT 
        variant,
        COUNT(*) AS case_count,
        RANK() OVER (ORDER BY COUNT(*) DESC) AS variant_rank
    FROM case_sequences
    GROUP BY variant
),

-- Step 4: Identify top K variants (replace K with desired number)
top_k_variants AS (
    SELECT variant
    FROM variant_counts
    WHERE variant_rank <= 5  -- K = 5, adjust as needed
),

-- Step 5: Get all case_ids that belong to top K variants
filtered_cases AS (
    SELECT cs.case_id
    FROM case_sequences cs
    INNER JOIN top_k_variants tkv ON cs.variant = tkv.variant
)

-- Step 6: Return all events from the original log for filtered cases
SELECT el.*
FROM event_log el
INNER JOIN filtered_cases fc ON el.case_id = fc.case_id
ORDER BY el.case_id, el.timestamp;
```

## Explanation

### Step-by-Step Breakdown:

| CTE | Purpose |
|-----|---------|
| `case_sequences` | Aggregates activities per case into an ordered string sequence using `STRING_AGG` with `ORDER BY timestamp` |
| `variant_counts` | Groups cases by their variant sequence, counts occurrences, and ranks variants by frequency |
| `top_k_variants` | Filters to keep only the top K most frequent variants |
| `filtered_cases` | Identifies all case_ids that follow one of the top K variants |
| **Final SELECT** | Returns all original events for cases in the top K variants |

### Key DuckDB Features Used:

1. **`STRING_AGG(activity, ' -> ' ORDER BY timestamp)`** - Concatenates activities in timestamp order with a delimiter
2. **`RANK() OVER (ORDER BY COUNT(*) DESC)`** - Ranks variants by frequency, handling ties appropriately
3. **CTEs (Common Table Expressions)** - For readable, modular query construction

## Parameterized Version (with K as variable)

```sql
-- Using a parameter for K
SET VARIABLE k_value = 5;

WITH 
case_sequences AS (
    SELECT 
        case_id,
        LIST_AGG(activity ORDER BY timestamp) AS variant_list,
        STRING_AGG(activity, ' -> ' ORDER BY timestamp) AS variant_string
    FROM event_log
    GROUP BY case_id
),

variant_counts AS (
    SELECT 
        variant_list,
        variant_string,
        COUNT(*) AS case_count
    FROM case_sequences
    GROUP BY variant_list, variant_string
    ORDER BY case_count DESC
    LIMIT getvariable('k_value')
),

filtered_cases AS (
    SELECT cs.case_id
    FROM case_sequences cs
    WHERE cs.variant_list IN (SELECT variant_list FROM variant_counts)
)

SELECT el.*
FROM event_log el
WHERE el.case_id IN (SELECT case_id FROM filtered_cases)
ORDER BY el.case_id, el.timestamp;
```

## Alternative Using LIST/ARRAY (More Robust)

```sql
WITH 
case_variants AS (
    SELECT 
        case_id,
        ARRAY_AGG(activity ORDER BY timestamp) AS variant
    FROM event_log
    GROUP BY case_id
),

top_k_variants AS (
    SELECT variant, COUNT(*) AS frequency
    FROM case_variants
    GROUP BY variant
    ORDER BY frequency DESC
    LIMIT 5  -- K value
)

SELECT e.*
FROM event_log e
WHERE e.case_id IN (
    SELECT cv.case_id
    FROM case_variants cv
    WHERE cv.variant IN (SELECT variant FROM top_k_variants)
)
ORDER BY e.case_id, e.timestamp;
```

This array-based approach is more robust as it avoids potential issues with activity names containing the delimiter string.