# DuckDB SQL Query: Top-K Process Variant Filtering

## Query

```sql
-- Set K here; replace the literal value as needed (e.g., 5, 10)
WITH

-- =========================================================
-- STEP 1: Build the ordered activity sequence for each case
-- =========================================================
case_sequences AS (
    SELECT
        case_id,
        STRING_AGG(activity, ' -> ' ORDER BY timestamp) AS variant
    FROM
        event_log
    GROUP BY
        case_id
),

-- =========================================================
-- STEP 2: Count cases per variant and rank by frequency
-- =========================================================
variant_counts AS (
    SELECT
        variant,
        COUNT(case_id)                                   AS case_count,
        RANK() OVER (ORDER BY COUNT(case_id) DESC)       AS variant_rank
    FROM
        case_sequences
    GROUP BY
        variant
),

-- =========================================================
-- STEP 3: Retain only the Top-K variants
-- =========================================================
top_k_variants AS (
    SELECT
        variant
    FROM
        variant_counts
    WHERE
        variant_rank <= 10          -- <<< replace 10 with your desired K
),

-- =========================================================
-- STEP 4: Identify every case_id that belongs to a top-K variant
-- =========================================================
top_k_cases AS (
    SELECT
        cs.case_id
    FROM
        case_sequences      cs
    INNER JOIN top_k_variants tkv
        ON cs.variant = tkv.variant
)

-- =========================================================
-- STEP 5: Return all original events for those cases
-- =========================================================
SELECT
    el.case_id,
    el.activity,
    el.timestamp
FROM
    event_log       el
INNER JOIN top_k_cases tkc
    ON el.case_id = tkc.case_id
ORDER BY
    el.case_id,
    el.timestamp;
```

---

## Step-by-Step Explanation

| CTE | Purpose |
|---|---|
| `case_sequences` | Uses `STRING_AGG( … ORDER BY timestamp)` to build a deterministic, ordered activity string per case (e.g., `"A -> B -> C"`) |
| `variant_counts` | Groups cases by their sequence string, counts how many cases share each sequence, and ranks variants by frequency |
| `top_k_variants` | Filters to variants whose rank is  K, keeping only the most frequent ones |
| `top_k_cases` | Joins back to `case_sequences` to resolve which `case_id`s belong to top-K variants |
| Final `SELECT` | Joins the original `event_log` on `case_id` to return every raw event for the qualifying cases |

---

## Key Design Decisions

```
RANK() vs ROW_NUMBER()

RANK() is intentionally used so that ties at the K-th
position are ALL included, avoiding arbitrary exclusions
when multiple variants share the same frequency.

STRING_AGG ordering

The ORDER BY timestamp inside STRING_AGG is evaluated
per-group, ensuring the sequence faithfully reflects
the temporal order of events within each case.
```

---

## Example Intermediate Results

```
case_sequences

 case_id  variant              

 1        A -> B -> C          
 2        A -> B -> C          
 3        A -> C               
 4        A -> B -> D          


variant_counts  (K = 2)

 variant       case_count  variant_rank 

 A -> B -> C       2            1          kept
 A -> C            1            2          kept
 A -> B -> D       1            2          kept (tie)

```