# DuckDB SQL Query to Filter Cases with Specific Activity Sequence and Timing

Here's a DuckDB SQL query that identifies cases with the specified activity sequence and timing condition, then excludes those cases from the final result:

```sql
WITH
-- First identify cases with the exact activity sequence
sequence_cases AS (
    SELECT
        case_id,
        MAX(CASE WHEN activity = 'Approve Purchase Requisition' THEN timestamp END) AS approve_time,
        MAX(CASE WHEN activity = 'Create Order' THEN timestamp END) AS create_time,
        MAX(CASE WHEN activity = 'Confirm Order' THEN timestamp END) AS confirm_time
    FROM event_log
    GROUP BY case_id
    HAVING
        -- Check for all three activities in the case
        COUNT(DISTINCT activity) IN (3, 4, 5) AND
        -- Check the exact sequence order
        MAX(CASE WHEN activity = 'Approve Purchase Requisition' THEN timestamp END) <
        MAX(CASE WHEN activity = 'Create Order' THEN timestamp END) AND
        MAX(CASE WHEN activity = 'Create Order' THEN timestamp END) <
        MAX(CASE WHEN activity = 'Confirm Order' THEN timestamp END)
),

-- Then filter for cases where the time between Create Order and Confirm Order is > 5 days
long_delay_cases AS (
    SELECT case_id
    FROM sequence_cases
    WHERE
        -- Calculate time difference in days
        (confirm_time - create_time) > INTERVAL '5 days'
)

-- Final result: all events except those from long_delay_cases
SELECT e.*
FROM event_log e
WHERE NOT EXISTS (
    SELECT 1
    FROM long_delay_cases l
    WHERE e.case_id = l.case_id
)
ORDER BY e.case_id, e.timestamp;
```

## Alternative Approach (More Precise Sequence Detection)

If you want to be more precise about detecting the exact sequence without other events in between, here's an alternative:

```sql
WITH
-- Find all sequences of the three activities in order with no other events in between
activity_sequences AS (
    SELECT
        e1.case_id,
        e1.timestamp AS approve_time,
        e2.timestamp AS create_time,
        e3.timestamp AS confirm_time
    FROM event_log e1
    JOIN event_log e2 ON e1.case_id = e2.case_id AND e1.timestamp < e2.timestamp
    JOIN event_log e3 ON e2.case_id = e3.case_id AND e2.timestamp < e3.timestamp
    WHERE
        e1.activity = 'Approve Purchase Requisition' AND
        e2.activity = 'Create Order' AND
        e3.activity = 'Confirm Order' AND
        -- Ensure no other events between these three
        NOT EXISTS (
            SELECT 1
            FROM event_log e4
            WHERE
                e4.case_id = e1.case_id AND
                e4.timestamp > e1.timestamp AND
                e4.timestamp < e2.timestamp
        ) AND
        NOT EXISTS (
            SELECT 1
            FROM event_log e5
            WHERE
                e5.case_id = e1.case_id AND
                e5.timestamp > e2.timestamp AND
                e5.timestamp < e3.timestamp
        )
),

-- Filter for sequences with >5 days between Create Order and Confirm Order
long_delay_sequences AS (
    SELECT case_id
    FROM activity_sequences
    WHERE (confirm_time - create_time) > INTERVAL '5 days'
)

-- Final result: all events except those from long_delay_sequences
SELECT e.*
FROM event_log e
WHERE NOT EXISTS (
    SELECT 1
    FROM long_delay_sequences l
    WHERE e.case_id = l.case_id
)
ORDER BY e.case_id, e.timestamp;
```

The second approach is more precise in ensuring the three activities appear consecutively with no other events in between, which matches your requirement of "direct succession".