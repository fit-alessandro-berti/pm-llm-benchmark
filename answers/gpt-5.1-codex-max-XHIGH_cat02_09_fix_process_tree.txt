The problematic part of your current tree is the `PARALLEL` node:

```python
parallel_block = ProcessTree(operator=Operator.PARALLEL, children=[
    create_po,
    receive_goods,
    receive_invoice,
    match_invoice,
    pay_invoice
])
```

Putting all of those activities under an `AND` allows them to interleave arbitrarily. In a standard procuretopay you do not want to be able to:

- Raise the purchase order after already receiving goods or an invoice.
- Match or pay an invoice before the invoice has been received, or before the goods have been received.
- Close a case before the financial settlement has been made.

The intended logic you listed – requisition  approval  PO  goods  invoice  match  pay  close – is a straightthrough sequence.

A corrected tree therefore replaces the parallel block with the appropriate ordering. If you want to keep the same “sequence with a block and then close” shape, the simplest fix is to make that block a `SEQUENCE`:

```python
from pm4py.objects.process_tree.obj import Operator, ProcessTree

# Define activities
create_req = ProcessTree(label="Create_Purchase_Requisition")
approve_req = ProcessTree(label="Approve_Purchase_Requisition")
create_po = ProcessTree(label="Create_Purchase_Order")
receive_goods = ProcessTree(label="Receive_Goods")
receive_invoice = ProcessTree(label="Receive_Invoice")
match_invoice = ProcessTree(label="Match_Invoice_to_PO")
pay_invoice = ProcessTree(label="Pay_Invoice")
close_case = ProcessTree(label="Close_Case")

# Corrected structure: enforce the intended order
ordered_block = ProcessTree(operator=Operator.SEQUENCE, children=[
    create_po,
    receive_goods,
    receive_invoice,
    match_invoice,
    pay_invoice
])

root = ProcessTree(operator=Operator.SEQUENCE, children=[
    create_req,
    approve_req,
    ordered_block,
    close_case
])
```

If your domain allows goods and invoice to arrive in either order, you can refine the middle part further to express that explicitly, e.g. parallel receipt of goods and invoice followed by matching and payment:

```python
receive_both = ProcessTree(operator=Operator.PARALLEL,
                           children=[receive_goods, receive_invoice])

ordered_block = ProcessTree(operator=Operator.SEQUENCE, children=[
    create_po,
    receive_both,
    match_invoice,
    pay_invoice
])
```

In both cases, the `SEQUENCE` operators force the prerequisition, approval and purchase order creation to happen up front, and they force matching and payment to happen only after the necessary inputs have been received. The `Close_Case` activity sits last in the root sequence, so it cannot occur until after payment. This eliminates the underfitting behaviour of the original model and aligns the controlflow with the domain’s expected procuretopay progression.