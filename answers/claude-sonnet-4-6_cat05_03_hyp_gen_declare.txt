# DECLARE Model Anomaly Analysis: Insurance Claims Process

---

## 1. Identified Anomalies and Contradictions

### Anomaly 1: `noncoexistence(E, C)` vs. `existence(C)` + Process Logic

The model simultaneously requires:
- **`existence(C)`** — Every claim trace *must* contain a Close (`C`) event.
- **`noncoexistence(E, C)`** — Evaluate (`E`) and Close (`C`) *cannot both appear* in the same trace.

**Contradiction:** These two rules together logically imply that **Evaluate (`E`) must never occur** in any valid trace. Since closing is mandatory, evaluation becomes forbidden — directly undermining the intended process where evaluation is a critical step before approval.

---

### Anomaly 2: `responded_existence(E  A)` vs. Effective Prohibition of `E`

The model states:
- **`responded_existence(E, activities: [A])`** — If Evaluate (`E`) occurs, then Assign (`A`) must also occur somewhere in the trace.

**Contradiction:** Since the `noncoexistence(E, C)` + `existence(C)` combination effectively prohibits `E` from occurring (as shown in Anomaly 1), this constraint becomes **vacuously satisfied and meaningless**. It implies that assignments are only required when evaluations happen — but evaluations can never happen. This means claims can be closed without anyone ever being assigned or evaluating them.

---

### Anomaly 3: `precedence(C, activities: [R])` — Insufficient Ordering Constraint

The model states:
- **`precedence(C, activities: [R])`** — Close (`C`) can only occur if Receive (`R`) preceded it.

**Gap:** While technically sound, this constraint is dangerously minimal. It permits a trace such as:

```
R  C
```

...completely bypassing Assign, Evaluate, Approve, and Notify. Combined with the prohibition on `E` derived from Anomaly 1, this means a claim can be **received and immediately closed** with full model compliance.

---

### Anomaly 4: Missing Constraints for Core Process Steps

The model has no constraints enforcing:
- That **Approve (`P`)** must occur before Close (`C`)
- That **Notify (`N`)** must occur before Close (`C`)
- That **Assign (`A`)** must precede **Evaluate (`E`)**
- That `R  A  E  P  N  C` ordering is preserved

This omission, combined with the active contradictions above, means the model structurally permits severely truncated — and fraudulent or negligent — claim lifecycles.

---

## 2. Hypotheses for Why These Anomalies Exist

### Hypothesis 1: Misinterpretation of Mutual Exclusivity
A modeler may have confused "Evaluation and Closing should not happen *simultaneously*" (a timing constraint) with "Evaluation and Closing should not *both exist in a trace*." The intent may have been to prevent concurrent processing, but the `noncoexistence` constraint was applied instead of a `nonsuccession` or temporal ordering constraint.

### Hypothesis 2: Policy Change Without Full Model Revision
An older version of the process may have included a fast-track closure path that bypassed evaluation (e.g., for low-value or duplicate claims). A new policy requiring evaluation for all claims was added via `responded_existence`, but the old `noncoexistence` constraint was never removed, creating a direct contradiction.

### Hypothesis 3: Pressure to Reduce Processing Time
Operational or business pressure to close claims quickly may have led to constraints being relaxed or "accidentally" omitted. The sparse `precedence` constraint and absence of approval/notification ordering may reflect an implicit desire to allow shortcuts, even if that was never formally approved.

### Hypothesis 4: Automated Mining on Incomplete or Biased Data
If the DECLARE model was mined from historical event logs, and those logs contained a significant proportion of abnormal cases (e.g., fraudulent claims closed immediately, or system errors that skipped steps), the mining algorithm may have incorrectly generalized those exceptions into universal constraints — including the destructive `noncoexistence(E, C)` rule.

### Hypothesis 5: Constraint Fragmentation Across Teams
Different teams (e.g., compliance, operations, IT) may have contributed constraints independently without cross-validation. The `existence(C)` rule may come from a compliance mandate, while `noncoexistence(E, C)` may have been added by a technical team modeling a different subprocess, resulting in rules that were never reconciled.

---

## 3. SQL-Based Verification Strategies

### Query 1: Claims Closed Without Any Evaluation
Detects traces where `C` occurred but `E` never did — the path enabled by the anomalous constraints.

```sql
SELECT 
    c.claim_id,
    c.customer_id,
    c.claim_type,
    c.claim_amount,
    c.submission_date
FROM claims c
WHERE EXISTS (
    SELECT 1 
    FROM claim_events ce 
    WHERE ce.claim_id = c.claim_id 
      AND ce.activity = 'C'
)
AND NOT EXISTS (
    SELECT 1 
    FROM claim_events ce 
    WHERE ce.claim_id = c.claim_id 
      AND ce.activity = 'E'
);
```

---

### Query 2: Claims Where Evaluation and Closing Both Occur
Directly tests whether the `noncoexistence(E, C)` constraint is violated in practice — and whether real data contradicts the model.

```sql
SELECT 
    c.claim_id,
    c.claim_type,
    c.claim_amount,
    MIN(CASE WHEN ce.activity = 'E' THEN ce.timestamp END) AS eval_time,
    MIN(CASE WHEN ce.activity = 'C' THEN ce.timestamp END) AS close_time
FROM claims c
JOIN claim_events ce ON c.claim_id = ce.claim_id
WHERE ce.activity IN ('E', 'C')
GROUP BY c.claim_id, c.claim_type, c.claim_amount
HAVING 
    COUNT(CASE WHEN ce.activity = 'E' THEN 1 END) > 0
    AND COUNT(CASE WHEN ce.activity = 'C' THEN 1 END) > 0;
```

---

### Query 3: Claims Closed Without Assignment or Approval
Identifies claims that skipped multiple mandatory steps, highlighting the practical impact of missing precedence constraints.

```sql
SELECT 
    c.claim_id,
    c.customer_id,
    c.claim_type,
    c.submission_date,
    BOOL_OR(ce.activity = 'A') AS was_assigned,
    BOOL_OR(ce.activity = 'E') AS was_evaluated,
    BOOL_OR(ce.activity = 'P') AS was_approved,
    BOOL_OR(ce.activity = 'N') AS customer_notified,
    BOOL_OR(ce.activity = 'C') AS was_closed
FROM claims c
JOIN claim_events ce ON c.claim_id = ce.claim_id
GROUP BY c.claim_id, c.customer_id, c.claim_type, c.submission_date
HAVING 
    BOOL_OR(ce.activity = 'C') = TRUE
    AND (
        BOOL_OR(ce.activity = 'A') = FALSE
        OR BOOL_OR(ce.activity = 'E') = FALSE
        OR BOOL_OR(ce.activity = 'P') = FALSE
        OR BOOL_OR(ce.activity = 'N') = FALSE
    )
ORDER BY c.submission_date DESC;
```

---

### Query 4: Evaluation Steps Without a Preceding Assignment
Verifies whether the `responded_existence(E  A)` constraint reflects reality, and specifically whether evaluations happen without any adjuster being assigned.

```sql
SELECT 
    ce_eval.claim_id,
    ce_eval.timestamp        AS evaluation_time,
    ce_eval.resource         AS evaluator,
    ce_assign.timestamp      AS assignment_time,
    ce_assign.resource       AS assigned_adjuster
FROM claim_events ce_eval
LEFT JOIN claim_events ce_assign 
    ON ce_eval.claim_id = ce_assign.claim_id
    AND ce_assign.activity = 'A'
    AND ce_assign.timestamp < ce_eval.timestamp
WHERE ce_eval.activity = 'E'
  AND ce_assign.event_id IS NULL
ORDER BY ce_eval.timestamp DESC;
```

---

### Query 5: Process Ordering Violations (Activity Sequence Audit)
Checks for cases where the overall sequence of activities deviates from the intended `R  A  E  P  N  C` order.

```sql
WITH activity_order AS (
    SELECT 
        claim_id,
        activity,
        timestamp,
        ROW_NUMBER() OVER (PARTITION BY claim_id ORDER BY timestamp) AS step_seq
    FROM claim_events
    WHERE activity IN ('R', 'A', 'E', 'P', 'N', 'C')
),
pivoted AS (
    SELECT
        claim_id,
        MAX(CASE WHEN activity = 'R' THEN step_seq END) AS step_R,
        MAX(CASE WHEN activity = 'A' THEN step_seq END) AS step_A,
        MAX(CASE WHEN activity = 'E' THEN step_seq END) AS step_E,
        MAX(CASE WHEN activity = 'P' THEN step_seq END) AS step_P,
        MAX(CASE WHEN activity = 'N' THEN step_seq END) AS step_N,
        MAX(CASE WHEN activity = 'C' THEN step_seq END) AS step_C
    FROM activity_order
    GROUP BY claim_id
)
SELECT 
    claim_id,
    step_R, step_A, step_E, step_P, step_N, step_C,
    CASE 
        WHEN step_R IS NULL THEN 'Missing: Receive'
        WHEN step_A IS NULL THEN 'Missing: Assign'
        WHEN step_E IS NULL THEN 'Missing: Evaluate'
        WHEN step_P IS NULL THEN 'Missing: Approve'
        WHEN step_N IS NULL THEN 'Missing: Notify'
        WHEN step_C IS NULL THEN 'Missing: Close'
        WHEN NOT (step_R < step_A AND step_A < step_E 
               AND step_E < step_P AND step_P < step_N 
               AND step_N < step_C)
             THEN 'Out-of-order sequence'
        ELSE 'Compliant'
    END AS compliance_status
FROM pivoted
WHERE 
    step_A IS NULL OR step_E IS NULL OR step_P IS NULL 
    OR step_N IS NULL
    OR NOT (step_R < step_A AND step_A < step_E 
            AND step_E < step_P AND step_P < step_N 
            AND step_N < step_C)
ORDER BY claim_id;
```

---

### Query 6: Adjuster Specialization Mismatch
Verifies whether adjusters are being assigned to claim types outside their specialization — a data quality issue that could contribute to anomalous model mining.

```sql
SELECT 
    c.claim_id,
    c.claim_type,
    ce.resource              AS assigned_adjuster_name,
    a.specialization         AS adjuster_specialization,
    a.region
FROM claims c
JOIN claim_events ce 
    ON c.claim_id = ce.claim_id 
    AND ce.activity = 'A'
JOIN adjusters a 
    ON a.name = ce.resource
WHERE 
    (c.claim_type = 'home_insurance' AND a.specialization != 'home')
    OR (c.claim_type = 'auto_insurance' AND a.specialization != 'auto')
ORDER BY c.claim_id;
```

---

## Summary Table

| Anomaly | Constraint(s) Involved | Business Impact | Verification Query |
|---|---|---|---|
| E effectively prohibited | `noncoexistence(E,C)` + `existence(C)` | Claims never evaluated | Query 1, 2 |
| Vacuous assignment rule | `responded_existence(EA)` + above | Assignments skipped freely | Query 4 |
| Minimal ordering enforcement | `precedence(CR)` only | RC shortcut allowed | Query 3, 5 |
| Missing P/N/A ordering | No constraints defined | Approval/notification skipped | Query 3, 5 |
| Specialization mismatches | (data quality) | Biased model mining | Query 6 |