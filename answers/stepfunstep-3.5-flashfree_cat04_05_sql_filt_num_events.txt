<think>
We are given a table `event_log` with columns `case_id`, `activity`, `timestamp`.
 We want to filter out cases that have more than six events. So we want to keep cases with 6 or fewer events.
 Steps:
 1. Count the number of events per `case_id`.
 2. Filter the `case_id`s that have count <= 6.
 3. Then, return all events from the table for those `case_id`s.

 We can do this by either:
   a) Using a subquery or CTE to get the list of valid `case_id`s and then join or filter the original table.
   b) Using a window function to count per `case_id` and then filter.

 Let me write both for clarity, but the prompt asks for one query. I'll choose the window function approach because it can be done in one pass.

 However, note: the window function approach might be less efficient in some databases because it computes the count for every row, but in DuckDB it should be fine.

 Alternatively, we can do:

 WITH case_counts AS (
   SELECT case_id
   FROM event_log
   GROUP BY case_id
   HAVING COUNT(*) <= 6
 )
 SELECT e.*
 FROM event_log e
 JOIN case_counts c ON e.case_id = c.case_id;

 But let me write the window function version:

 SELECT *
 FROM (
   SELECT e.*, COUNT(*) OVER (PARTITION BY case_id) as case_event_count
   FROM event_log e
 ) sub
 WHERE case_event_count <= 6;

 However, note that the window function version will compute the count for every row and then filter. The first method (with CTE and join) might be more efficient because it aggregates first and then joins.

 But the prompt doesn't specify which one to use. I think both are acceptable.

 Let me adjust: the window function version might be simpler in terms of one scan, but note that the window function is computed for every row and then we filter. The CTE version does two scans: one for aggregation and one for the join.

 However, in DuckDB, the optimizer might handle both similarly.

 Since the prompt says "craft a DuckDB SQL query", I'll provide the window function version because it's concise and clear.

 But note: the window function version will return the same events, but also includes an extra column `case_event_count`? The prompt says "returns only the events", so we should not include that extra column.

 We can do:

 SELECT case_id, activity, timestamp
 FROM (
   SELECT e.*, COUNT(*) OVER (PARTITION BY case_id) as case_event_count
   FROM event_log e
 ) sub
 WHERE case_event_count <= 6;

 But the original table might have more columns? The prompt says "at least" the three columns, so we want to return all columns of the original table? The prompt says "returns only the events from cases that have six or fewer events". So we want the original columns.

 We can do:

 SELECT *
 FROM (
   SELECT e.*, COUNT(*) OVER (PARTITION BY case_id) as case_event_count
   FROM event_log e
 ) sub
 WHERE case_event_count <= 6
   AND then we have the extra column. We don't want that.

 We can either list the original columns or use a subquery to remove it.

 Alternatively, we can do:

 SELECT e.*
 FROM event_log e
 WHERE e.case_id IN (
   SELECT case_id
   FROM event_log
   GROUP BY case_id
   HAVING COUNT(*) <= 6
 );

 This is the IN version, which is similar to the CTE join.

 Let me stick to the window function but without the extra column in the output:

 We can do:

 SELECT case_id, activity, timestamp   -- but if there are more columns, we have to list them? 
   -- Alternatively, we can use a NATURAL JOIN? No.

 Alternatively, we can use a common table expression and then join:

 WITH valid_cases AS (
   SELECT case_id
   FROM event_log
   GROUP BY case_id
   HAVING COUNT(*) <= 6
 )
 SELECT e.*
 FROM event_log e
 INNER JOIN valid_cases v ON e.case_id = v.case_id;

 This returns exactly the columns of `event_log` and only the rows for valid cases.

 Since the prompt says "returns only the events", and we don't know the exact columns, I think it's safe to assume we want all columns of `event_log`.

 I'll choose the CTE with join because it's standard and clear.

 However, note: the window function version can be written without the extra column by using a subquery that selects only the original columns and then filters by the window function in the outer query? But then we cannot use the window function in the WHERE clause of the same level.

 So:

 Option 1 (CTE and join):

 WITH case_counts AS (
   SELECT case_id
   FROM event_log
   GROUP BY case_id
   HAVING COUNT(*) <= 6
 )
 SELECT event_log.*
 FROM event_log
 JOIN case_counts USING (case_id);

 Option 2 (window function with subquery and then drop the extra column):

 SELECT case_id, activity, timestamp   -- but we don't know all columns
   -- We can do: SELECT * EXCEPT (case_event_count) but that's not standard SQL.

 DuckDB does support SELECT * EXCEPT (column) but let's not rely on that if we don't know the columns.

 Actually, the prompt says the table has at least `case_id`, `activity`, `timestamp`. There might be more. So we should return all columns.

 Therefore, the CTE and join is safe because we do `event_log.*` and we join on `case_id`.

 Alternatively, we can use the window function and then in the outer query select only the columns of the original table. But we don't know the exact column names.

 So, let's stick with:

 WITH valid_cases AS (
   SELECT case_id
   FROM event_log
   GROUP BY case_id
   HAVING COUNT(*) <= 6
 )
 SELECT e.*
 FROM event_log e
 JOIN valid_cases v ON e.case_id = v.case_id;

 This will work.

 Another way without CTE:

 SELECT e.*
 FROM event_log e
 WHERE e.case_id IN (
   SELECT case_id
   FROM event_log
   GROUP BY case_id
   HAVING COUNT(*) <= 6
 );

 This is also good.

 I'll choose the IN version because it's a single correlated subquery? Actually, it's not correlated. The subquery is independent.

 But note: the IN version might be less efficient than the join in some databases, but in DuckDB it might be optimized.

 Since the prompt doesn't specify performance, I'll write the IN version for simplicity.

 However, let me write the query as:

 SELECT *
 FROM event_log
 WHERE case_id IN (
   SELECT case_id
   FROM event_log
   GROUP BY case_id
   HAVING COUNT(*) <= 6
 );

 This is clear and concise.

 But note: the subquery in the IN clause returns a list of case_ids that have 6 or fewer events. Then we select all rows from event_log that have a case_id in that list.

 This should be correct.

 Let me test with a simple example:

 Suppose event_log:
 case_id | activity | timestamp
   A     |   act1   |  t1
   A     |   act2   |  t2
   B     |   act1   |  t3
   B     |   act2   |  t4
   B     |   act3   |  t5
   C     |   act1   |  t6   -> C has 1 event
   D     |   act1   |  t7
   D     |   act2   |  t8
   D     |   act3   |  t9
   D     |   act4   |  t10
   D     |   act5   |  t11
   D     |   act6   |  t12   -> D has 6 events
   E     |   act1   |  t13
   E     |   act2   |  t14
   E     |   act3   |  t15   -> E has 3 events
   F     |   act1   |  t16
   F     |   act2   |  t17
   F     |   act3   |  t18
   F     |   act4   |  t19   -> F has 4 events
   G     |   act1   |  t20
   G     |   act2   |  t21
   G     |   act3   |  t22
   G     |   act4   |  t23
   G     |   act5   |  t24
   G     |   act6   |  t25
   G     |   act7   |  t26   -> G has 7 events, so exclude.

 The query should return events for A, B, C, D, E, F.

 The subquery returns: A (2), B (3), C (1), D (6), E (3), F (4). G is excluded.

 So the IN version works.

 However, note: if there are many case_ids, the IN list might be long. But that's okay.

 Alternatively, we can use EXISTS:

 SELECT *
 FROM event_log e
 WHERE EXISTS (
   SELECT 1
   FROM event_log e2
   WHERE e2.case_id = e.case_id
   GROUP BY e2.case_id
   HAVING COUNT(*) <= 6
 );

 But this is correlated and might be less efficient.

 So, I'll stick with the IN version.

 But note: the IN version does the aggregation once and then uses the list. The EXISTS version does the aggregation for each row? Not necessarily, the optimizer might rewrite it.

 However, I think the IN version is more straightforward.

 Let me write the final query:

 SELECT *
 FROM event_log
 WHERE case_id IN (
   SELECT case_id
   FROM event_log
   GROUP BY case_id
   HAVING COUNT(*) <= 6
 );

 That's it.

 However, note: the prompt says "more than six events", so we want to exclude those with >6, meaning we keep <=6.

 We are doing HAVING COUNT(*) <= 6, which is correct.

 But wait: the prompt says "filters out any cases containing more than six events", so we remove cases with >6. We are keeping <=6. Correct.

 Let me adjust: if a case has exactly 6 events, we keep it. That's what the prompt says: "six or fewer".

 So, the query is:

 SELECT *
 FROM event_log
 WHERE case_id IN (
   SELECT case_id
   FROM event_log
   GROUP BY case_id
   HAVING COUNT(*) <= 6
 );

 I think this is the simplest and most readable.

 However, note: if the table is very large, the subquery might be expensive. But that's the nature of the problem.

 We can also do:

 SELECT e.*
 FROM event_log e
 JOIN (
   SELECT case_id
   FROM event_log
   GROUP BY case_id
   HAVING COUNT(*) <= 6
 ) valid ON e.case_id = valid.case_id;

 This is equivalent and might be more efficient because it's a join. But in DuckDB, the optimizer might treat them the same.

 I'll present the IN version as it's a single block and easy to understand.

 But the prompt says "craft a DuckDB SQL query", so either is acceptable.

 I'll write the IN version.

 However, let me check: in the IN version, the subquery is not correlated and returns a set of case_ids. Then we filter the outer table by that set.

 That should work.

 Final answer:
</think>
Here's a DuckDB SQL query that achieves the specified filtering:

```sql
SELECT *
FROM event_log
WHERE case_id IN (
    SELECT case_id
    FROM event_log
    GROUP BY case_id
    HAVING COUNT(*) <= 6
);
```

**Alternative approach using a window function (also valid):**
```sql
SELECT *
FROM (
    SELECT *, COUNT(*) OVER (PARTITION BY case_id) as case_event_count
    FROM event_log
) subquery
WHERE case_event_count <= 6;
```

**Key explanation:**

1. **Inner Subquery**: `SELECT case_id FROM event_log GROUP BY case_id HAVING COUNT(*) <= 6`
   - Groups events by `case_id`
   - Counts events per case
   - Filters to keep only cases with 6 or fewer events using `HAVING COUNT(*) <= 6`

2. **Outer Query**: `SELECT * FROM event_log WHERE case_id IN (...)`
   - Returns all columns (`*`) from the original `event_log` table
   - Filters rows to include only those whose `case_id` appears in the list of valid cases from the subquery

**Why this works correctly:**
- The `GROUP BY` + `HAVING` correctly counts events per case before filtering
- The `IN` clause efficiently matches all events from qualifying cases
- Returns the complete set of events (all columns) for cases meeting the criteria
- Handles cases with exactly 6 events (inclusive) while excluding cases with 7+ events

Both approaches are valid in DuckDB. The first (using `IN` with a grouped subquery) is typically more readable and often performs well for this pattern. The window function approach may be preferable if you need the event counts in the result for other purposes.