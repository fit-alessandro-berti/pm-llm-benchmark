```sql
WITH ordered AS (
    SELECT
        case_id,
        activity,
        "timestamp",
        ROW_NUMBER() OVER (
            PARTITION BY case_id
            ORDER BY "timestamp", activity, rowid
        ) AS rn
    FROM event_log
),

triples AS (
    SELECT
        o1.case_id,
        o1.rn                       AS rn_approve,
        o2."timestamp"              AS ts_create,
        o3."timestamp"              AS ts_confirm,
        DATE_DIFF('day', o2."timestamp", o3."timestamp") AS diff_days
    FROM ordered o1
    JOIN ordered o2
        ON o1.case_id = o2.case_id AND o2.rn = o1.rn + 1
    JOIN ordered o3
        ON o1.case_id = o3.case_id AND o3.rn = o1.rn + 2
    WHERE
        o1.activity = 'Approve Purchase Requisition'
        AND o2.activity = 'Create Order'
        AND o3.activity = 'Confirm Order'
),

bad_cases AS (
    SELECT DISTINCT case_id
    FROM triples
    WHERE diff_days > 5
)

SELECT e.*
FROM event_log e
LEFT JOIN bad_cases b
    ON e.case_id = b.case_id
WHERE b.case_id IS NULL
ORDER BY e.case_id, e."timestamp";
```

Explanation of key points (brief):

- `ordered` assigns a per-case sequence number (`rn`) to each event based on time, making “direct succession” checkable via `rn`, `rn+1`, `rn+2`.
- `triples` picks triples of events with those consecutive `rn` values and filters to the specific activity order.
- `bad_cases` keeps only cases where the time between `'Create Order'` and `'Confirm Order'` in that triple is more than 5 days.
- Final query returns all events except those whose `case_id` is in `bad_cases`.