This solution uses Common Table Expressions (CTEs) to first rank the events within each case, identify the exact sequential pattern, filter those sequences by the time constraint, and finally exclude all events belonging to the identified "bad" cases.

```sql
WITH RankedEvents AS (
    -- Step 1a: Assign a sequence number (rn) to every event within its case, ordered by time.
    -- This is crucial for enforcing strict, direct succession later.
    SELECT
        case_id,
        activity,
        timestamp,
        ROW_NUMBER() OVER (PARTITION BY case_id ORDER BY timestamp) as rn
    FROM event_log
),
SequentialCandidates AS (
    -- Step 1b: Identify cases where the required sequence occurs consecutively (rn, rn+1, rn+2).
    SELECT DISTINCT
        T1.case_id,
        T1.timestamp AS ts_approve,
        T2.timestamp AS ts_create,
        T3.timestamp AS ts_confirm
    FROM RankedEvents AS T1
    JOIN RankedEvents AS T2
        ON T1.case_id = T2.case_id
        AND T2.rn = T1.rn + 1 -- Ensure T2 is the immediate next event
    JOIN RankedEvents AS T3
        ON T1.case_id = T3.case_id
        AND T3.rn = T2.rn + 1 -- Ensure T3 is the immediate next event after T2
    WHERE
        T1.activity = 'Approve Purchase Requisition'
        AND T2.activity = 'Create Order'
        AND T3.activity = 'Confirm Order'
),
BadCases AS (
    -- Step 2: Among the identified sequences, find cases where the time gap between
    -- 'Create Order' (ts_create) and 'Confirm Order' (ts_confirm) is > 5 days.
    SELECT DISTINCT
        case_id
    FROM SequentialCandidates
    WHERE
        -- Calculate the difference in days. Since ts_confirm must logically follow ts_create,
        -- DATE_DIFF will yield a positive integer if the gap is large enough.
        DATE_DIFF('day', ts_create, ts_confirm) > 5
)
-- Step 3: Return all events from cases that are NOT present in the BadCases CTE.
SELECT
    e.*
FROM event_log AS e
WHERE
    e.case_id NOT IN (SELECT case_id FROM BadCases)
ORDER BY
    e.case_id,
    e.timestamp;
```