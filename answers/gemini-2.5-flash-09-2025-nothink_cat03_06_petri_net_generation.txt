The following Python code constructs the accepting Petri net for the insurance claim management scenario.

The Petri net includes places to model the states between activities and transitions for each activity, including the conditional loops for re-document submission and in-depth investigation.

```python
from pm4py.objects.petri_net.obj import PetriNet, Marking
from pm4py.objects.petri_net.utils import petri_utils

# 1. Create the Petri Net object
net = PetriNet(name="Insurance Claim Process")

# 2. Define Places (representing states)
# Start/End places
p_start = PetriNet.Place(name="start")
p_end = PetriNet.Place(name="end")

# States between activities
p_registered = PetriNet.Place(name="p_registered")
p_doc_verified = PetriNet.Place(name="p_doc_verified")
p_fraud_checked = PetriNet.Place(name="p_fraud_checked")
p_assessed = PetriNet.Place(name="p_assessed")
p_approved = PetriNet.Place(name="p_approved")
p_paid = PetriNet.Place(name="p_paid")
p_notified = PetriNet.Place(name="p_notified")

# Places for conditional/loop structures
p_needs_resubmit = PetriNet.Place(name="p_needs_resubmit") # State after DV fails, before RDS
p_needs_investigation = PetriNet.Place(name="p_needs_investigation") # State after FC fails, before II

# Add all places to the net
places = {
    p_start, p_end, p_registered, p_doc_verified, p_fraud_checked, 
    p_assessed, p_approved, p_paid, p_notified,
    p_needs_resubmit, p_needs_investigation
}
for p in places:
    net.places.add(p)

# 3. Define Transitions (labeled with activities)
t_CR = PetriNet.Transition(name="t_CR", label="Claim Registration (CR)")
t_DV = PetriNet.Transition(name="t_DV", label="Document Verification (DV)")
t_RDS = PetriNet.Transition(name="t_RDS", label="Re-Document Submission (RDS)")
t_FC = PetriNet.Transition(name="t_FC", label="Fraud Check (FC)")
t_II = PetriNet.Transition(name="t_II", label="In-depth Investigation (II)")
t_CA = PetriNet.Transition(name="t_CA", label="Claim Assessment (CA)")
t_AP = PetriNet.Transition(name="t_AP", label="Approval (AP)")
t_P = PetriNet.Transition(name="t_P", label="Payment (P)")
t_N = PetriNet.Transition(name="t_N", label="Notification (N)")
t_CL = PetriNet.Transition(name="t_CL", label="Closure (CL)")

# Transitions representing conditional splits (silent transitions for flow control)
# Document Verification Split
t_DV_OK = PetriNet.Transition(name="t_DV_OK", label=None)
t_DV_FAIL = PetriNet.Transition(name="t_DV_FAIL", label=None)

# Fraud Check Split
t_FC_OK = PetriNet.Transition(name="t_FC_OK", label=None)
t_FC_FAIL = PetriNet.Transition(name="t_FC_FAIL", label=None)

# Add all transitions to the net
transitions = {
    t_CR, t_DV, t_RDS, t_FC, t_II, t_CA, t_AP, t_P, t_N, t_CL,
    t_DV_OK, t_DV_FAIL, t_FC_OK, t_FC_FAIL
}
for t in transitions:
    net.transitions.add(t)

# 4. Define Arcs (connecting places and transitions)

# C -> CR -> p_registered
petri_utils.add_arc_from_to(p_start, t_CR, net)
petri_utils.add_arc_from_to(t_CR, p_registered, net)

# p_registered -> DV
petri_utils.add_arc_from_to(p_registered, t_DV, net)

# DV -> Split (DV_OK or DV_FAIL)
petri_utils.add_arc_from_to(t_DV, t_DV_OK, net)
petri_utils.add_arc_from_to(t_DV, t_DV_FAIL, net)

# DV_OK (to Fraud Check)
petri_utils.add_arc_from_to(t_DV_OK, p_doc_verified, net)

# DV_FAIL (to Re-Document Submission loop)
petri_utils.add_arc_from_to(t_DV_FAIL, p_needs_resubmit, net)
petri_utils.add_arc_from_to(p_needs_resubmit, t_RDS, net)
petri_utils.add_arc_from_to(t_RDS, p_registered, net) # RDS sends it back to be registered/ready for DV again

# p_doc_verified -> FC
petri_utils.add_arc_from_to(p_doc_verified, t_FC, net)

# FC -> Split (FC_OK or FC_FAIL)
petri_utils.add_arc_from_to(t_FC, t_FC_OK, net)
petri_utils.add_arc_from_to(t_FC, t_FC_FAIL, net)

# FC_OK (to Claim Assessment)
petri_utils.add_arc_from_to(t_FC_OK, p_fraud_checked, net)

# FC_FAIL (to In-depth Investigation loop)
petri_utils.add_arc_from_to(t_FC_FAIL, p_needs_investigation, net)
petri_utils.add_arc_from_to(p_needs_investigation, t_II, net)
petri_utils.add_arc_from_to(t_II, p_doc_verified, net) # II results in verification state (ready for FC again)

# p_fraud_checked -> CA -> p_assessed
petri_utils.add_arc_from_to(p_fraud_checked, t_CA, net)
petri_utils.add_arc_from_to(t_CA, p_assessed, net)

# p_assessed -> AP -> p_approved
petri_utils.add_arc_from_to(p_assessed, t_AP, net)
petri_utils.add_arc_from_to(t_AP, p_approved, net)

# p_approved -> P -> p_paid
petri_utils.add_arc_from_to(p_approved, t_P, net)
petri_utils.add_arc_from_to(t_P, p_paid, net)

# p_paid -> N -> p_notified
petri_utils.add_arc_from_to(p_paid, t_N, net)
petri_utils.add_arc_from_to(t_N, p_notified, net)

# p_notified -> CL -> p_end
petri_utils.add_arc_from_to(p_notified, t_CL, net)
petri_utils.add_arc_from_to(t_CL, p_end, net)

# 5. Define Initial and Final Markings

# Initial Marking (im): One token in the 'start' place, representing a new claim (C)
im = Marking()
im[p_start] = 1

# Final Marking (fm): One token in the 'end' place, representing a closed and archived claim (CL)
fm = Marking()
fm[p_end] = 1

# Output the result
print("--- Accepting Petri Net Construction Complete ---")
print(f"Net Name: {net.name}")
print(f"Number of Places: {len(net.places)}")
print(f"Number of Transitions: {len(net.transitions)} (including silent transitions)")
print("\nInitial Marking (im):")
print({p.name: count for p, count in im.items()})
print("\nFinal Marking (fm):")
print({p.name: count for p, count in fm.items()})

# Optional: Print transitions with labels
print("\nActivities/Transitions:")
for t in net.transitions:
    print(f"  {t.name}: '{t.label if t.label is not None else 'SILENT'}'")
```