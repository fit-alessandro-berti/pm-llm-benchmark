# DuckDB SQL Query Solution

Here's a comprehensive solution to identify and exclude cases with the specified sequence and timing condition:

## Primary Solution (Using LEAD Window Function)

```sql
WITH ordered_events AS (
    -- For each event, look ahead to get the next two activities and timestamps
    SELECT 
        case_id,
        activity,
        timestamp,
        LEAD(activity, 1) OVER (PARTITION BY case_id ORDER BY timestamp) AS next_activity,
        LEAD(activity, 2) OVER (PARTITION BY case_id ORDER BY timestamp) AS next_next_activity,
        LEAD(timestamp, 1) OVER (PARTITION BY case_id ORDER BY timestamp) AS next_timestamp,
        LEAD(timestamp, 2) OVER (PARTITION BY case_id ORDER BY timestamp) AS next_next_timestamp
    FROM event_log
),
cases_to_exclude AS (
    -- Identify cases matching the sequence pattern AND timing condition
    SELECT DISTINCT
        case_id
    FROM ordered_events
    WHERE 
        activity = 'Approve Purchase Requisition'
        AND next_activity = 'Create Order'
        AND next_next_activity = 'Confirm Order'
        AND (next_next_timestamp - next_timestamp) > INTERVAL '5 days'
)
-- Return all events EXCEPT those from the excluded cases
SELECT 
    el.*
FROM event_log el
WHERE el.case_id NOT IN (SELECT case_id FROM cases_to_exclude)
ORDER BY el.case_id, el.timestamp;
```

## Alternative Solution (Using ROW_NUMBER and Self-Joins)

```sql
WITH numbered_events AS (
    -- Assign sequential row numbers to events within each case
    SELECT 
        case_id,
        activity,
        timestamp,
        ROW_NUMBER() OVER (PARTITION BY case_id ORDER BY timestamp) AS rn
    FROM event_log
),
cases_to_exclude AS (
    -- Find three consecutive events matching the pattern
    SELECT DISTINCT
        e1.case_id
    FROM numbered_events e1
    JOIN numbered_events e2 
        ON e1.case_id = e2.case_id 
        AND e1.rn + 1 = e2.rn
    JOIN numbered_events e3 
        ON e2.case_id = e3.case_id 
        AND e2.rn + 1 = e3.rn
    WHERE 
        e1.activity = 'Approve Purchase Requisition'
        AND e2.activity = 'Create Order'
        AND e3.activity = 'Confirm Order'
        AND (e3.timestamp - e2.timestamp) > INTERVAL '5 days'
)
SELECT 
    el.*
FROM event_log el
WHERE el.case_id NOT IN (SELECT case_id FROM cases_to_exclude)
ORDER BY el.case_id, el.timestamp;
```

## Alternative Timing Condition

If you prefer using `date_diff` function instead of interval arithmetic:

```sql
-- Replace the timing condition with:
AND date_diff('day', next_timestamp, next_next_timestamp) > 5
```

**Note:** Using `INTERVAL '5 days'` is more precise for timestamp comparisons as it considers the full datetime, while `date_diff('day', ...)` only counts calendar day boundaries.

## Query Explanation

1. **ordered_events CTE**: Uses `LEAD()` window function to peek ahead at the next two activities and their timestamps for each event within a case.

2. **cases_to_exclude CTE**: Identifies cases where:
   - Three specific activities occur in direct succession (no intervening events)
   - The time between 'Create Order' and 'Confirm Order' exceeds 5 days

3. **Final SELECT**: Returns all events from the original table except those belonging to the excluded cases, properly ordered by case and timestamp.

The solution handles edge cases gracefully:
- Cases with multiple matching sequences (DISTINCT ensures each case is counted once)
- Cases with fewer than 3 events (LEAD returns NULL, condition fails)
- Multiple occurrences of the sequence in the same case