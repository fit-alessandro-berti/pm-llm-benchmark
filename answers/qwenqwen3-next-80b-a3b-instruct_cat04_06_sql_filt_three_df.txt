To solve this problem, we need to:

1. **Identify cases** that contain the exact sequence:  
   `'Approve Purchase Requisition'`  `'Create Order'`  `'Confirm Order'`  
   in **direct succession** (i.e., no other activity in between).

2. Among those cases, **filter only those** where the time between `'Create Order'` and `'Confirm Order'` is **more than 5 days**.

3. **Exclude all events** from those filtered cases — meaning return **all events** from **all other cases**.

---

### Strategy:

- Use **window functions** to look at the next two events within each case, ordered by timestamp.
- Identify sequences where:
  - Current activity = `'Approve Purchase Requisition'`
  - Next activity = `'Create Order'`
  - Next next activity = `'Confirm Order'`
- Compute the time difference between the `'Create Order'` and `'Confirm Order'` events (i.e., between row 2 and row 3 of the sequence).
- Collect all `case_id`s that satisfy **both** the sequence and the >5-day condition.
- Finally, return all events from `event_log` **except** those whose `case_id` is in the above set.

---

### DuckDB SQL Query:

```sql
WITH sequence_candidates AS (
    SELECT 
        case_id,
        activity,
        timestamp,
        LEAD(activity, 1) OVER (PARTITION BY case_id ORDER BY timestamp) AS next_activity,
        LEAD(activity, 2) OVER (PARTITION BY case_id ORDER BY timestamp) AS next_next_activity,
        LEAD(timestamp, 1) OVER (PARTITION BY case_id ORDER BY timestamp) AS next_timestamp,
        LEAD(timestamp, 2) OVER (PARTITION BY case_id ORDER BY timestamp) AS next_next_timestamp
    FROM event_log
),
bad_cases AS (
    SELECT DISTINCT case_id
    FROM sequence_candidates
    WHERE 
        activity = 'Approve Purchase Requisition'
        AND next_activity = 'Create Order'
        AND next_next_activity = 'Confirm Order'
        AND julianday(next_next_timestamp) - julianday(next_timestamp) > 5
)
SELECT *
FROM event_log
WHERE case_id NOT IN (SELECT case_id FROM bad_cases)
ORDER BY case_id, timestamp;
```

---

### Explanation:

- **`sequence_candidates` CTE**:  
  Uses `LEAD()` to peek at the next two activities and their timestamps for each event, within each `case_id` (grouped and ordered by `timestamp`).

- **`bad_cases` CTE**:  
  Filters for the exact 3-step sequence and computes the time difference between `'Create Order'` (`next_timestamp`) and `'Confirm Order'` (`next_next_timestamp`) using `julianday()` — DuckDB’s function to convert datetime to Julian day number (a float), so subtracting gives days as a decimal.

  - `julianday(next_next_timestamp) - julianday(next_timestamp) > 5`  more than 5 days.

- **Final SELECT**:  
  Returns all events from `event_log` **except** those whose `case_id` is in `bad_cases`.

- **`ORDER BY case_id, timestamp`**:  
  Ensures output is logically ordered by case and chronological time.

---

### Notes:

- `julianday()` is the correct DuckDB function to compute day differences between timestamps.
- This assumes timestamps are stored as `TIMESTAMP` type (standard in DuckDB).
- The `LEAD()` function ensures we only consider **consecutive** activities — no gaps. If there’s an event between them, the sequence won’t match.
- `NOT IN` is safe here because `case_id` is not nullable (as per problem statement — it identifies cases).

This query is efficient, readable, and fully compliant with DuckDB SQL syntax.