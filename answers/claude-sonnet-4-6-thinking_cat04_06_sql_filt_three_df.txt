## Solution

### Approach

The strategy uses **window functions** (`LEAD`) to inspect consecutive events within each case, identify violating cases, and then exclude them entirely from the result.

```sql
-- Step 1: Enrich each event with info about the next two events in the same case
WITH ordered_events AS (
    SELECT
        case_id,
        activity,
        timestamp,
        -- Look ahead at the immediately following activity (within the same case)
        LEAD(activity,   1) OVER (PARTITION BY case_id ORDER BY timestamp) AS next_activity,
        LEAD(activity,   2) OVER (PARTITION BY case_id ORDER BY timestamp) AS next_next_activity,
        -- Also capture their timestamps for the timing condition
        LEAD(timestamp,  1) OVER (PARTITION BY case_id ORDER BY timestamp) AS next_timestamp,
        LEAD(timestamp,  2) OVER (PARTITION BY case_id ORDER BY timestamp) AS next_next_timestamp
    FROM event_log
),

-- Step 2: Isolate cases that contain the forbidden sequence with the timing violation
matching_cases AS (
    SELECT DISTINCT case_id
    FROM ordered_events
    WHERE
        -- The three activities appear in direct succession (no gaps)
        activity          = 'Approve Purchase Requisition'
        AND next_activity         = 'Create Order'
        AND next_next_activity    = 'Confirm Order'
        -- Time between 'Create Order' and 'Confirm Order' exceeds 5 days
        AND (next_next_timestamp - next_timestamp) > INTERVAL '5 days'
)

-- Step 3: Return every event that does NOT belong to a matching case
SELECT  el.*
FROM    event_log AS el
WHERE   el.case_id NOT IN (SELECT case_id FROM matching_cases)
ORDER BY el.case_id, el.timestamp;
```

---

### How It Works

| CTE / Clause | Purpose |
|---|---|
| `ordered_events` | Uses `LEAD(..., 1)` and `LEAD(..., 2)` over `(PARTITION BY case_id ORDER BY timestamp)` to attach each event's *immediately next* and *second-next* activity/timestamp. Because these are consecutive row offsets, **no interleaving events are allowed** — this enforces the "direct succession" requirement. |
| `matching_cases` | Filters to rows where the current activity is `'Approve Purchase Requisition'`, the very next is `'Create Order'`, and the one after that is `'Confirm Order'`. It then additionally checks that the elapsed time between `'Create Order'` and `'Confirm Order'` is **> 5 days**. `DISTINCT` collapses duplicates. |
| Final `SELECT` | Returns **all** columns of every event whose `case_id` is **not** in the excluded set. |

---

### Key Design Decisions

- **`LEAD` for direct succession**: Because `LEAD(activity, 1)` and `LEAD(activity, 2)` yield the *adjacent* rows (no skips), any intervening event would naturally break the match — correctly implementing the "no other event in between" constraint.
- **Interval arithmetic**: `next_next_timestamp - next_timestamp > INTERVAL '5 days'` is native DuckDB syntax and handles timestamp subtraction cleanly.
- **`NOT IN` vs. `NOT EXISTS`**: Both are valid; `NOT IN` is used here for readability. If `case_id` could be `NULL`, `NOT EXISTS` would be safer.