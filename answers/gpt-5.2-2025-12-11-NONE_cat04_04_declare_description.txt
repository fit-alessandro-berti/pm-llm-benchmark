## Practical, step-by-step loan approval process implied by the DECLARE model

### 1) Start and mandatory intake
1. **Receive_Application** must happen and must be the **first** activity.  
   - **Constraints involved:**  
     - `init(Receive_Application)`  the process starts here.  
     - `existence(Receive_Application)`  it must occur at least once.
2. After the application is received, a **Preliminary_Credit_Check** must follow at some point.  
   - **Constraint:** `response(Receive_Application -> Preliminary_Credit_Check)`.

**Real-world motivation:** You can’t assess or proceed without an application, and a credit check is a foundational risk-control step before investing effort in deeper processing.

---

### 2) Exactly one preliminary credit check (and it’s tightly positioned)
3. **Preliminary_Credit_Check** occurs **exactly once** in every case.  
   - **Constraint:** `exactly_one(Preliminary_Credit_Check)`.
4. That credit check is not only required, it’s also “anchored” by a strict adjacency rule: whenever **Authorize_Contract_Terms** happens, it must be **immediately preceded** by **Preliminary_Credit_Check**.  
   - **Constraint:** `chainprecedence(Authorize_Contract_Terms <- Preliminary_Credit_Check)` (i.e., Prelim Credit Check directly before authorization).

**Interpretation in practice:** The model suggests authorization is granted right after a final/validated view of the credit-check result—no intervening steps.

**Motivation:** Prevents using stale credit results, reduces risk of approving based on outdated information, and supports auditability (“authorization was based on the most recent check”).

---

### 3) Document collection is mandatory and coupled with credit check
5. **Gather_Additional_Documents** must happen at least once.  
   - **Constraint:** `existence(Gather_Additional_Documents)`.
6. **Preliminary_Credit_Check** and **Gather_Additional_Documents** are in **succession**: if one occurs, the other must occur, and in the specified order (credit check before document gathering).  
   - **Constraint:** `succession(Preliminary_Credit_Check -> Gather_Additional_Documents)`.

**Practical flow:**  
- Do the credit check, then collect pay stubs/IDs/bank statements as needed.

**Motivation:**  
- **Risk management & efficiency:** credit check first avoids spending time collecting documents for clearly ineligible applicants.  
- **Fraud prevention:** document gathering supports identity verification and income validation.

---

### 4) Quality assurance review must follow documents, and directly leads to packaging
7. **Gather_Additional_Documents** and **Quality_Assurance_Review** are in **alternate succession** (typically meaning: after documents are gathered, a QA review must eventually happen, and between them the pattern is constrained to avoid repeated back-and-forth).  
   - **Constraint:** `altsuccession(Gather_Additional_Documents -> Quality_Assurance_Review)`.
8. Once **Quality_Assurance_Review** occurs, it must be **immediately followed** by **Assemble_Loan_Offer_Package**.  
   - **Constraint:** `chainsuccession(Quality_Assurance_Review -> Assemble_Loan_Offer_Package)`.

**Practical flow:**  
- Documents are collected  QA checks compliance/accuracy  immediately assemble the loan offer package.

**Motivation:**  
- **Regulatory compliance & operational quality:** QA ensures the file is complete, disclosures/criteria are satisfied, and underwriting rules were applied correctly.  
- **Best practice:** assembling an offer right after QA reduces delays and prevents changes slipping in after QA.

---

### 5) Packaging implies QA exists, and triggers funding next
9. If **Assemble_Loan_Offer_Package** occurs, then **Quality_Assurance_Review** must have occurred at least once (not necessarily immediately before—though we already have it immediately before via chain succession if QA happens).  
   - **Constraint:** `responded_existence(Assemble_Loan_Offer_Package -> Quality_Assurance_Review)`.
10. Immediately after **Assemble_Loan_Offer_Package**, the next step must be **Transfer_Funds**.  
   - **Constraint:** `chainresponse(Assemble_Loan_Offer_Package -> Transfer_Funds)`.

**Practical flow:**  
- Offer package is assembled  funding is triggered right away.

**Motivation:**  
- **Customer satisfaction & cycle-time:** reduces waiting after the offer is finalized.  
- **Control:** ensures funding is tied to a finalized package rather than ad-hoc decisions.

---

### 6) Authorization, documents, and QA ordering
11. **Quality_Assurance_Review** must occur **before** **Authorize_Contract_Terms**.  
   - **Constraint:** `precedence(Quality_Assurance_Review -> Authorize_Contract_Terms)` (QA is a prerequisite).
12. **Gather_Additional_Documents** and **Authorize_Contract_Terms** must either both occur or neither occurs (coexistence).  
   - **Constraint:** `coexistence(Gather_Additional_Documents <-> Authorize_Contract_Terms)`.

**Practical implication:**  
- You cannot authorize contract terms without document gathering being part of the case (and if you gathered documents, authorization must happen at some point).

**Motivation:**  
- **Audit & compliance:** authorization requires a documented file.  
- **Operational consistency:** prevents “soft approvals” without completed documentation.

**Note on overall ordering tension:** The model also forces **Authorize_Contract_Terms** to be directly preceded by **Preliminary_Credit_Check**, while also requiring QA to occur before authorization. In a real implementation, this implies that QA must happen earlier, and the process returns to a “final” credit check right before authorization (even if the activity label is the same). Because `exactly_one(Preliminary_Credit_Check)` allows only one instance, this model effectively compresses the ordering so that QA must happen before that single credit check, which is atypical. In practice, organizations often do *initial* credit check early and a *final refresh* just before authorization; the model’s “exactly one” constraint conflicts with that common practice.

---

### 7) Funding and customer notification are coupled and ordered
13. If **Transfer_Funds** happens, **Notify_Customer** must eventually happen afterward, and the “alternate” form typically restricts repeated alternations.  
   - **Constraint:** `altresponse(Transfer_Funds -> Notify_Customer)`.
14. **Notify_Customer** must occur **before** **Transfer_Funds** (alternate precedence).  
   - **Constraint:** `altprecedence(Notify_Customer -> Transfer_Funds)`.

**Combined implication:** Notification and transfer are tightly linked and (given precedence) notification comes first. In real terms:  
- Notify customer that funds will be disbursed / approval confirmed  then transfer funds  ensure notification occurs (again) or is already satisfied depending on interpretation.

**Motivation:**  
- **Customer satisfaction & legal clarity:** customers should receive confirmation/disclosures before money moves.  
- **Operational control:** reduces disputes (“I wasn’t told funds were being disbursed”).

---

## Prohibitions and “must not happen” rules (safety/compliance guards)

### A) Forbidden activity
- **Proceed_Without_Compliance** must never occur.  
  - **Constraint:** `absence(Proceed_Without_Compliance)`.

**Motivation:** Encodes non-negotiable regulatory and policy requirements—no bypassing KYC/AML, underwriting rules, required disclosures, etc.

### B) Noncoexistence: transfer funds cannot coexist with receiving application
- **Transfer_Funds** and **Receive_Application** cannot both appear in the same case.  
  - **Constraint:** `noncoexistence(Transfer_Funds, Receive_Application)`.

**Practical meaning:** As written, this forbids a normal end-to-end loan case (because the process must start with Receive_Application and also (apparently) transfers funds later). In real-world modeling, you’d rarely want this; you might instead want a constraint like “funding cannot occur before application is received” (a precedence), not “cannot both occur.”

### C) Nonsuccession: notifying customer cannot be followed by preliminary credit check
- **Notify_Customer** must not occur before a later **Preliminary_Credit_Check**.  
  - **Constraint:** `nonsuccession(Notify_Customer -> Preliminary_Credit_Check)`.

**Motivation:** Prevents telling the customer a result/next steps and then performing core eligibility checks afterward (which would look like a broken or deceptive process).

### D) Non-chain succession: authorization must not be immediately followed by notification
- **Authorize_Contract_Terms** cannot have **Notify_Customer** as its immediate next step.  
  - **Constraint:** `nonchainsuccession(Authorize_Contract_Terms -> Notify_Customer)`.

**Motivation:** Enforces an intermediate step between authorization and notification (e.g., documentation generation, booking the loan, internal posting, fraud hold checks). It prevents premature communication before systems reflect the final state.

---

## What the “intended” real-world flow likely is (narrative)
A plausible operational story (ignoring the model’s internal contradictions like noncoexistence and the tight chainprecedence/exactly-one issue) looks like:

1. Receive application (case start).
2. Preliminary credit check (initial eligibility screen).
3. Gather additional documents (identity, income, collateral as needed).
4. Quality assurance review (completeness and compliance checks).
5. Assemble loan offer package (prepare final terms and docs).
6. Authorize contract terms (formal approval).
7. Notify customer (approval confirmation / disbursement notice).
8. Transfer funds (disbursement).
9. Notify customer (confirmation of disbursement) — depending on how notification is implemented.

---

## Consequences if steps occur out of order or are omitted

- **Skipping Preliminary_Credit_Check (or doing it more than once):**  
  - Violates risk controls; could lead to approvals for high-risk applicants or inconsistent decisions.  
  - Repeating it (disallowed) would break audit expectations in this model; in reality, the *business* might want a refresh check, but then the model should allow it explicitly.

- **Gathering documents before credit check (violating succession):**  
  - Wastes operational effort and increases customer friction for applicants likely to be rejected.  
  - Increases exposure to handling sensitive data unnecessarily (privacy/security risk).

- **Authorizing terms before QA review (violating precedence):**  
  - High compliance risk: missing disclosures, KYC gaps, policy exceptions not recorded.  
  - Audit findings, regulatory penalties, or forced remediation.

- **Assembling offer package without QA (violating responded existence):**  
  - Increases error rates in offer documents (APR, fees, conditions), driving rework, complaints, and legal exposure.

- **Transferring funds before proper customer notification (violating altprecedence/altresponse intent):**  
  - Disputes, chargebacks/returns, reputational harm.  
  - Potential violation of consumer lending disclosure timing rules depending on jurisdiction.

- **Performing “Proceed_Without_Compliance” (forbidden):**  
  - Direct regulatory breach (AML/KYC, consumer credit regs), potential fines, license risk, and fraud exposure.

---

## Important note: the model contains constraints that clash with a typical end-to-end funded loan
Two constraints in particular make a fully consistent “application-to-funding” trace difficult or impossible depending on exact DECLARE semantics:
- `noncoexistence(Transfer_Funds, Receive_Application)` conflicts with the fact that `Receive_Application` is mandatory and the process presumably includes `Transfer_Funds`.
- `exactly_one(Preliminary_Credit_Check)` combined with `chainprecedence(Authorize_Contract_Terms <- Preliminary_Credit_Check)` and `precedence(QA -> Authorize)` tends to force unusual ordering (QA before the single credit check) or makes common “initial + final credit refresh” impossible.

If your intent is a realistic loan process, those would typically be adjusted (e.g., replace noncoexistence with precedence constraints, and allow two credit-check variants or relax “exactly_one”).