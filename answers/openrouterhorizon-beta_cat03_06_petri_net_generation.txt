```python
from pm4py.objects.petri_net.obj import PetriNet, Marking
from pm4py.objects.petri_net.utils import petri_utils

# Create Petri net
net = PetriNet("Insurance Claim Process")

# Places (states between activities)
p_start = PetriNet.Place("p_start")              # new claim arrives
p_after_C = PetriNet.Place("p_after_C")          # after Insurance Claim (C)
p_after_CR = PetriNet.Place("p_after_CR")        # after Claim Registration (CR)
p_after_DV = PetriNet.Place("p_after_DV")        # after Document Verification (DV) - complete
p_need_RDS = PetriNet.Place("p_need_RDS")        # documents incomplete -> need Re-Document Submission (RDS)
p_after_RDS = PetriNet.Place("p_after_RDS")      # after RDS, go back to DV
p_after_FC = PetriNet.Place("p_after_FC")        # after Fraud Check (FC) - cleared
p_need_II = PetriNet.Place("p_need_II")          # FC raises doubts -> need In-depth Investigation (II)
p_after_II = PetriNet.Place("p_after_II")        # after II, go back to FC
p_after_CA = PetriNet.Place("p_after_CA")        # after Claim Assessment (CA)
p_after_AP = PetriNet.Place("p_after_AP")        # after Approval (AP) (when required)
p_ready_for_payment = PetriNet.Place("p_ready_for_payment")  # ready for Payment (P)
p_after_P = PetriNet.Place("p_after_P")          # after Payment (P)
p_after_N = PetriNet.Place("p_after_N")          # after Notification (N)
p_closed = PetriNet.Place("p_closed")            # final closed claim

# Add places to net
net.places.update({
    p_start, p_after_C, p_after_CR, p_after_DV, p_need_RDS, p_after_RDS,
    p_after_FC, p_need_II, p_after_II, p_after_CA, p_after_AP,
    p_ready_for_payment, p_after_P, p_after_N, p_closed
})

# Transitions (activities)
t_C = PetriNet.Transition("C", "Insurance Claim (C)")
t_CR = PetriNet.Transition("CR", "Claim Registration (CR)")
t_DV = PetriNet.Transition("DV", "Document Verification (DV)")
t_RDS = PetriNet.Transition("RDS", "Re-Document Submission (RDS)")
t_FC = PetriNet.Transition("FC", "Fraud Check (FC)")
t_II = PetriNet.Transition("II", "In-depth Investigation (II)")
t_CA = PetriNet.Transition("CA", "Claim Assessment (CA)")
t_AP = PetriNet.Transition("AP", "Approval (AP)")
t_skip_AP = PetriNet.Transition("skip_AP", None)  # silent transition if approval not required
t_P = PetriNet.Transition("P", "Payment (P)")
t_N = PetriNet.Transition("N", "Notification (N)")
t_CL = PetriNet.Transition("CL", "Closure (CL)")

# Add transitions to net
net.transitions.update({
    t_C, t_CR, t_DV, t_RDS, t_FC, t_II, t_CA, t_AP, t_skip_AP, t_P, t_N, t_CL
})

# Arcs
# Start -> Insurance Claim logged
petri_utils.add_arc_from_to(p_start, t_C, net)
petri_utils.add_arc_from_to(t_C, p_after_C, net)

# Claim Registration
petri_utils.add_arc_from_to(p_after_C, t_CR, net)
petri_utils.add_arc_from_to(t_CR, p_after_CR, net)

# Document Verification with possible loop to RDS (re-submission)
# DV has two outcomes: complete -> p_after_DV; incomplete -> p_need_RDS
# Model with two DV transitions or a single DV with branching via silent transitions.
# Here, use two explicit outcomes via DV_complete/DV_incomplete using silent post-splits:
t_DV_complete = PetriNet.Transition("DV_complete", None)
t_DV_incomplete = PetriNet.Transition("DV_incomplete", None)
net.transitions.add(t_DV_complete)
net.transitions.add(t_DV_incomplete)

# Execute DV then split silently to outcomes
petri_utils.add_arc_from_to(p_after_CR, t_DV, net)
mid_after_DV_exec = PetriNet.Place("p_mid_after_DV_exec")
net.places.add(mid_after_DV_exec)
petri_utils.add_arc_from_to(t_DV, mid_after_DV_exec, net)

petri_utils.add_arc_from_to(mid_after_DV_exec, t_DV_complete, net)
petri_utils.add_arc_from_to(mid_after_DV_exec, t_DV_incomplete, net)
petri_utils.add_arc_from_to(t_DV_complete, p_after_DV, net)
petri_utils.add_arc_from_to(t_DV_incomplete, p_need_RDS, net)

# RDS loop back to DV
petri_utils.add_arc_from_to(p_need_RDS, t_RDS, net)
petri_utils.add_arc_from_to(t_RDS, p_after_RDS, net)
# After RDS, run DV again
petri_utils.add_arc_from_to(p_after_RDS, t_DV, net)

# Fraud Check with possible multiple II loops
# FC has two outcomes: cleared -> p_after_FC; doubts -> p_need_II
t_FC_cleared = PetriNet.Transition("FC_cleared", None)
t_FC_doubts = PetriNet.Transition("FC_doubts", None)
net.transitions.add(t_FC_cleared)
net.transitions.add(t_FC_doubts)

petri_utils.add_arc_from_to(p_after_DV, t_FC, net)
mid_after_FC_exec = PetriNet.Place("p_mid_after_FC_exec")
net.places.add(mid_after_FC_exec)
petri_utils.add_arc_from_to(t_FC, mid_after_FC_exec, net)

petri_utils.add_arc_from_to(mid_after_FC_exec, t_FC_cleared, net)
petri_utils.add_arc_from_to(mid_after_FC_exec, t_FC_doubts, net)
petri_utils.add_arc_from_to(t_FC_cleared, p_after_FC, net)
petri_utils.add_arc_from_to(t_FC_doubts, p_need_II, net)

# II loop back to FC (may repeat multiple times)
petri_utils.add_arc_from_to(p_need_II, t_II, net)
petri_utils.add_arc_from_to(t_II, p_after_II, net)
petri_utils.add_arc_from_to(p_after_II, t_FC, net)

# Claim Assessment
petri_utils.add_arc_from_to(p_after_FC, t_CA, net)
petri_utils.add_arc_from_to(t_CA, p_after_CA, net)

# Approval path: either approval required (AP) or skip approval (silent)
petri_utils.add_arc_from_to(p_after_CA, t_AP, net)
petri_utils.add_arc_from_to(t_AP, p_after_AP, net)

petri_utils.add_arc_from_to(p_after_CA, t_skip_AP, net)
petri_utils.add_arc_from_to(t_skip_AP, p_ready_for_payment, net)

# From approved state also ready for payment
petri_utils.add_arc_from_to(p_after_AP, t_P, net)
petri_utils.add_arc_from_to(p_ready_for_payment, t_P, net)
petri_utils.add_arc_from_to(t_P, p_after_P, net)

# Notification and Closure
petri_utils.add_arc_from_to(p_after_P, t_N, net)
petri_utils.add_arc_from_to(t_N, p_after_N, net)
petri_utils.add_arc_from_to(p_after_N, t_CL, net)
petri_utils.add_arc_from_to(t_CL, p_closed, net)

# Initial and final markings
im = Marking()
im[p_start] = 1

fm = Marking()
fm[p_closed] = 1

# Optional: if you want a single explicit start transition for "new claim arrives",
# you could add a source place and silent start transition, but p_start with a token is sufficient.
```