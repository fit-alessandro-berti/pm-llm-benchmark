Here's a DuckDB SQL query that filters out cases with more than six events and returns all events from cases with six or fewer events:

```sql
SELECT el.*
FROM event_log el
INNER JOIN (
    SELECT case_id
    FROM event_log
    GROUP BY case_id
    HAVING COUNT(*) <= 6
) filtered_cases ON el.case_id = filtered_cases.case_id
ORDER BY el.case_id, el.timestamp;
```

**Alternative approach using a CTE (Common Table Expression):**

```sql
WITH case_counts AS (
    SELECT case_id, COUNT(*) as event_count
    FROM event_log
    GROUP BY case_id
    HAVING COUNT(*) <= 6
)
SELECT el.*
FROM event_log el
INNER JOIN case_counts cc ON el.case_id = cc.case_id
ORDER BY el.case_id, el.timestamp;
```

**Alternative approach using a window function:**

```sql
SELECT case_id, activity, timestamp
FROM (
    SELECT *,
           COUNT(*) OVER (PARTITION BY case_id) as case_event_count
    FROM event_log
) 
WHERE case_event_count <= 6
ORDER BY case_id, timestamp;
```

**Explanation:**
- All three approaches achieve the same result but use different techniques
- The first approach uses a subquery to identify cases with 6 events, then joins back to get all events for those cases
- The CTE approach makes the query more readable by separating the case counting logic
- The window function approach calculates the event count per case directly in the main query
- The `ORDER BY` clause ensures the results are organized by case and chronological order

The window function approach is often the most efficient for this type of filtering in analytical databases like DuckDB.