```python
from pm4py.objects.petri_net.obj import PetriNet, Marking
from pm4py.objects.petri_net.utils import petri_utils

# Create a new Petri net for the insurance claim process
net = PetriNet(name="Insurance_Claim_Process")

# Define places
start = PetriNet.Place("start")
claim_registered = PetriNet.Place("claim_registered")
documents_submitted = PetriNet.Place("documents_submitted")
documents_verified = PetriNet.Place("documents_verified")
fraud_checked = PetriNet.Place("fraud_checked")
investigation_done = PetriNet.Place("investigation_done")
claim_assessed = PetriNet.Place("claim_assessed")
approved = PetriNet.Place("approved")
paid = PetriNet.Place("paid")
notified = PetriNet.Place("notified")
closed = PetriNet.Place("closed")

# Add all places to the net
for place in [
    start,
    claim_registered,
    documents_submitted,
    documents_verified,
    fraud_checked,
    investigation_done,
    claim_assessed,
    approved,
    paid,
    notified,
    closed,
]:
    net.places.add(place)

# Define transitions (with labels for activities)
t_cr = PetriNet.Transition("t_cr", "Claim Registration")
t_dv = PetriNet.Transition("t_dv", "Document Verification")
t_rds = PetriNet.Transition("t_rds", "Re-Document Submission")
t_fc = PetriNet.Transition("t_fc", "Fraud Check")
t_ii = PetriNet.Transition("t_ii", "In-depth Investigation")
t_ca = PetriNet.Transition("t_ca", "Claim Assessment")
t_ap = PetriNet.Transition("t_ap", "Approval")
t_p = PetriNet.Transition("t_p", "Payment")
t_n = PetriNet.Transition("t_n", "Notification")
t_cl = PetriNet.Transition("t_cl", "Closure")

# Add all transitions to the net
for trans in [t_cr, t_dv, t_rds, t_fc, t_ii, t_ca, t_ap, t_p, t_n, t_cl]:
    net.transitions.add(trans)

# Add arcs to model flow

# Start -> Claim Registration
petri_utils.add_arc_from_to(start, t_cr, net)
petri_utils.add_arc_from_to(t_cr, claim_registered, net)

# Claim Registration -> Document Submission
petri_utils.add_arc_from_to(claim_registered, t_dv, net)
petri_utils.add_arc_from_to(t_dv, documents_verified, net)

# Optional loop for re-submitting documents
petri_utils.add_arc_from_to(documents_verified, t_rds, net)
petri_utils.add_arc_from_to(t_rds, documents_submitted, net)
petri_utils.add_arc_from_to(documents_submitted, t_dv, net)

# After successful verification, move to Fraud Check
petri_utils.add_arc_from_to(documents_verified, t_fc, net)
petri_utils.add_arc_from_to(t_fc, fraud_checked, net)

# In-depth Investigation loop (can happen multiple times)
petri_utils.add_arc_from_to(fraud_checked, t_ii, net)
petri_utils.add_arc_from_to(t_ii, investigation_done, net)
petri_utils.add_arc_from_to(investigation_done, t_fc, net)  # Loop back to fraud check

# Proceed to Claim Assessment after fraud check (with or without II)
petri_utils.add_arc_from_to(fraud_checked, t_ca, net)
petri_utils.add_arc_from_to(t_ca, claim_assessed, net)

# Approval step
petri_utils.add_arc_from_to(claim_assessed, t_ap, net)
petri_utils.add_arc_from_to(t_ap, approved, net)

# Payment
petri_utils.add_arc_from_to(approved, t_p, net)
petri_utils.add_arc_from_to(t_p, paid, net)

# Notification
petri_utils.add_arc_from_to(paid, t_n, net)
petri_utils.add_arc_from_to(t_n, notified, net)

# Closure
petri_utils.add_arc_from_to(notified, t_cl, net)
petri_utils.add_arc_from_to(t_cl, closed, net)

# Define initial marking: token at start
im = Marking()
im[start] = 1

# Define final marking: token at closed
fm = Marking()
fm[closed] = 1

# Result: Accepting Petri net defined with net, im, fm
```

###  Summary:
This Petri net models the full **insurance claim lifecycle** with:
- A **sequential flow** from registration to closure.
- A **feedback loop** between `Document Verification` and `Re-Document Submission` for incomplete documents.
- A **loop for In-depth Investigation**, allowing multiple checks before passing `Fraud Check`.

The **initial marking** starts with one token in `start`, and the **final marking** requires one token in `closed`, representing a successfully processed and closed claim.

You can now use this accepting Petri net with PM4Py for simulation, conformance checking, or process mining tasks.