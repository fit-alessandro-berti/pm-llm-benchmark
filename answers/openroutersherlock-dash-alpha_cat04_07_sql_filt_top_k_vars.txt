```sql
WITH case_sequences AS (
  -- Step 1: Extract ordered sequence of activities for each case
  SELECT 
    case_id,
    LIST_AGG(activity ORDER BY timestamp) AS activity_sequence
  FROM event_log
  GROUP BY case_id
),

variant_stats AS (
  -- Step 2 & 3: Group by sequence (variant) and count frequency, get top K
  SELECT 
    activity_sequence,
    COUNT(*) as variant_frequency,
    ROW_NUMBER() OVER (ORDER BY COUNT(*) DESC) as variant_rank
  FROM case_sequences
  GROUP BY activity_sequence
),

top_k_variants AS (
  -- Select top K variants (adjust K as needed, e.g., K=5)
  SELECT activity_sequence
  FROM variant_stats 
  WHERE variant_rank <= 5  -- Set K=5 here
)

-- Step 4: Return all events from cases belonging to top K variants
SELECT e.*
FROM event_log e
WHERE e.case_id IN (
  SELECT cs.case_id
  FROM case_sequences cs
  JOIN top_k_variants tkv ON cs.activity_sequence = tkv.activity_sequence
);
```

**Key features of this solution:**

1. **`case_sequences` CTE**: Uses `LIST_AGG(activity ORDER BY timestamp)` to create the ordered activity sequence for each `case_id`, perfectly preserving timestamp order.

2. **`variant_stats` CTE**: Groups identical sequences together and counts their frequency. Uses `ROW_NUMBER()` to rank variants by frequency (descending).

3. **`top_k_variants` CTE**: Filters to only the top K variants (K=5 in this example - easily adjustable).

4. **Final SELECT**: Joins back to the original `event_log` to return **all events** (not just sequences) for cases matching the top K variants.

**To customize K**: Simply change `WHERE variant_rank <= 5` to your desired value (e.g., `<= 10` for top 10 variants).

**Output**: Complete event records (`case_id`, `activity`, `timestamp`) from only the cases following the most frequent process variants, maintaining original event-level granularity.