# POWL Model for Manufacturing and Distribution Process

## Analysis of Event Log Patterns

After analyzing the event log, I identified the following patterns:

1. **Sequential start**: OR  MS  QS (always in this order)
2. **Assembly with quality checks**: AS can be followed by IQC(s), which can repeat multiple times before another AS
3. **Testing with re-testing**: TST may be followed by RT, then TST again (can repeat)
4. **Optional labeling**: LB may be skipped (as in Case 2)
5. **Sequential end**: PK  (optional LB)  DP  D

### Key Loop Patterns Identified:

- **Assembly Loop**: `*(AS, *(IQC, skip))` - Assembly is done, then optionally one or more IQCs followed by another Assembly (repeatable)
- **Testing Loop**: `*(TST, RT)` - Testing is done, then optionally Re-Testing followed by Testing again (repeatable)
- **Optional Labeling**: `X(LB, skip)` - Either Labeling or skip it

## Final POWL Model

```python
from pm4py.objects.powl.obj import StrictPartialOrder, OperatorPOWL, Transition, SilentTransition
from pm4py.objects.process_tree.obj import Operator

# Define all activity transitions
OR = Transition(label="OR")
MS = Transition(label="MS")
QS = Transition(label="QS")
AS = Transition(label="AS")
IQC = Transition(label="IQC")
TST = Transition(label="TST")
RT = Transition(label="RT")
PK = Transition(label="PK")
LB = Transition(label="LB")
DP = Transition(label="DP")
D = Transition(label="D")

# Silent transitions for loops and optional paths
skip_iqc = SilentTransition()
skip_lb = SilentTransition()

# IQC inner loop: allows one or more consecutive IQCs
# *(IQC, skip) produces: IQC, IQC IQC, IQC IQC IQC, etc.
iqc_loop = OperatorPOWL(operator=Operator.LOOP, children=[IQC, skip_iqc])

# Assembly loop: AS followed optionally by (IQC+ then AS again)
# *(AS, iqc_loop) produces: AS, AS IQC+ AS, AS IQC+ AS IQC+ AS, etc.
assembly_loop = OperatorPOWL(operator=Operator.LOOP, children=[AS, iqc_loop])

# Testing loop: TST followed optionally by (RT then TST again)
# *(TST, RT) produces: TST, TST RT TST, TST RT TST RT TST, etc.
testing_loop = OperatorPOWL(operator=Operator.LOOP, children=[TST, RT])

# Optional labeling: either perform LB or skip it
labeling_choice = OperatorPOWL(operator=Operator.XOR, children=[LB, skip_lb])

# Main process as a strict partial order (fully sequential)
root = StrictPartialOrder(nodes=[OR, MS, QS, assembly_loop, testing_loop, PK, labeling_choice, DP, D])
root.order.add_edge(OR, MS)
root.order.add_edge(MS, QS)
root.order.add_edge(QS, assembly_loop)
root.order.add_edge(assembly_loop, testing_loop)
root.order.add_edge(testing_loop, PK)
root.order.add_edge(PK, labeling_choice)
root.order.add_edge(labeling_choice, DP)
root.order.add_edge(DP, D)
```

## Visual Representation

```
PO=(nodes={OR, MS, QS, *(AS, *(IQC, )), *(TST, RT), PK, X(LB, ), DP, D},
    order={ORMS, MSQS, QS*(AS, *(IQC, )), 
           *(AS, *(IQC, ))*(TST, RT), *(TST, RT)PK,
           PKX(LB, ), X(LB, )DP, DPD})
```

## Model Validation Against Cases

| Case | Trace | Model Path |
|------|-------|------------|
| 1 | ORMSQSASIQCASTSTRTTSTPKLBDPD |  |
| 2 | ORMSQSASIQCASTSTPKDPD (LB skipped) |  |
| 3 | ORMSQSASIQCIQCASIQCASTSTRTTSTPKLBDPD |  |
| 4 | ORMSQSASTSTPKLBDPD (no IQC, no RT) |  |
| 5 | ORMSQSASIQCASIQCASTSTRTTSTRTTSTPKLBDPD |  |