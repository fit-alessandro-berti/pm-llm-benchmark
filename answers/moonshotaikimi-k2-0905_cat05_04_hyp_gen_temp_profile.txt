Anomalies observed in the temporal profile
1. (R  P) 25 h ± 1 h – extremely narrow spread for a multi-day path that must include assignment and evaluation.  
2. (P  N) 7 days ± 2 days – approval is done but the customer is not told for a week on average.  
3. (A  C) 2 h ± 1 h – claims are closed very soon after the adjuster is assigned, although evaluation and approval should still happen.  
4. (E  N) 5 min ± 1 min – notification fires almost immediately after evaluation, faster than plausible manual review or letter generation.

Hypotheses that may explain the above
- R  P low variance: a batch job auto-approves certain low-value claims exactly 24 h after receipt; human checks are skipped.  
- P  N long delay: the notification task is queued in a separate system that runs only weekly, or the team that sends letters is under-staffed.  
- A  C short loop: some claims are “fast-closed” (denied or withdrawn) immediately after assignment; these never reach evaluation/approval.  
- E  N near-zero gap: evaluation and notification are logged by the same automated call that marks the claim “evaluated” and instantly triggers an e-mail; the two events are technically distinct but temporally coincident.

Verification SQL (PostgreSQL syntax)

1. List every claim whose RP interval deviates by more than 3  (1 h) from the profiled mean (25 h):

```sql
WITH r AS (
    SELECT claim_id, timestamp AS t_r
    FROM claim_events
    WHERE activity = 'R'
),
p AS (
    SELECT claim_id, timestamp AS t_p
    FROM claim_events
    WHERE activity = 'P'
)
SELECT r.claim_id,
       EXTRACT(EPOCH FROM (p.t_p - r.t_r))/3600 AS hours_r_to_p
FROM r
JOIN p USING (claim_id)
WHERE ABS(EXTRACT(EPOCH FROM (p.t_p - r.t_r)) - 25*3600) > 3*3600
ORDER BY hours_r_to_p;
```

2. Identify claims closed within 3 h of assignment (possible fast-closure):

```sql
WITH a AS (
    SELECT claim_id, timestamp AS t_a
    FROM claim_events
    WHERE activity = 'A'
),
c AS (
    SELECT claim_id, timestamp AS t_c
    FROM claim_events
    WHERE activity = 'C'
)
SELECT a.claim_id,
       EXTRACT(EPOCH FROM (c.t_c - a.t_a))/3600 AS hours_a_to_c
FROM a
JOIN c USING (claim_id)
WHERE c.t_c BETWEEN a.t_a AND a.t_a + INTERVAL '3 hours'
ORDER BY hours_a_to_c;
```

3. Distribution of PN delay by claim type and adjuster region (to spot backlog patterns):

```sql
WITH p AS (
    SELECT ce.claim_id, ce.timestamp AS t_p
    FROM claim_events ce
    WHERE ce.activity = 'P'
),
n AS (
    SELECT ce.claim_id, ce.timestamp AS t_n
    FROM claim_events ce
    WHERE ce.activity = 'N'
)
SELECT cl.claim_type,
       ad.region,
       COUNT(*) AS cnt,
       PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY EXTRACT(EPOCH FROM (n.t_n - p.t_p))/86400) AS median_days,
       MIN(EXTRACT(EPOCH FROM (n.t_n - p.t_p))/86400) AS min_days,
       MAX(EXTRACT(EPOCH FROM (n.t_n - p.t_p))/86400) AS max_days
FROM p
JOIN n USING (claim_id)
JOIN claims cl ON cl.claim_id = p.claim_id
JOIN claim_events ce2 ON ce2.claim_id = p.claim_id AND ce2.activity = 'A'
JOIN adjusters ad ON ad.adjuster_id::text = ce2.resource
GROUP BY cl.claim_type, ad.region
ORDER BY median_days DESC;
```

4. Check whether tiny EN gaps come from automated resource “SYSTEM”:

```sql
SELECT ce1.claim_id,
       EXTRACT(EPOCH FROM (ce2.timestamp - ce1.timestamp)) AS seconds_e_to_n,
       ce1.resource AS eval_resource,
       ce2.resource AS notif_resource
FROM claim_events ce1
JOIN claim_events ce2
  ON ce1.claim_id = ce2.claim_id
 AND ce2.activity = 'N'
 AND ce2.timestamp BETWEEN ce1.timestamp AND ce1.timestamp + INTERVAL '1 minute'
WHERE ce1.activity = 'E'
ORDER BY seconds_e_to_n;
```

These queries let the analyst count how many cases fall into each anomalous bucket, link them to specific adjusters or claim attributes, and decide whether corrective action is required.