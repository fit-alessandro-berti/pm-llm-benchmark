To generate a temporal profile for an hypothetical Purchase-to-Pay (P2P) process, we need to first define the steps in the process and then collect data on the times between each couple of activities. For the sake of this example, let's assume we have trace data from multiple executions of the P2P process. We will use this data to calculate the average and standard deviation for each couple of activities.

Here's a simplified version of a P2P process with key steps:

1. Purchase Order Creation (POC)
2. Goods Receipt (GR)
3. Invoice Receipt (IR)
4. PO Match (matching the purchase order with the goods received and the invoice received)
5. Three-way match (confirming that the PO, GR, and IR are consistent with each other)
6. Payment Processing (PP)
7. Invoice Approval (IA)
8. Payment Execution (PE)

Now, let's assume we have collected the inter-activity times between each couple of activities for a number of process executions. We will use this data to calculate the average and standard deviation. For the purpose of this example, I will generate synthetic data and compute the temporal profile.

Here's a Python script that could be used to calculate the temporal profile:

```python
import numpy as np
from scipy.stats import sem

# Synthetic data for inter-activity times in seconds (for example purposes)
data = {
    ('POC', 'GR'): [3600, 4800, 2400, 5400],  # Purchase Order Creation to Goods Receipt
    ('GR', 'IR'): [1200, 900, 1800, 600],     # Goods Receipt to Invoice Receipt
    ('IR', 'POM'): [1500, 3000, 7200, 4500],   # Invoice Receipt to PO Match
    ('POM', 'TWM'): [2400, 2880, 900, 4320],   # PO Match to Three-way match
    ('TWM', 'PP'): [10800, 21600, 7200, 5400],  # Three-way match to Payment Processing
    ('PP', 'IA'): [3600, 9000, 6000, 10800],   # Payment Processing to Invoice Approval
    ('IA', 'PE'): [4800, 5400, 21600, 10800]   # Invoice Approval to Payment Execution
}

# Calculate the average and standard deviation for each couple of activities
temporal_profile = {}
for (act1, act2), times in data.items():
    mean = np.mean(times)
    sem_value = sem(times)  # Standard Error of the Mean, which is a measure of variability
    stddev = sem_value / len(times)**0.5  # Standard Deviation
    temporal_profile[act1, act2] = (mean, stddev)

# Example ZETA value for deviation detection
ZETA = 3  # This is an arbitrary value for illustration purposes

# Function to detect deviations based on ZETA
def detect_deviations(temporal_profile, zeta):
    deviations = {}
    for (act1, act2), (mean, stddev) in temporal_profile.items():
        lower_bound = mean - zeta * stddev
        upper_bound = mean + zeta * stddev
        deviations[(act1, act2)] = {
            'lower_bound': lower_bound,
            'upper_bound': upper_bound
        }
    return deviations

# Generate the temporal profile with deviation bounds
temporal_profile_with_deviations = detect_deviations(temporal_profile, ZETA)

print(temporal_profile_with_deviations)
```

This script will output a temporal profile dictionary that includes the average and standard deviation for each couple of activities, as well as the lower and upper bounds for detection of deviations based on the ZETA value. The actual values for the P2P process steps would depend on real-world data collection and analysis.

Please note that the above script uses synthetic data and an arbitrary ZETA value for demonstration purposes. In a real-world scenario, you would collect actual inter-activity times from your processes and analyze them to generate an accurate temporal profile.