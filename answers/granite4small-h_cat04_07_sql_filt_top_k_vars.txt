Below is a **singlestatement DuckDB query** that accomplishes every step you described:

```sql
WITH ordered_events AS (
    -- 1 Order activities per case by timestamp and concatenate them into a string.
    SELECT
        case_id,
        GROUP_CONCAT(activity, ',') OVER (PARTITION BY case_id ORDER BY "timestamp") AS variant_sequence
    FROM event_log
),

variant_counts AS (
    -- 2 Count how many cases belong to each distinct activitysequence (process variant).
    SELECT
        variant_sequence,
        COUNT(*) AS case_count
    FROM ordered_events
    GROUP BY variant_sequence
)

SELECT e.*
FROM event_log      AS e               -- the original log we finally return
JOIN ordered_events  oe ON e.case_id = oe.case_id   -- bring in each case’s variant string
JOIN variant_counts vc ON oe.variant_sequence = vc.variant_sequence   -- attach counts
WHERE vc.case_count IN (
    SELECT DISTINCT CASE WHEN rn <= :K THEN cnt END
    FROM (
        SELECT
            case_count,
            ROW_NUMBER() OVER (ORDER BY case_count DESC) AS rn
        FROM variant_counts
    )
);
```

### How the query works – stepbystep

| Step | What it does | Why it matters |
|------|--------------|----------------|
| **`ordered_events` CTE** | Uses `GROUP_CONCAT(activity, ',') OVER (PARTITION BY case_id ORDER BY "timestamp")` to produce a *single string* for each `case_id` that lists all activities in the exact order they occurred. | Gives us a concrete representation of “the process variant” – i.e., the ordered sequence of activities per case. |
| **`variant_counts` CTE** | Counts how many rows (cases) share each distinct `variant_sequence`. The result column `case_count` tells you exactly how many cases follow that particular variant. | Allows us to rank variants by popularity and later filter for the topK ones. |
| **Final SELECT** | Joins back to the original `event_log` so we can return *all* columns of every event belonging to a case whose variant is among the most frequent. The join condition ensures we only keep events from those selected cases. | Guarantees that the output contains exactly the rows you asked for: “all events from the original log that belong **only** to cases which are part of the topK variants.” |
| **TopK filter** | `WHERE vc.case_count IN ( … )` extracts the K highest counts. The inner window function (`ROW_NUMBER()`) ranks all variants by their frequency and keeps only those with a rank :K. | Implements “topK most frequent process variants”. You can set `:K = 5` (or any other positive integer) before running the query. |

### Parameters

- **`:K`** – Replace this placeholder with the desired number of top variants, e.g., `5`. In many client libraries you’d bind it as a named parameter.

### Example usage

```sql
-- Assuming K = 3 (the three most common process variants)
WITH ...   -- (query from above)

SELECT ...
WHERE vc.case_count IN (
    SELECT DISTINCT CASE WHEN rn <= 3 THEN cnt END FROM ( … )
);
```

Running the query with `:K = 3` will:

1. Identify the three activitysequences that appear in the most cases.
2. Return **all events** from every case whose variant matches one of those three sequences.

If you need to adjust ordering stability, add a secondary sort key inside `GROUP_CONCAT`, e.g., `, ROW_NUMBER() OVER (PARTITION BY case_id ORDER BY "timestamp")` before concatenation – this ensures deterministic output when multiple rows share the same timestamp.