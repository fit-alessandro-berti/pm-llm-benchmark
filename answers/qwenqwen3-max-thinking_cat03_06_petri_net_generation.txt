Here's the Python code that constructs an **accepting Petri net** for the described **insurance claim management process**, including the optional loops for **re-document submission (RDS)** and **in-depth investigation (II)**.

We follow the structure:
- **Places** represent states **between** activities.
- **Transitions** are labeled with the **activity names**.
- **Loops** are modeled using extra places and transitions to allow rework.
- The **initial marking** has a token in the `start` place (before Claim Registration).
- The **final marking** has a token in the `end` place (after Closure).

---

###  Python Code Using `pm4py`

```python
from pm4py.objects.petri_net.obj import PetriNet, Marking
from pm4py.objects.petri_net.utils import petri_utils

# Create the Petri net
net = PetriNet(name="InsuranceClaimProcess")

# --- Define Places ---
start = PetriNet.Place(name="start")
after_CR = PetriNet.Place(name="after_CR")          # after Claim Registration
after_DV = PetriNet.Place(name="after_DV")          # after Document Verification
after_RDS = PetriNet.Place(name="after_RDS")        # after Re-Document Submission
after_FC = PetriNet.Place(name="after_FC")          # after Fraud Check
after_II = PetriNet.Place(name="after_II")          # after In-depth Investigation
after_CA = PetriNet.Place(name="after_CA")          # after Claim Assessment
after_AP = PetriNet.Place(name="after_AP")          # after Approval
after_P = PetriNet.Place(name="after_P")            # after Payment
after_N = PetriNet.Place(name="after_N")            # after Notification
end = PetriNet.Place(name="end")                    # final state

# Add places to the net
places = [
    start, after_CR, after_DV, after_RDS, after_FC, after_II,
    after_CA, after_AP, after_P, after_N, end
]
for p in places:
    net.places.add(p)

# --- Define Transitions (with labels as activity names) ---
CR = PetriNet.Transition(name="t_CR", label="Claim Registration")
DV = PetriNet.Transition(name="t_DV", label="Document Verification")
RDS = PetriNet.Transition(name="t_RDS", label="Re-Document Submission")
FC = PetriNet.Transition(name="t_FC", label="Fraud Check")
II = PetriNet.Transition(name="t_II", label="In-depth Investigation")
CA = PetriNet.Transition(name="t_CA", label="Claim Assessment")
AP = PetriNet.Transition(name="t_AP", label="Approval")
P = PetriNet.Transition(name="t_P", label="Payment")
N = PetriNet.Transition(name="t_N", label="Notification")
CL = PetriNet.Transition(name="t_CL", label="Closure")

# Add transitions to the net
transitions = [CR, DV, RDS, FC, II, CA, AP, P, N, CL]
for t in transitions:
    net.transitions.add(t)

# --- Add Arcs (Flow) ---

# Main flow
petri_utils.add_arc_from_to(start, CR, net)
petri_utils.add_arc_from_to(CR, after_CR, net)

petri_utils.add_arc_from_to(after_CR, DV, net)
petri_utils.add_arc_from_to(DV, after_DV, net)

# Document Verification loop: if incomplete  RDS  back to DV
petri_utils.add_arc_from_to(after_DV, RDS, net)   # RDS only if needed
petri_utils.add_arc_from_to(RDS, after_RDS, net)
petri_utils.add_arc_from_to(after_RDS, DV, net)   # loop back to DV

# Proceed from DV to FC (only when documents are complete)
# We assume a token proceeds from after_DV to FC when no rework is needed
petri_utils.add_arc_from_to(after_DV, FC, net)
petri_utils.add_arc_from_to(FC, after_FC, net)

# Fraud Check loop: if doubts  II  back to FC
petri_utils.add_arc_from_to(after_FC, II, net)    # II only if needed
petri_utils.add_arc_from_to(II, after_II, net)
petri_utils.add_arc_from_to(after_II, FC, net)    # loop back to FC

# Proceed from FC to CA (only when no further investigation needed)
petri_utils.add_arc_from_to(after_FC, CA, net)
petri_utils.add_arc_from_to(CA, after_CA, net)

# Approval (only if needed; for simplicity, we assume it's always present after CA)
petri_utils.add_arc_from_to(after_CA, AP, net)
petri_utils.add_arc_from_to(AP, after_AP, net)

# Payment
petri_utils.add_arc_from_to(after_AP, P, net)
petri_utils.add_arc_from_to(P, after_P, net)

# Notification
petri_utils.add_arc_from_to(after_P, N, net)
petri_utils.add_arc_from_to(N, after_N, net)

# Closure
petri_utils.add_arc_from_to(after_N, CL, net)
petri_utils.add_arc_from_to(CL, end, net)

# --- Define Initial and Final Markings ---
im = Marking()
im[start] = 1

fm = Marking()
fm[end] = 1

# Now `net`, `im`, and `fm` define the accepting Petri net.
```

---

###  Notes on Loops

- **Document Re-submission Loop**:  
  After `DV`, if documents are incomplete, the token can go through `RDS` and loop back to `DV`. This is modeled by having **two outgoing arcs from `after_DV`**: one to `FC` (normal path) and one to `RDS` (rework path).  
  >  In a real executable net, you'd need **choice semantics** (e.g., via silent transitions or guards). For modeling purposes in `pm4py`, this structure is acceptable as a **workflow net with optional loops**.

- **In-depth Investigation Loop**:  
  Similarly, after `FC`, a token can either proceed to `CA` or enter `II` and loop back to `FC`.

>  **Important**: This net is **not** a *free-choice* net due to shared input places for choices, but it correctly captures the described process logic for analysis and simulation in `pm4py`.

---

###  Result

- **Initial marking**: token in `start`  new claim arrives.
- **Final marking**: token in `end`  claim closed and archived.
- All activities are transitions with proper labels.
- Optional rework loops are included.

This Petri net can be used for conformance checking, simulation, or process mining tasks with `pm4py`.