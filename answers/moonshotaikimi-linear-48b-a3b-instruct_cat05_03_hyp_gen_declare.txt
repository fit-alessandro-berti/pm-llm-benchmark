## Anomalies Identified in the DECLARE Model

### 1. **Deadlock-Creating Contradiction**
- **Precedence Rule**: `C` must follow `R`
- **Non-coexistence Rule**: `E` cannot coexist with `C`
- **Responded Existence Rule**: `E` requires `A` before it
- **Contradiction**: A claim could be evaluated (`E`) before being received (`R`) OR closed (`C`) before being evaluated (`E`) - both violate the response existence rule.

### 2. **Impossible Execution Path**
- A claim could transition: `R`  `A`  `C` (skipping both `E` and `N`)
- The precedence rule incorrectly links `C` to `R` instead of verifying if evaluation happened first

### 3. **Missing Required Conditions**
- No constraints ensure:
  - An adjuster is assigned before evaluation
  - Evaluation has required specialized knowledge
  - Adequate justification exists before approval

### 4. **Violation of Exception Logic**
- The model allows closing without evaluation completion - contradicting standard insurance practices

## Hypotheses for Anomaly Causes

### 1. **Data Quality Issues**
- Historical cleaning created invalid event sequences that must still be honored
- Incomplete event tracking initially, with corrections applied retroactively

### 2. **Process Variation**
- Different claim categories have conflicting designated paths
- Exceptions handling overrode formal model constraints

### 3. **Legacy System Migration**
- Rules migrated from old system without validation of consistency
- Timing requirements changed, but precedence rules remained

### 4. **Compliance vs. Flexibility Trade-offs**
- Model allows "close claim without evaluation" to handle quick approvals or bad-faith claims
- Business requirements prioritized speed over completeness

---

## SQL Investigation Strategies

### 1. **Claims Closed Without Evaluation**
```sql
-- Find claims whose last event is 'C' but have no 'E' event
WITH last_events AS (
    SELECT claim_id,
           MAX(timestamp) as last_timestamp,
           MAX(CASE WHEN activity = 'C' THEN timestamp END) as close_time,
           MAX(CASE WHEN activity = 'E' THEN timestamp END) as evaluate_time
    FROM claim_events
    GROUP BY claim_id
)
SELECT le.*
FROM last_events le
LEFT JOIN claims ON claims.claim_id = le.claim_id
WHERE le.close_time IS NOT NULL 
  AND le.evaluate_time IS NULL
  AND le.last_timestamp = le.close_time;
```

### 2. **Evaluation Without Prior Assignment**
```sql
-- Find claims evaluated without being assigned to an adjuster first
SELECT ce.*
FROM claim_events ce
WHERE ce.activity = 'E'
  AND NOT EXISTS (
      SELECT 1 
      FROM claim_events ce2 
      WHERE ce2.claim_id = ce.claim_id 
        AND ce2.activity = 'A' 
        AND ce2.timestamp < ce.timestamp
  )
ORDER BY ce.claim_id, ce.timestamp;
```

### 3. **Concurrent Evaluation and Closing**
```sql
-- Find claims with both E and C activities in sequence
WITH claim_sequences AS (
    SELECT claim_id,
           STRING_AGG(activity ORDER BY timestamp) as activity_sequence
    FROM claim_events
    GROUP BY claim_id
)
SELECT claim_id, activity_sequence
FROM claim_sequences
WHERE activity_sequence LIKE '%EC%' 
   OR activity_sequence LIKE '%AC%'
   OR activity_sequence LIKE '%E%C%'
ORDER BY claim_id;
```

### 4. **Adjuster Assignment Verification**
```sql
-- Find claims where evaluation was performed by adjusters without proper specialization
SELECT ce.*, a.specialization
FROM claim_events ce
INNER JOIN claims c ON c.claim_id = ce.claim_id
LEFT JOIN adjusters a ON a.name = ce.resource 
WHERE ce.activity = 'E'
  AND a.specialization != c.claim_type;
```

### 5. **Missing Notification Before Closing**
```sql
-- Find claims closed without prior notification (N activity)
SELECT c.*
FROM claims c
WHERE NOT EXISTS (
    SELECT 1 
    FROM claim_events ce 
    WHERE ce.claim_id = c.claim_id 
      AND ce.activity = 'N'
)
  AND EXISTS (
    SELECT 1 
    FROM claim_events ce2 
    WHERE ce2.claim_id = c.claim_id 
      AND ce2.activity = 'A'
  );
```

### 6. **Process Flow Validation**
```sql
-- Find claims where sequence deviates from R->A->E->P->N->C
WITH claim_events_sorted AS (
    SELECT claim_id,
           activity,
           timestamp,
           ROW_NUMBER() OVER (PARTITION BY claim_id ORDER BY timestamp) as order_num
    FROM claim_events
),
ordered_claims AS (
    SELECT claim_id, 
           STRING_AGG(activity ORDER BY order_num) as full_sequence
    FROM claim_events_sorted 
    GROUP BY claim_id
)
SELECT c.claim_id, c.claim_type, o.full_sequence
FROM claims c
INNER JOIN ordered_claims o ON o.claim_id = c.claim_id
WHERE NOT (
    o.full_sequence LIKE 'R%A%E%P%N%C%' 
    AND o.full_sequence NOT LIKE '%CC%' 
    AND o.full_sequence NOT LIKE '%EE%'
);
```

These queries will help identify whether the anomalous constraints in the DECLARE model actually manifest in the operational data, providing concrete evidence for validating or refuting the model's effectiveness.