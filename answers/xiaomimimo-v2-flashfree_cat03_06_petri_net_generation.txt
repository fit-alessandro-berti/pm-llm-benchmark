Of course. Here is the Python code to construct an accepting Petri net for the described insurance claim management process.

The Petri net is designed to capture the sequential flow and the potential loops for re-submission and in-depth investigation. The structure includes:

1.  **Places**: Representing the states before and after each activity.
2.  **Transitions**: Representing the activities themselves.
3.  **Arcs**: Connecting places to transitions and vice-versa to define the flow.
4.  **Loops**:
    *   A loop for **Document Verification (DV)** to **Re-Document Submission (RDS)** and back, modeling the re-submission process.
    *   A loop for **Fraud Check (FC)** to **In-depth Investigation (II)** and back, allowing for multiple rounds of investigation.
5.  **Initial Marking**: A single token in the `Start` place, signifying the arrival of a new claim.
6.  **Final Marking**: A single token in the `Closed` place, signifying a successfully processed and closed claim.

### Python Code for Petri Net Construction

```python
from pm4py.objects.petri_net.obj import PetriNet, Marking
from pm4py.objects.petri_net.utils import petri_utils

def create_insurance_claim_net():
    """
    Constructs an accepting Petri net for the insurance claim management process.
    
    The process includes sequential activities and loops for document re-submission
    and in-depth fraud investigation.

    Returns:
        tuple: A tuple containing (net, initial_marking, final_marking).
    """
    # 1. Create a Petri Net object
    net = PetriNet(name="Insurance Claim Management Process")

    # 2. Define the Places (states)
    # We create a place for each state in the process
    p_start = PetriNet.Place(name="Start")
    p_claim_registered = PetriNet.Place(name="Claim_Registered")
    p_docs_verified = PetriNet.Place(name="Docs_Verified")
    p_fraud_check_ok = PetriNet.Place(name="Fraud_Check_OK")
    p_claim_assessed = PetriNet.Place(name="Claim_Assessed")
    p_approved = PetriNet.Place(name="Approved")
    p_paid = PetriNet.Place(name="Paid")
    p_notified = PetriNet.Place(name="Notified")
    p_closed = PetriNet.Place(name="Closed")
    
    # Places for loops
    p_docs_to_resubmit = PetriNet.Place(name="Docs_To_Resubmit")
    p_investigation_needed = PetriNet.Place(name="Investigation_Needed")

    # Add all places to the net
    places = [p_start, p_claim_registered, p_docs_verified, p_fraud_check_ok, 
              p_claim_assessed, p_approved, p_paid, p_notified, p_closed, 
              p_docs_to_resubmit, p_investigation_needed]
    for place in places:
        net.places.add(place)

    # 3. Define the Transitions (activities)
    t_cr = PetriNet.Transition(name="cr", label="Claim Registration")
    t_dv = PetriNet.Transition(name="dv", label="Document Verification")
    t_fc = PetriNet.Transition(name="fc", label="Fraud Check")
    t_ca = PetriNet.Transition(name="ca", label="Claim Assessment")
    t_ap = PetriNet.Transition(name="ap", label="Approval")
    t_p = PetriNet.Transition(name="p", label="Payment")
    t_n = PetriNet.Transition(name="n", label="Notification")
    t_cl = PetriNet.Transition(name="cl", label="Closure")
    
    # Transitions for loops
    t_rds = PetriNet.Transition(name="rds", label="Re-Document Submission")
    t_ii = PetriNet.Transition(name="ii", label="In-depth Investigation")

    # Add all transitions to the net
    transitions = [t_cr, t_dv, t_fc, t_ca, t_ap, t_p, t_n, t_cl, t_rds, t_ii]
    for transition in transitions:
        net.transitions.add(transition)

    # 4. Define the Arcs (connectivity)
    # Main process flow
    petri_utils.add_arc_from_to(p_start, t_cr, net)
    petri_utils.add_arc_from_to(t_cr, p_claim_registered, net)
    
    petri_utils.add_arc_from_to(p_claim_registered, t_dv, net)
    petri_utils.add_arc_from_to(t_dv, p_docs_verified, net)
    
    petri_utils.add_arc_from_to(p_docs_verified, t_fc, net)
    petri_utils.add_arc_from_to(t_fc, p_fraud_check_ok, net)
    
    petri_utils.add_arc_from_to(p_fraud_check_ok, t_ca, net)
    petri_utils.add_arc_from_to(t_ca, p_claim_assessed, net)
    
    petri_utils.add_arc_from_to(p_claim_assessed, t_ap, net)
    petri_utils.add_arc_from_to(t_ap, p_approved, net)
    
    petri_utils.add_arc_from_to(p_approved, t_p, net)
    petri_utils.add_arc_from_to(t_p, p_paid, net)
    
    petri_utils.add_arc_from_to(p_paid, t_n, net)
    petri_utils.add_arc_from_to(t_n, p_notified, net)
    
    petri_utils.add_arc_from_to(p_notified, t_cl, net)
    petri_utils.add_arc_from_to(t_cl, p_closed, net)
    
    # Loop 1: Document Re-submission (DV -> RDS -> DV)
    petri_utils.add_arc_from_to(p_docs_verified, t_rds, net)
    petri_utils.add_arc_from_to(t_dv, p_docs_to_resubmit, net) # Alternative path from DV
    petri_utils.add_arc_from_to(p_docs_to_resubmit, t_rds, net)
    petri_utils.add_arc_from_to(t_rds, p_claim_registered, net) # Loop back to after CR
    
    # Loop 2: In-depth Investigation (FC -> II -> FC)
    petri_utils.add_arc_from_to(p_fraud_check_ok, t_ii, net)
    petri_utils.add_arc_from_to(t_fc, p_investigation_needed, net) # Alternative path from FC
    petri_utils.add_arc_from_to(p_investigation_needed, t_ii, net)
    petri_utils.add_arc_from_to(t_ii, p_docs_verified, net) # Loop back to after DV

    # 5. Define Markings
    # Initial marking: one token in the start place
    im = Marking()
    im[p_start] = 1

    # Final marking: one token in the closed place
    fm = Marking()
    fm[p_closed] = 1

    return net, im, fm

# --- Main execution ---
if __name__ == "__main__":
    # Create the accepting Petri net
    net, initial_marking, final_marking = create_insurance_claim_net()

    # Print the properties of the constructed net
    print(f"Petri Net Name: {net.name}")
    print(f"Number of Places: {len(net.places)}")
    print(f"Number of Transitions: {len(net.transitions)}")
    print("\nInitial Marking (Tokens in places):")
    for place, tokens in initial_marking.items():
        print(f"  - Place '{place.name}': {tokens} token(s)")
    
    print("\nFinal Marking (Tokens in places):")
    for place, tokens in final_marking.items():
        print(f"  - Place '{place.name}': {tokens} token(s)")

    # A simple verification to show the net structure is valid
    # (e.g., all places and transitions in markings are part of the net)
    is_valid = all(p in net.places for p in initial_marking.keys()) and \
               all(p in net.places for p in final_marking.keys())
    
    print(f"\nPetri Net Validity (All marked places exist in the net): {is_valid}")
```