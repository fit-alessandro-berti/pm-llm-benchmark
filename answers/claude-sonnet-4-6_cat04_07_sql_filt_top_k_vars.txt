# DuckDB SQL Query: Top K Process Variants Filter

## Approach

I'll build this step-by-step using CTEs for clarity and correctness:

1. **Build ordered activity sequences** per case using `LIST` aggregate with `ORDER BY`
2. **Count cases per variant** to identify frequencies
3. **Rank variants** by frequency to find top K
4. **Filter original events** to only include cases from top K variants

## SQL Query

```sql
-- Set K value (replace 5 with desired number of top variants)
WITH 

-- Step 1: Build the ordered activity sequence for each case
case_variants AS (
    SELECT
        case_id,
        LIST(activity ORDER BY timestamp) AS activity_sequence
    FROM
        event_log
    GROUP BY
        case_id
),

-- Step 2: Count how many cases share each unique activity sequence (variant)
variant_counts AS (
    SELECT
        activity_sequence,
        COUNT(case_id)      AS case_count,
        LIST(case_id)       AS case_ids   -- optional: track which cases belong here
    FROM
        case_variants
    GROUP BY
        activity_sequence
),

-- Step 3: Rank variants by frequency and keep only Top K
top_k_variants AS (
    SELECT
        activity_sequence,
        case_count,
        ROW_NUMBER() OVER (ORDER BY case_count DESC) AS variant_rank
    FROM
        variant_counts
    QUALIFY
        variant_rank <= 5   -- << substitute K here
),

-- Step 4: Identify which case_ids belong to a Top K variant
filtered_cases AS (
    SELECT
        cv.case_id
    FROM
        case_variants   cv
    INNER JOIN
        top_k_variants  tkv
        ON cv.activity_sequence = tkv.activity_sequence
)

-- Step 5: Return all original events for the filtered cases
SELECT
    el.case_id,
    el.activity,
    el.timestamp
FROM
    event_log       el
INNER JOIN
    filtered_cases  fc
    ON el.case_id = fc.case_id
ORDER BY
    el.case_id,
    el.timestamp;
```

## Step-by-Step Explanation

| CTE | Purpose |
|-----|---------|
| `case_variants` | Uses `LIST(activity ORDER BY timestamp)` to produce an **ordered array** representing each case's process path |
| `variant_counts` | Groups identical sequences  counts how many cases follow each variant |
| `top_k_variants` | Ranks variants by `case_count DESC`, retains only rank  K using `QUALIFY` |
| `filtered_cases` | Joins back to `case_variants` to recover the `case_id`s belonging to top K variants |
| Final `SELECT` | Returns **all original event rows** for those case IDs |

## Key DuckDB-Specific Features Used

```sql
-- Ordered list aggregation (DuckDB native syntax)
LIST(activity ORDER BY timestamp)

-- QUALIFY clause for inline window-function filtering (cleaner than a subquery)
QUALIFY ROW_NUMBER() OVER (ORDER BY case_count DESC) <= K

-- Array equality comparison used in the JOIN
ON cv.activity_sequence = tkv.activity_sequence  -- DuckDB supports LIST/array equality
```

## Tie-Handling Note

> Using `ROW_NUMBER()` means ties at the K-th boundary are **broken arbitrarily**.  
> Replace with `DENSE_RANK()` if you want *all* variants tied at rank K to be included:

```sql
-- Inclusive tie-handling alternative
QUALIFY DENSE_RANK() OVER (ORDER BY case_count DESC) <= 5
```