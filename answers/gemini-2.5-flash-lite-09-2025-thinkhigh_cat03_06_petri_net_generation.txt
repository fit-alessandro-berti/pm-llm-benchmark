This scenario requires careful modeling of sequential steps, optional loops (RDS), and repeatable optional investigations (II). We will define the Petri Net structure using intermediate places to accurately represent the state *before* and *after* critical decision points.

### Petri Net Structure Definition

**Places (States):**
| Name | Description |
| :--- | :--- |
| P0 | Start (New Claim Arrived) |
| P1 | After Claim Registration (Ready for DV) |
| P2 | After Document Verification (Ready for FC or RDS) |
| P3 | After Fraud Check (Ready for CA or II loop) |
| P4 | After Claim Assessment (Ready for Approval) |
| P5 | After Approval (Ready for Payment) |
| P6 | After Payment (Ready for Notification) |
| P7 | After Notification (Ready for Closure) |
| P8 | Final State (Claim Closed) |

**Transitions (Activities):**
| Name | Label (Activity) |
| :--- | :--- |
| T_CR | Claim Registration |
| T_DV | Document Verification |
| T_RDS | Re-Document Submission |
| T_FC | Fraud Check (Successful path continuation) |
| T_II | In-depth Investigation (Loop transition) |
| T_CA | Claim Assessment |
| T_AP | Approval |
| T_P | Payment |
| T_N | Notification |

### Python Implementation

```python
from pm4py.objects.petri_net.obj import PetriNet, Marking
from pm4py.objects.petri_net.utils import petri_utils

# 1. Initialize the Petri Net
net = PetriNet(name="Insurance_Claim_Management")

# 2. Define Places (P0 to P8)
P0 = PetriNet.Place(name="P_Start")
P1 = PetriNet.Place(name="P_CR_Done")
P2 = PetriNet.Place(name="P_DV_Done")
P3 = PetriNet.Place(name="P_FC_Done")
P4 = PetriNet.Place(name="P_CA_Done")
P5 = PetriNet.Place(name="P_AP_Done")
P6 = PetriNet.Place(name="P_P_Done")
P7 = PetriNet.Place(name="P_N_Done")
P8 = PetriNet.Place(name="P_End")

net.places.add(P0)
net.places.add(P1)
net.places.add(P2)
net.places.add(P3)
net.places.add(P4)
net.places.add(P5)
net.places.add(P6)
net.places.add(P7)
net.places.add(P8)

# 3. Define Transitions (T)
T_CR = PetriNet.Transition(name="T_CR", label="Claim Registration")
T_DV = PetriNet.Transition(name="T_DV", label="Document Verification")
T_RDS = PetriNet.Transition(name="T_RDS", label="Re-Document Submission")
T_FC = PetriNet.Transition(name="T_FC", label="Fraud Check") # Represents proceeding from DV to FC
T_II = PetriNet.Transition(name="T_II", label="In-depth Investigation")
T_CA = PetriNet.Transition(name="T_CA", label="Claim Assessment")
T_AP = PetriNet.Transition(name="T_AP", label="Approval")
T_P = PetriNet.Transition(name="T_P", label="Payment")
T_N = PetriNet.Transition(name="T_N", label="Notification")

net.transitions.add(T_CR)
net.transitions.add(T_DV)
net.transitions.add(T_RDS)
net.transitions.add(T_FC)
net.transitions.add(T_II)
net.transitions.add(T_CA)
net.transitions.add(T_AP)
net.transitions.add(T_P)
net.transitions.add(T_N)

# 4. Add Arcs defining the flow

# Sequence Start: P0 -> CR -> P1
petri_utils.add_arc_from_to(P0, T_CR, net)
petri_utils.add_arc_from_to(T_CR, P1, net)

# Step 2: DV and RDS Loop
# P1 -> DV -> P2 (If documents verified successfully enough to proceed)
petri_utils.add_arc_from_to(P1, T_DV, net)
petri_utils.add_arc_from_to(T_DV, P2, net) 
# P2 -> RDS -> P1 (If verification fails, loop back to P1 for re-submission prep)
petri_utils.add_arc_from_to(P2, T_RDS, net)
petri_utils.add_arc_from_to(T_RDS, P1, net)

# Step 3: FC and II Loop (Assuming successful DV leads to FC via T_FC transition)
# P1 -> FC -> P3 (If DV was successful, we proceed to FC logic from P1/P2 context. 
# We use P1 -> T_FC -> P3 to imply that after successful verification work is done, we trigger FC)
# *Refinement for strict flow:* We must ensure FC only happens AFTER DV success (P2). 
# Let's modify the interpretation: If P2 enables T_FC, it means success.
petri_utils.add_arc_from_to(P2, T_FC, net) # P2 enables FC transition if DV was successful
petri_utils.add_arc_from_to(T_FC, P3, net) 

# P3 -> II -> P3 (In-depth Investigation Loop: token cycles back to re-evaluate/repeat II)
petri_utils.add_arc_from_to(P3, T_II, net)
petri_utils.add_arc_from_to(T_II, P3, net)

# P3 -> CA (Proceeding to Assessment after checks clear)
petri_utils.add_arc_from_to(P3, T_CA, net) # Transition used for clearing FC/II stage
petri_utils.add_arc_from_to(T_CA, P4, net)

# Steps 4-8: The final sequence
# P4 -> CA -> P5
petri_utils.add_arc_from_to(P4, T_AP, net)
petri_utils.add_arc_from_to(T_AP, P5, net)

# P5 -> Payment -> P6
petri_utils.add_arc_from_to(P5, T_P, net)
petri_utils.add_arc_from_to(T_P, P6, net)

# P6 -> Notification -> P7
petri_utils.add_arc_from_to(P6, T_N, net)
petri_utils.add_arc_from_to(T_N, P7, net)

# P7 -> Closure -> P8 (End)
# We need one final transition for Closure (CL) which wasn't explicitly named in the T list,
# but is implied by the process end. Let's reuse T_N label for simplicity if CL happens immediately after N, 
# or define a final transition T_CL. We will define T_CL for clarity.

T_CL = PetriNet.Transition(name="T_CL", label="Closure")
net.transitions.add(T_CL)

petri_utils.add_arc_from_to(P7, T_CL, net)
petri_utils.add_arc_from_to(T_CL, P8, net)


# 5. Define Initial Marking (im)
im = Marking()
im[P0] = 1  # Start with one token in the Initial State

# 6. Define Final Marking (fm)
fm = Marking()
fm[P8] = 1  # End state is reached when token is in P8 (Closed)

# Verification Output (Optional print statements to show structure)
print(f"Petri Net '{net.name}' constructed successfully.")
print(f"Number of Places: {len(net.places)}")
print(f"Number of Transitions: {len(net.transitions)}")
print(f"Initial Marking: {im}")
print(f"Final Marking: {fm}")
```