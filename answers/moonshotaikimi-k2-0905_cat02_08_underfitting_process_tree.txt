Example of a trace that the model happily calls “fitting” but that no sensible cash-handling process would ever allow:

```
<Receive_Order, Check_Inventory, Authorize_Payment, Package_Items, Ship_Order, Close_Order, Cancel_Order>
```

Why the model says “yes”  
- The only hard precedence rules encoded are:
  - Receive_Order  Check_Inventory,
  - (Authorize_Payment, Package_Items, Ship_Order) must all appear after Check_Inventory,
  - Cancel_Order must be followed immediately by Close_Order (cancel branch).  
- Because all activities that belong to the mutually exclusive XOR branches are still kept under the global root “ close_order  …”, nothing stops the final two activities “Close_Order, Cancel_Order” from being appended after the three parallel ones.  
- In other words, the tree is built as:  

```
 (Receive_Order, Check_Inventory, XOR( PARALLEL(AP,PI,SO), (Cancel,Close) ), Close )
```

The outer SEQUENCE with its last child “Close_Order” is *obligatory*, so a second Close_Order or any residual activity that technically lies on an alternative branch can simply be tagged on afterwards. The pm4py semantics of an XOR is only “one of the two direct sub-trees is executed once”, not “no activity of the other branch may ever occur anywhere in the trace”.

Why this is nonsense in the real world  
Having already shipped the goods (and therefore, by implication, irrevocably released the inventory and activated the payment obligation), the process suddenly “cancels” the order. Legally and operationally the order cannot be cancelled any more once the shipment has left the warehouse; doing so would at best be a return, not a cancellation. The model nevertheless treats the trace as perfectly valid, which is exactly the under-fitting problem described.