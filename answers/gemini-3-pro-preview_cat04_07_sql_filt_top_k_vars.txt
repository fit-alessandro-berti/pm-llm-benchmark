Here is the DuckDB SQL query to perform the requested task.

In this query, replace `5` with your desired value for **K** in the `LIMIT` clause within the `top_k_variants` CTE.

```sql
WITH case_sequences AS (
    -- 1. Determine the sequence of activities (variant) for each case
    -- We use list() to create an array of activities ordered by timestamp
    SELECT 
        case_id,
        list(activity ORDER BY timestamp ASC) AS variant_sequence
    FROM event_log
    GROUP BY case_id
),
variant_stats AS (
    -- 2. Group by the specific sequence to count how many cases follow it
    SELECT 
        variant_sequence,
        COUNT(*) AS case_count
    FROM case_sequences
    GROUP BY variant_sequence
),
top_k_variants AS (
    -- 3. Determine the Top K variants by frequency
    SELECT 
        variant_sequence
    FROM variant_stats
    ORDER BY case_count DESC
    LIMIT 5 -- <--- Replace 5 with your specific K value
)
-- 4. Return all events from the original log belonging to cases in the Top K variants
SELECT 
    el.case_id,
    el.activity,
    el.timestamp
FROM event_log el
-- Join to associate the case_id with its calculated variant
JOIN case_sequences cs 
    ON el.case_id = cs.case_id
-- Join to filter only those variants that exist in our Top K list
JOIN top_k_variants tkv 
    ON cs.variant_sequence = tkv.variant_sequence
ORDER BY 
    el.case_id, 
    el.timestamp;
```

### Explanation of Steps

1.  **`case_sequences` CTE**: We group the raw data by `case_id` and use DuckDB's native `list()` aggregation function. By specifying `ORDER BY timestamp ASC` inside the list function, we ensure the resulting array (e.g., `['Start', 'Check', 'End']`) accurately represents the chronological process variant.
2.  **`variant_stats` CTE**: We group the results from the previous step by the generated list (`variant_sequence`) to count how many unique cases share that exact same path.
3.  **`top_k_variants` CTE**: We sort the unique variants by their frequency (descending) and keep only the top **K** rows.
4.  **Final SELECT**: We join the original `event_log` table against the calculated sequences and the top K filter list. This ensures we output the raw event rows (id, activity, timestamp) but only for the cases that fall within the most frequent variants.