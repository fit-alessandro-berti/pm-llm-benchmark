```python
from pm4py.objects.petri_net.obj import PetriNet, Marking
from pm4py.objects.petri_net.utils import petri_utils

# Create the Petri net
net = PetriNet(name="insurance_claim_management")

# Define places for the process flow
start = PetriNet.Place(name="start")                      # Entry point
registered = PetriNet.Place(name="registered")            # CR: Claim Registered
documents_received = PetriNet.Place(name="documents_received")  # DV: Doc verified, claim valid
fraud_check = PetriNet.Place(name="fraud_check")          # FC: In fraud check
fraud_clear = PetriNet.Place(name="fraud_clear")          # FC cleared
assessment = PetriNet.Place(name="assessment")            # CA: Claim assessed
decision_extra = PetriNet.Place(name="decision_extra")    # Split for extra checks
approval = PetriNet.Place(name="approval")                # AP: Approved by manager
payment = PetriNet.Place(name="payment")                  # P: Payment made
notification = PetriNet.Place(name="notification")        # N: Customer notified
decision_closure = PetriNet.Place(name="decision_closure") # Split to close
closed = PetriNet.Place(name="closed")                    # CL: Claim closed
success = PetriNet.Place(name="success")                  # Coincident gateway after closure

# Places for extra flows
re_doc_submission = PetriNet.Place(name="re_doc_submission") # RDS: Re-submission
in_depth_investigation = PetriNet.Place(name="in_depth_investigation") # II: Investigation

# Create transitions for process activities
register_claim = PetriNet.Transition(name="register_claim", label="Claim Registration")
verify_documents = PetriNet.Transition(name="verify_documents", label="Document Verification")
fraud_check_trans = PetriNet.Transition(name="fraud_check", label="Fraud Check")
indepth_investigation = PetriNet.Transition(name="indepth_investigation", label="In-depth Investigation")
assess_claim = PetriNet.Transition(name="assess_claim", label="Claim Assessment")
decision_above_threshold = PetriNet.Transition(name="decision_above_threshold", label="Threshold Decision")
approve_claim = PetriNet.Transition(name="approve_claim", label="Approval")
process_payment = PetriNet.Transition(name="process_payment", label="Payment")
notify_customer = PetriNet.Transition(name="notify_customer", label="Notification")
decision_closure_transition = PetriNet.Transition(name="decision_closure", label="Closure Decision")
finalize_claim = PetriNet.Transition(name="finalize_claim", label="Closure")

# Create transitions for loops
re_submit = PetriNet.Transition(name="re_submit", label="Re-Document Submission")
reinvestigate = PetriNet.Transition(name="reinvestigate", label="Re-investigate")

# Add all elements to the net
net.places.update([start, registered, documents_received, fraud_check, fraud_clear,
                   assessment, decision_extra, approval, payment, notification,
                   decision_closure, closed, success, re_doc_submission, in_depth_investigation])
net.transitions.update([register_claim, verify_documents, fraud_check_trans, indepth_investigation,
                        assess_claim, decision_above_threshold, approve_claim, process_payment,
                        notify_customer, decision_closure_transition, finalize_claim,
                        re_submit, reinvestigate])

# Add arcs for main flow
petri_utils.add_arc_from_to(start, register_claim, net)
petri_utils.add_arc_from_to(register_claim, registered, net)
petri_utils.add_arc_from_to(registered, verify_documents, net)
petri_utils.add_arc_from_to(verify_documents, documents_received, net)

# Main fraud path
petri_utils.add_arc_from_to(documents_received, fraud_check_trans, net)
petri_utils.add_arc_from_to(fraud_check_trans, fraud_check, net)
petri_utils.add_arc_from_to(fraud_check, fraud_clear, net)

# Normal path: fraud cleared leads to assessment
petri_utils.add_arc_from_to(fraud_clear, assess_claim, net)

# Investigation loop
petri_utils.add_arc_from_to(assess_claim, decision_extra, net)
petri_utils.add_arc_from_to(decision_extra, indepth_investigation, net)
petri_utils.add_arc_from_to(indepth_investigation, fraud_check, net)

# Approval path
petri_utils.add_arc_from_to(decision_extra, approval, net)
petri_utils.add_arc_from_to(approval, process_payment, net)

# Payment and notification flow
petri_utils.add_arc_from_to(process_payment, notification, net)
petri_utils.add_arc_from_to(notification, decision_closure_transition, net)
petri_utils.add_arc_from_to(decision_closure_transition, closed, net)
petri_utils.add_arc_from_to(closed, success, net)

# Re-submission loop from verification
petri_utils.add_arc_from_to(verify_documents, re_doc_submission, net)
petri_utils.add_arc_from_to(re_doc_submission, verify_documents, net)

# Re-investigation loop from assessment
petri_utils.add_arc_from_to(assess_claim, decision_extra, net)  # Already added above
# Actually, we re-use the existing split to lead to both re-investigation and continue
# We'll add a direct path back to decision_extra for re-investigation:
petri_utils.add_arc_from_to(fraud_clear, analyze_decision, net)  # This place now handles both paths

# We need to adjust the flow to make re-investigation a loop:
# Simpler: immediately after assessment, we have decision whether to re-investigate
# Let's restructure quickly:

# We'll create a new place for assessment decision and rework arcs slightly:
net.places.remove(decision_extra)
assessment_decision = PetriNet.Place(name="assessment_decision")
net.places.add(assessment_decision)
# Re-route arcs:
petri_utils.add_arc_from_to(fraud_clear, assess_claim, net)        # fraud clear -> assess
petri_utils.add_arc_from_to(assess_claim, assessment_decision, net) # assess -> decision
petri_utils.add_arc_from_to(assessment_decision, indepth_investigation, net) # decision -> reinvestigate
petri_utils.add_arc_from_to(assessment_decision, approval, net)         # decision -> approve

# Also need to handle re-submission at verification stage
petri_utils.add_arc_from_to(verify_documents, re_doc_submission, net)
petri_utils.add_arc_from_to(re_doc_submission, verify_documents, net)

# Final adjustment: ensure closure path
petri_utils.add_arc_from_to(success, finalize_claim, net)
petri_utils.add_arc_from_to(finalize_claim, closed, net)

# Define initial and final markings
im = Marking()
im[start] = 1

fm = Marking()
fm[success] = 1  # Arbitrary token to indicate successful completion
fm[closed] = 1   # Ensure closed is marked - we'll use success as final, but also mark closed
# We can mark both for explicit final marking
im[success] = 0  # Ensure not preset incorrectly in fm
fm[closed] = 1
fm[success] = 1

print("Accepting Petri net constructed successfully.")
print("Initial marking:", {k: v for k, v in im.items()})
print("Final marking:", {k: v for k, v in fm.items()})
```