```python
log_skeleton = {
    'equivalence': set(),
    'always_before': {
        ('RO', 'CA'),
        ('CA', 'RI'),
        ('RI', 'PI'),
        ('PI', 'QC'),
        ('QC', 'PO'),
        ('PO', 'GSL'),
        ('GSL', 'D'),
        ('RO', 'IC'),  # Invoice can only be generated after order is received
        ('IC', 'RP'),  # Payment recorded only after invoice is sent
        ('PO', 'IC'),  # Typically, invoicing happens after packing (order details finalized)
    },
    'always_after': {
        ('CA', 'RO'),
        ('RI', 'CA'),
        ('PI', 'RI'),
        ('QC', 'PI'),
        ('PO', 'QC'),
        ('GSL', 'PO'),
        ('D', 'GSL'),
        ('IC', 'RO'),
        ('RP', 'IC'),
        ('IC', 'PO'),
    },
    'never_together': set(),
    'activ_freq': {
        'RO': {1},
        'CA': {1},
        'RI': {1},
        'PI': {1},
        'QC': {1},
        'PO': {1},
        'GSL': {1},
        'D': {1},
        'IC': {1},
        'RP': {0, 1},  # Payment may not be recorded yet in the log (e.g., pending payment)
    },
    'directly_follows': {
        # In many standard implementations, certain steps are tightly coupled.
        # However, in a real-world log, there might be intermediate system events or parallel tasks.
        # For this scenario, we assume a streamlined process with minimal gaps.
        # We conservatively define only the most rigidly enforced immediate sequences.
        ('PO', 'GSL'),   # Packing is immediately followed by label generation
        ('GSL', 'D'),    # Label generation is immediately followed by dispatch
    }
}
```