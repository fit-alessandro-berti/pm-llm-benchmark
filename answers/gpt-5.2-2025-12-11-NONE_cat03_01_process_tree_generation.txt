### Process tree (notation)

```
->(
  'A',
  'RG',
  'IA',
  ->('TI','TC'),
  X('CE','FBP'),
  *(
    tau,
    ->(
      'SC',
      X('TM','SPT'),
      X('FCE','FBA')
    )
  ),
  +('AI','NC'),
  ->('FAS','DDI'),
  +('BL','ICP','MRF')
)
```

Notes:
- The loop is modeled as `*(tau, body)`: you may exit immediately (normal results right after initial test) via `tau`, or repeat the `body` (SC  treatment choice  re-test choice) any number of times.
- The “Re-Diagnostic Test (RDT)” is represented structurally by the exclusive choice `X('FCE','FBA')` (i.e., the concrete re-test performed).

---

### PM4Py `ProcessTree` construction (with correct parent pointers)

```python
from pm4py.objects.process_tree.obj import ProcessTree, Operator

# Root: big sequence of all stages
root = ProcessTree(operator=Operator.SEQUENCE)

def act(label, parent):
    return ProcessTree(label=label, parent=parent)

# 1) A -> RG -> IA
A  = act("A", root)
RG = act("RG", root)
IA = act("IA", root)

# 2) Triage sequence: TI -> TC
triage_seq = ProcessTree(operator=Operator.SEQUENCE, parent=root)
TI = act("TI", triage_seq)
TC = act("TC", triage_seq)
triage_seq.children.extend([TI, TC])

# 3) Initial diagnostic: XOR(CE, FBP)
init_diag = ProcessTree(operator=Operator.XOR, parent=root)
CE  = act("CE", init_diag)
FBP = act("FBP", init_diag)
init_diag.children.extend([CE, FBP])

# 4) Loop after initial diagnostic:
#    *( tau,  SC -> XOR(TM,SPT) -> XOR(FCE,FBA) )
loop = ProcessTree(operator=Operator.LOOP, parent=root)

# A-part of loop: tau (allows immediate exit when results are normal)
tau = ProcessTree(label=None, parent=loop)  # silent step

# B-part of loop: sequence SC -> treatment_choice -> re_test_choice
loop_body = ProcessTree(operator=Operator.SEQUENCE, parent=loop)

SC = act("SC", loop_body)

treat_choice = ProcessTree(operator=Operator.XOR, parent=loop_body)
TM  = act("TM", treat_choice)
SPT = act("SPT", treat_choice)
treat_choice.children.extend([TM, SPT])

retest_choice = ProcessTree(operator=Operator.XOR, parent=loop_body)
FCE = act("FCE", retest_choice)
FBA = act("FBA", retest_choice)
retest_choice.children.extend([FCE, FBA])

loop_body.children.extend([SC, treat_choice, retest_choice])

# Attach children to loop
loop.children.extend([tau, loop_body])

# 5) Parallel: AI || NC
support_par = ProcessTree(operator=Operator.PARALLEL, parent=root)
AI = act("AI", support_par)
NC = act("NC", support_par)
support_par.children.extend([AI, NC])

# 6) Final admin sequence: FAS -> DDI
final_admin = ProcessTree(operator=Operator.SEQUENCE, parent=root)
FAS = act("FAS", final_admin)
DDI = act("DDI", final_admin)
final_admin.children.extend([FAS, DDI])

# 7) Final clearances in parallel: BL || ICP || MRF
clearances = ProcessTree(operator=Operator.PARALLEL, parent=root)
BL  = act("BL", clearances)
ICP = act("ICP", clearances)
MRF = act("MRF", clearances)
clearances.children.extend([BL, ICP, MRF])

# Attach everything to the root sequence in order
root.children.extend([
    A, RG, IA,
    triage_seq,
    init_diag,
    loop,
    support_par,
    final_admin,
    clearances
])
```