## Log Skeleton for the Order Fulfillment Process

### Reasoning Through the Constraints

**Process flow:** `RO  CA  RI  PI  QC  PO  GSL  D  IC  (RP?)`

| Constraint | Rationale |
|---|---|
| **Equivalence** | RO through IC all occur exactly once, making each pair co-equivalent. RP is excluded (optional). |
| **Always Before** | Full transitive predecessor closure (e.g., if `D` occurs, all of ROCARIPIQCPOGSL must have occurred first). |
| **Always After** | Full transitive successor closure for mandatory activities (e.g., if `RO` occurs, all of CA…IC must follow). RP excluded (optional). |
| **Never Together** | No mutually exclusive activities in this linear process. |
| **Activity Frequencies** | All core activities occur exactly once; RP is optional (0 or 1). |
| **Directly Follows** | Each step is immediately followed by the next in the strict sequential chain. |

---

```python
log_skeleton = {

    # All pairs among {RO,CA,RI,PI,QC,PO,GSL,D,IC} occur the same number of times (always 1)
    'equivalence': {
        ('RO', 'CA'), ('RO', 'RI'), ('RO', 'PI'), ('RO', 'QC'),
        ('RO', 'PO'), ('RO', 'GSL'), ('RO', 'D'),  ('RO', 'IC'),
        ('CA', 'RI'), ('CA', 'PI'), ('CA', 'QC'), ('CA', 'PO'),
        ('CA', 'GSL'), ('CA', 'D'),  ('CA', 'IC'),
        ('RI', 'PI'), ('RI', 'QC'), ('RI', 'PO'), ('RI', 'GSL'),
        ('RI', 'D'),  ('RI', 'IC'),
        ('PI', 'QC'), ('PI', 'PO'), ('PI', 'GSL'), ('PI', 'D'),
        ('PI', 'IC'),
        ('QC', 'PO'), ('QC', 'GSL'), ('QC', 'D'),  ('QC', 'IC'),
        ('PO', 'GSL'), ('PO', 'D'),  ('PO', 'IC'),
        ('GSL', 'D'),  ('GSL', 'IC'),
        ('D',  'IC')
    },

    # (A, B)  if A occurs, B must have occurred BEFORE A  (full transitive closure)
    'always_before': {
        # CA requires RO first
        ('CA',  'RO'),
        # RI requires RO, CA first
        ('RI',  'RO'),  ('RI',  'CA'),
        # PI requires RO, CA, RI first
        ('PI',  'RO'),  ('PI',  'CA'),  ('PI',  'RI'),
        # QC requires RO, CA, RI, PI first
        ('QC',  'RO'),  ('QC',  'CA'),  ('QC',  'RI'),  ('QC',  'PI'),
        # PO requires RO, CA, RI, PI, QC first
        ('PO',  'RO'),  ('PO',  'CA'),  ('PO',  'RI'),  ('PO',  'PI'),
        ('PO',  'QC'),
        # GSL requires RO..PO first
        ('GSL', 'RO'),  ('GSL', 'CA'),  ('GSL', 'RI'),  ('GSL', 'PI'),
        ('GSL', 'QC'),  ('GSL', 'PO'),
        # D requires RO..GSL first
        ('D',   'RO'),  ('D',   'CA'),  ('D',   'RI'),  ('D',   'PI'),
        ('D',   'QC'),  ('D',   'PO'),  ('D',   'GSL'),
        # IC requires RO..D first
        ('IC',  'RO'),  ('IC',  'CA'),  ('IC',  'RI'),  ('IC',  'PI'),
        ('IC',  'QC'),  ('IC',  'PO'),  ('IC',  'GSL'), ('IC',  'D'),
        # RP (optional) requires all previous activities if it occurs
        ('RP',  'RO'),  ('RP',  'CA'),  ('RP',  'RI'),  ('RP',  'PI'),
        ('RP',  'QC'),  ('RP',  'PO'),  ('RP',  'GSL'), ('RP',  'D'),
        ('RP',  'IC')
    },

    # (A, B)  if A occurs, B MUST occur AFTER A  (full transitive closure, mandatory activities only)
    'always_after': {
        # RO is always followed by everything up to IC
        ('RO',  'CA'),  ('RO',  'RI'),  ('RO',  'PI'),  ('RO',  'QC'),
        ('RO',  'PO'),  ('RO',  'GSL'), ('RO',  'D'),   ('RO',  'IC'),
        # CA is always followed by RI..IC
        ('CA',  'RI'),  ('CA',  'PI'),  ('CA',  'QC'),  ('CA',  'PO'),
        ('CA',  'GSL'), ('CA',  'D'),   ('CA',  'IC'),
        # RI is always followed by PI..IC
        ('RI',  'PI'),  ('RI',  'QC'),  ('RI',  'PO'),  ('RI',  'GSL'),
        ('RI',  'D'),   ('RI',  'IC'),
        # PI is always followed by QC..IC
        ('PI',  'QC'),  ('PI',  'PO'),  ('PI',  'GSL'), ('PI',  'D'),
        ('PI',  'IC'),
        # QC is always followed by PO..IC
        ('QC',  'PO'),  ('QC',  'GSL'), ('QC',  'D'),   ('QC',  'IC'),
        # PO is always followed by GSL..IC
        ('PO',  'GSL'), ('PO',  'D'),   ('PO',  'IC'),
        # GSL is always followed by D, IC
        ('GSL', 'D'),   ('GSL', 'IC'),
        # D is always followed by IC
        ('D',   'IC')
        # IC is NOT always followed by RP (RP is optional)
    },

    # No two activities are mutually exclusive in this linear process
    'never_together': set(),

    # Allowed occurrence counts per activity per case
    'activ_freq': {
        'RO':  {1},       # Every case starts with exactly one order receipt
        'CA':  {1},       # Availability is always checked once
        'RI':  {1},       # Items are reserved once
        'PI':  {1},       # Items are picked once
        'QC':  {1},       # Quality check performed once
        'PO':  {1},       # Order packed once
        'GSL': {1},       # Shipping label generated once
        'D':   {1},       # Dispatched once
        'IC':  {1},       # Invoice sent once
        'RP':  {0, 1}     # Payment may or may not be recorded yet
    },

    # Strict immediate-succession constraints along the main chain
    'directly_follows': {
        ('RO',  'CA'),    # Order receipt  availability check
        ('CA',  'RI'),    # Availability check  reserve items
        ('RI',  'PI'),    # Reservation  picking
        ('PI',  'QC'),    # Picking  quality check
        ('QC',  'PO'),    # Quality check  packing
        ('PO',  'GSL'),   # Packing  label generation
        ('GSL', 'D'),     # Label generated  dispatch
        ('D',   'IC')     # Dispatch  invoice  (RP excluded: it is optional)
    }
}
```

---

### Key Design Decisions

| Decision | Explanation |
|---|---|
| `RP` has frequency `{0, 1}` | Payment recording may lag behind or not yet be captured in the log |
| `(IC, RP)` **excluded** from `directly_follows` & `always_after` | Since RP is optional, IC does not guarantee RP follows |
| `(RP, IC)` **included** in `always_before` | If RP *does* occur, IC must have happened first |
| Full transitive closure in `always_before` / `always_after` | Ensures completeness; every ordering dependency is explicitly captured |