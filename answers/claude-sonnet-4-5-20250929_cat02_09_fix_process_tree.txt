# Analysis and Fixed Process Tree Model

## 1. Issues with the Current Model

The current model has a critical flaw: **the parallel block (AND operator) allows all activities after requisition approval to execute in any order**. This creates several domain violations:

- **Pay Invoice before Receive Goods**: You could pay for items never received
- **Match Invoice before Receive Invoice**: You cannot match what hasn't arrived
- **Pay Invoice before Match Invoice**: Payments should only occur after verification
- **Receive Goods before Create PO**: Goods shouldn't arrive without an order
- **Any activity before Create PO**: A purchase order must exist before downstream activities

### Correct Domain Logic Dependencies:

1. **Create PO** must happen before receiving goods or invoices
2. **Receive Goods** and **Receive Invoice** can happen independently (parallel) after PO creation
3. **Match Invoice** requires both goods and invoice to be received
4. **Pay Invoice** must happen after matching
5. **Close Case** happens last

## 2. Corrected Process Tree Model

```python
from pm4py.objects.process_tree.obj import Operator, ProcessTree

# Define activities
create_req = ProcessTree(label="Create_Purchase_Requisition")
approve_req = ProcessTree(label="Approve_Purchase_Requisition")
create_po = ProcessTree(label="Create_Purchase_Order")
receive_goods = ProcessTree(label="Receive_Goods")
receive_invoice = ProcessTree(label="Receive_Invoice")
match_invoice = ProcessTree(label="Match_Invoice_to_PO")
pay_invoice = ProcessTree(label="Pay_Invoice")
close_case = ProcessTree(label="Close_Case")

# Fixed structure:
# 1. Sequential start: Create and approve requisition, then create PO
# 2. Parallel block: Receive goods AND receive invoice (can happen in any order)
# 3. Sequential end: Match invoice, pay invoice, close case

parallel_receive_block = ProcessTree(operator=Operator.PARALLEL, children=[
    receive_goods,
    receive_invoice
])

root = ProcessTree(operator=Operator.SEQUENCE, children=[
    create_req,
    approve_req,
    create_po,
    parallel_receive_block,
    match_invoice,
    pay_invoice,
    close_case
])
```

## 3. Explanation of the Fixed Model

### Structure Breakdown:

```
 (Sequence Root)
   Create_Purchase_Requisition
   Approve_Purchase_Requisition
   Create_Purchase_Order
    (Parallel Block)
      Receive_Goods
      Receive_Invoice
   Match_Invoice_to_PO
   Pay_Invoice
   Close_Case
```

### How This Prevents Unwanted Behavior:

1. **Strict Requisition Flow**: The sequence enforces that you must create and approve a requisition before creating a PO
   
2. **PO Before Receiving**: The PO creation must complete before the parallel block starts, ensuring you cannot receive goods or invoices without an order

3. **Controlled Parallelism**: Only receiving goods and receiving invoice can happen in parallel, which reflects real-world scenarios where:
   - Goods might arrive before the invoice
   - Invoice might arrive before the goods
   - Both are independent but necessary prerequisites

4. **Sequential Verification & Payment**: After both receives complete (parallel block synchronization):
   - **Match Invoice** can only happen when both goods and invoice are received
   - **Pay Invoice** can only happen after matching verifies correctness
   - **Close Case** only happens after payment

5. **Domain Conformance**: This model enforces the "three-way match" principle common in procurement:
   - PO (what was ordered)
   - Goods Receipt (what was received)
   - Invoice (what is being billed)
   
   All three must align before payment occurs.

### Prevented Violations:

-  Cannot pay before receiving goods
-  Cannot match before receiving invoice
-  Cannot receive before creating PO
-  Cannot skip approval
-  Cannot close before payment
-  Allows flexible timing for goods and invoice receipt (realistic)

This model balances **necessary flexibility** (parallel receiving) with **strict control** (sequential verification and payment), accurately representing standard Procure-to-Pay business logic.