To solve this, we can use DuckDB's powerful list aggregation and Window functions. The query follows these logical steps:

1.  **`case_sequences`**: Aggregate activities into an ordered list for every `case_id`.
2.  **`variant_counts`**: Group by the sequence to find the frequency of each variant and select the top $K$.
3.  **`filtered_cases`**: Identify the specific `case_id`s that belong to those top variants.
4.  **Final Select**: Join back to the original table to retrieve all event details for those specific cases.

Here is the DuckDB SQL query (replace `K` with your desired integer, e.g., `5`):

```sql
WITH case_sequences AS (
    -- 1. Construct the ordered sequence of activities for each case
    SELECT 
        case_id, 
        list_agg(activity ORDER BY timestamp ASC) AS variant
    FROM event_log
    GROUP BY case_id
),
top_variants AS (
    -- 2. Group by variant and count frequencies to find the top K
    SELECT 
        variant, 
        COUNT(*) as frequency
    FROM case_sequences
    GROUP BY variant
    ORDER BY frequency DESC
    LIMIT K -- Replace K with your specific value
),
target_cases AS (
    -- 3. Filter down to case_ids belonging to the top K variants
    SELECT cs.case_id
    FROM case_sequences cs
    JOIN top_variants tv ON cs.variant = tv.variant
)
-- 4. Return all original events for the filtered cases
SELECT 
    e.case_id, 
    e.activity, 
    e.timestamp
FROM event_log e
JOIN target_cases tc ON e.case_id = tc.case_id
ORDER BY e.case_id, e.timestamp;
```

### Explanation of the components:

*   **`list_agg(activity ORDER BY timestamp ASC)`**: This is a specialized DuckDB function that creates a List type. Unlike a string concatenation, this preserves the data structure and allows for accurate comparisons of sequences. Sorting within the aggregator ensures the process flow is respected.
*   **The Join Strategy**: We first find the "Fingerprint" (variant) of every case. We then find which fingerprints are most common. Finally, we filter the original log by those `case_id`s that match the common fingerprints.
*   **Performance**: DuckDB handles list aggregations very efficiently in-memory, making this approach much faster than self-joins or complex window-function chains often used in traditional SQL dialects.