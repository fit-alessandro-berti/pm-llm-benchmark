# POWL Model for Manufacturing & Distribution Process

## Analysis of Event Log Patterns

| Pattern | Observation | Model Construct |
|---------|-------------|-----------------|
| **Start** | OR  MS  QS always sequential | Strict partial order |
| **Assembly/QC** | AS always first; then optionally IQC(s) followed by AS, repeating. Case 3 shows consecutive IQCs (IQCIQC) without intervening AS | Nested loop: `*(AS, *(IQC, ))` |
| **Testing** | TST always first; then optionally RT  TST, repeating (Case 5: two RT cycles) | Loop: `*(TST, RT)` |
| **Labeling** | LB present in Cases 1,3,4,5 but skipped in Case 2 | Choice: `X(LB, )` |
| **End** | PK  (LB?)  DP  D always sequential | Strict partial order |

### Trace Verification

| Case | Assembly Loop | Testing Loop | Labeling |
|------|--------------|--------------|----------|
| 1 | AS  IQC  AS (1 redo, 1 IQC each) | TST  RT  TST (1 redo) | LB |
| 2 | AS  IQC  AS (1 redo) | TST (no redo) | skip |
| 3 | AS  IQC,IQC  AS  IQC  AS (2 redos, first has 2 IQCs) | TST  RT  TST (1 redo) | LB |
| 4 | AS (no redo, no IQC) | TST (no redo) | LB |
| 5 | AS  IQC  AS  IQC  AS (2 redos, 1 IQC each) | TST  RT  TST  RT  TST (2 redos) | LB |

## Final POWL Model

```python
import pm4py
from pm4py.objects.powl.obj import StrictPartialOrder, OperatorPOWL, Transition, SilentTransition
from pm4py.objects.process_tree.obj import Operator

# --- Activity Transitions ---
OR  = Transition(label="OR")
MS  = Transition(label="MS")
QS  = Transition(label="QS")
AS  = Transition(label="AS")
IQC = Transition(label="IQC")
TST = Transition(label="TST")
RT  = Transition(label="RT")
PK  = Transition(label="PK")
LB  = Transition(label="LB")
DP  = Transition(label="DP")
D   = Transition(label="D")
skip = SilentTransition()

# --- Inner loop: one or more IQC checks ---
# *(IQC, tau) produces: IQC | IQCIQC | IQCIQCIQC | ...
# Needed because Case 3 shows consecutive IQCs without intervening AS
IQC_loop = OperatorPOWL(operator=Operator.LOOP, children=[IQC, skip])

# --- Assembly-Quality loop ---
# *(AS, IQC_loop) produces: AS, then optionally (one-or-more IQCs  AS), repeating
# Case 4: AS  |  Cases 1,2: ASIQCAS  |  Case 3: ASIQCIQCASIQCAS
AS_IQC_loop = OperatorPOWL(operator=Operator.LOOP, children=[AS, IQC_loop])

# --- Testing-Retesting loop ---
# *(TST, RT) produces: TST, then optionally (RT  TST), repeating
# Cases 2,4: TST  |  Cases 1,3: TSTRTTST  |  Case 5: TSTRTTSTRTTST
TST_RT_loop = OperatorPOWL(operator=Operator.LOOP, children=[TST, RT])

# --- Optional Labeling ---
# X(LB, tau): either label or skip
# Case 2 skips; all others include LB
LB_choice = OperatorPOWL(operator=Operator.XOR, children=[LB, skip])

# --- Root: Full sequential process ---
root = StrictPartialOrder(
    nodes=[OR, MS, QS, AS_IQC_loop, TST_RT_loop, PK, LB_choice, DP, D]
)
root.order.add_edge(OR, MS)
root.order.add_edge(MS, QS)
root.order.add_edge(QS, AS_IQC_loop)
root.order.add_edge(AS_IQC_loop, TST_RT_loop)
root.order.add_edge(TST_RT_loop, PK)
root.order.add_edge(PK, LB_choice)
root.order.add_edge(LB_choice, DP)
root.order.add_edge(DP, D)
```

## Structural Summary

```
PO=(nodes={OR, MS, QS, *(AS, *(IQC, )), *(TST, RT), PK, X(LB, ), DP, D},
    order={ORMS, MSQS, QS*(AS, *(IQC,)), *(AS, *(IQC,))*(TST,RT),
           *(TST,RT)PK, PKX(LB,), X(LB,)DP, DPD})
```

**Key design decisions:**
- **Nested loop `*(AS, *(IQC, ))`**: The inner `*(IQC, )` allows one-or-more consecutive IQC checks per redo cycle, accommodating Case 3's double-IQC pattern while still handling single IQCs in other cases.
- **`*(TST, RT)`**: Cleanly captures zero, one, or multiple re-testing rounds.
- **`X(LB, )`**: Silent transition alternative models the optional labeling step.
- **Fully ordered root**: All activities follow a strict sequential dependency chain with no concurrency, consistent with every observed trace.