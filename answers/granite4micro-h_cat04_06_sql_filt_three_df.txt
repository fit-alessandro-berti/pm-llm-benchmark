To tackle this problem effectively within DuckDB, we'll break down the requirements step by step and craft a SQL query that aligns with these specifications. The key is to identify case instances where the specified sequence of activities occurs along with the timing condition and then exclude those cases from our final result set.

### Step 1: Identify Cases Meeting the Sequence & Timing Condition

First, we need to find `case_id`s where:
- 'Approve Purchase Requisition' precedes 'Create Order', which in turn precedes 'Confirm Order'.
- The time between 'Create Order' and 'Confirm Order' exceeds 5 days.

We can achieve this using conditional aggregation or window functions. For clarity, let's outline the approach:

1. **Identify the Sequence**: Use `LAG` to check if each row is preceded by the required activity.
2. **Check Timing Condition**: Calculate the difference between consecutive 'Create Order' and 'Confirm Order' events within the same case.

### Step 2: Exclude Those Cases from Final Output

We will perform a LEFT JOIN with the identified cases (from step 1) to exclude them, returning all other event logs as required.

Here is the DuckDB SQL query that accomplishes this:

```sql
WITH sequence_cases AS (
    SELECT 
        case_id
    FROM 
        event_log e1
    WHERE EXISTS (
        SELECT 1
        FROM event_log e2
        JOIN event_log e3 ON e3.case_id = e2.case_id
        WHERE e1.case_id = e2.case_id
          AND e2.activity = 'Approve Purchase Requisition'
          AND e2.timestamp < e3.timestamp
          AND e3.activity = 'Create Order'
          AND e3.timestamp < e3.timestamp + INTERVAL '5 days' 
          AND e3.timestamp = (
              SELECT MAX(timestamp)
              FROM event_log e4
              WHERE e4.case_id = e1.case_id
                AND e4.activity = 'Confirm Order'
          )
    )
)

SELECT *
FROM event_log
WHERE case_id NOT IN (SELECT case_id FROM sequence_cases);
```

### Explanation:

- **CTE (`sequence_cases`)**:
  - We first filter `event_log` to identify cases that meet the exact activity sequence and timing condition.
  - The subquery checks for each row if there exists a subsequent 'Create Order' followed by 'Confirm Order' within the same case, ensuring 'Confirm Order' occurs after 'Create Order' by more than five days.

- **Final SELECT**:
  - After identifying `case_id`s that violate our criteria (i.e., contain the specified sequence and timing condition), we exclude these from the main query using a NOT IN clause.
  
This approach ensures we return all events except those from cases where 'Approve Purchase Requisition' is immediately followed by 'Create Order', which in turn is closely followed by 'Confirm Order' within 5 days.

### Key Concepts Utilized:

- **Common Table Expressions (CTE)**: Simplifies complex queries and improves readability.
- **Conditional Aggregation/Windes Functions**: Allows checking conditions based on previous rows without self-joins, though here we opted for explicit subqueries for clarity in the explanation.
- **Interval Arithmetic**: Ensures precise time comparisons across events within each case.

This query effectively filters out cases that meet both the activity sequence and timing condition while retaining all other event records from `event_log`, fulfilling the problem's requirements.