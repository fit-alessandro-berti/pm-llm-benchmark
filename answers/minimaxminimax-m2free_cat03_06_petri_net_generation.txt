<think>
We are constructing an accepting Petri net for an insurance claim management process.

 Steps:
 1. Define the places (states) and transitions (activities) for the process.
 2. The process flow:
    - Start: A new claim arrives -> represented by a start place with a token.
    - Then we have: CR, DV, FC, CA, AP, P, N, CL.

 However, there are loops for re-submission of documents (RDS) and in-depth investigation (II). 
    - After DV, if documents are incomplete, we go back to RDS and then back to DV? 
      Actually, the step "Re-Document Submission (RDS)" is a step that happens after DV when documents are incomplete, and then we return to DV? 
      But the description says: after DV, if incomplete, then RDS (re-submission) and then we continue? 
      However, note that the flow says: "in some cases, if documents are incomplete after Document Verification (DV), a re-submission of documents step occurs (RDS) before the process continues". 
      So, the flow is: ... DV -> (if incomplete) RDS -> then back to DV? But wait, the description says "before the process continues", meaning that after RDS we go back to DV? 
      Alternatively, we can interpret that after DV, if incomplete, we go to RDS and then from RDS we go back to DV? 

    Similarly, for FC and II: after FC, if there are doubts, we do II and then go back to FC? But note: the description says "if the Fraud Check (FC) raises doubts, an additional In-depth Investigation (II) is performed. This can happen multiple times before proceeding to Claim Assessment (CA)."

 3. We can design the flow as:

    Start -> CR -> DV -> [if not complete] RDS -> DV (loop) -> [if complete] FC -> [if doubts] II -> FC (loop) -> CA -> AP -> P -> N -> CL

    However, note that the problem does not specify whether RDS leads back to DV or to another step. Similarly, II leads back to FC.

 4. We need to model these loops. We'll create places for each state and transitions for each activity.

 5. We'll have:
    - start place (p0): initial token here.
    - After CR: p1
    - After DV: p2
        - From p2, if documents are complete: transition FC -> p3
        - If documents are incomplete: transition RDS -> then from RDS we go back to DV? But note: RDS is a step that leads back to DV? 
          Actually, we can model RDS as a transition that goes from a place after DV (say p2) to a place that represents "waiting for re-submission", and then from that place we go to DV again? 
          However, the step RDS is an activity that must happen. So we can have:

          p2 (after DV) -> (if incomplete) RDS (transition) -> then we need to go back to DV? But DV is a transition, so we cannot go back to a transition.

    Alternative approach: 
        We model DV as a transition that consumes a token from the state after CR and produces a token in the state after DV. Then, if we have to do RDS, we model RDS as a transition that goes from the state after DV to a state that represents "re-submitted documents", and then from that state we go back to DV? But note that DV is a transition and we cannot have two consecutive transitions without a place.

    So we break DV into two steps? Actually, we can have:

        p1 (after CR) -> DV -> p2
        p2 -> (if incomplete) RDS -> p3
        p3 -> DV -> p2   (but then we get stuck in a loop between p2 and p3? because from p2 we can go to RDS again? and from p3 we go to DV which leads to p2? then we have a choice: from p2 we can either go to FC (if complete) or to RDS (if incomplete) again? 

    However, the flow says that after RDS we do DV again? So we can have:

        p2 -> (if complete) FC -> p4
        p2 -> (if incomplete) RDS -> p3
        p3 -> DV -> p2   [loop]

    Similarly for FC and II:

        p4 (after FC) -> (if doubts) II -> p5 -> FC -> p4   (loop)
        p4 -> (if no doubts) CA -> p6

 6. We'll design the Petri net with the following places:

    p0: start (claim arrived)
    p1: after CR (claim registered)
    p2: after DV (document verification done) -> from here, we can either go to FC (if complete) or to RDS (if incomplete)
    p3: after RDS (re-document submission done) -> we go back to DV (so we don't need an extra place for the state after RDS? because after RDS we do DV again? But note: RDS is an activity and then we do DV again, so we break the flow with a place for the result of RDS? Actually, we can model RDS as a transition that produces a token in a place that is the same as the input place for DV? That would be p2? But that doesn't work because we need to distinguish between the first DV and the next.

    Alternatively, we can have:

        p2 (state after DV) -> (if incomplete) transition RDS -> p6 (state after RDS) -> transition DV -> p2 (again)   [so we have a loop]

    Similarly, for FC:

        p4 (state after FC) -> (if doubts) transition II -> p7 (state after II) -> transition FC -> p4 (again)
        p4 -> (if no doubts) transition CA -> p5

 7. Then from p5 (after CA) we do AP (if threshold exceeded) but note: AP is conditional. The description says: "if the amount surpasses a certain threshold". So we have:

        p5 (after CA) -> (if above threshold) AP -> p8
        p5 -> (if not above threshold) ? Actually, the description says the claim must be approved by a senior manager if the amount surpasses a threshold. But what if it doesn't? Then we skip AP? 

    However, the description does not say that we always do AP. It says we do AP only if the amount surpasses a threshold. So we have:

        p5 -> (if above threshold) transition AP -> p8
        p5 -> (if below threshold) transition (skip) -> p8? Or we can model that AP is always done? But the problem states conditionally.

    Alternatively, we can model that after CA, if the amount is above threshold, we do AP, otherwise we skip to payment.

    But note: the steps are:
        ... -> CA -> [if above threshold] AP -> P -> N -> CL
        ... -> CA -> [if below threshold] P -> N -> CL

    So we can have:

        p5 -> (if above) transition AP -> p8
        p5 -> (if below) transition (no approval) -> p8? But what about the activity? Actually, we don't have an activity for skipping. We can have the transition from p5 to p8 for the case of below threshold without a label? Or we can have a transition labeled "skip" for the below threshold? But the problem doesn't specify an activity for below threshold. We can model it as a transition that has no activity? Or we can use the same transition AP? But AP is conditional.

    Alternatively, we can have:

        p5 -> (if above) transition AP -> p8
        p5 -> (if below) transition (with no activity) -> p8   [then we don't have an activity for below threshold]

    But the problem says: "Approval (AP): the claim must be approved by a senior manager if the amount surpasses a certain threshold". So if it doesn't surpass, we don't do AP. So we can have two transitions from p5: one labeled "above_threshold" and one "below_threshold". But the problem doesn't specify an activity for below_threshold. We can model the below_threshold as a transition that doesn't represent an activity? Or we can have a transition that represents "bypass approval"?

    However, note that the problem does not say that bypassing approval is an activity. So we can have two transitions from p5: 
        - one for the case of above threshold: AP (transition labeled "AP")
        - one for the case of below threshold: a transition that we might label as "continue" or "no approval needed" but that doesn't correspond to an activity. Alternatively, we can use the same transition AP for above threshold and for below threshold we can use a different transition? But the activity AP only happens in the above threshold case.

    Actually, we can model the flow as:

        p5 -> (if above threshold) transition AP -> p8
        p5 -> (if below threshold) transition (no activity) -> p8   [but note: we cannot have an unlabeled transition? We can leave the label as None?]

    But the problem says the transitions are labeled with the activity names. So for the below threshold case, we don't have an activity? Then we can set the label to None? Or we can use a transition without a label? 

    Alternatively, we can model that the transition from p5 to p8 for the below threshold case does not correspond to any activity? Then we don't need to label it? But the problem says "transitions labeled with the activity names". So if there's no activity, we can set the label to None? Or we can skip creating that transition? 

    However, we must have a way to represent the condition. So we'll create two transitions from p5: one for above (with label "AP") and one for below (with label None? or we can use a label for the condition? But the problem says "activity names", so below threshold is not an activity. 

    We can do: 
        p5 -> transition_above: labeled "AP" -> p8
        p5 -> transition_below: labeled None -> p8

    But note: the problem says "the claim must be approved by a senior manager if the amount surpasses a certain threshold". So the activity AP happens only when above threshold. The below threshold case does not have an activity. So we can model the transition for below threshold as having no label? That is acceptable? 

    Alternatively, we can model the flow as:

        p5 -> transition (condition: below_threshold) -> p8   [label = "bypass"] but that's not an activity? 

    We'll follow the problem: the activities are named. So we only label transitions that correspond to an activity. The bypass for below threshold is not an activity. Therefore, we can have:

        p5 -> transition_below: label = None

    But note: the pm4py PetriNet.Transition has a label. We can set it to None for bypass.

 8. Then from p8 (after AP or bypass) we do P (payment) -> p9 -> N (notification) -> p10 -> CL (closure) -> p11 (final place)

 9. We have to remember that the initial marking has a token in p0 (start) and the final marking has a token in p11 (after closure).

 10. Steps in code:

     - Create a PetriNet.
     - Create places: p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11
        p0: start
        p1: after CR
        p2: after DV (we are at the point where we check the documents) -> from here we have two choices: go to FC (if complete) or to RDS (if incomplete)
        p3: after RDS? Actually, after RDS we go back to DV? But we break the DV into two parts? 
        But note: we have a loop from p2 to p3 (via RDS) and then from p3 back to p2 (via DV again). So p2 is the same state for every DV? 

     Alternatively, we can avoid having p3 as a separate state? We can model RDS as a transition that goes from p2 to p2? But that would be a self-loop? That's not allowed because arcs must connect distinct nodes? Actually, we can have an arc from a place to a transition and then from the same transition to the same place? That would be a self-loop? But that's allowed? However, in Petri nets, we usually avoid self-loops for clarity? 

     Instead, we can have:

        p2 -> RDS -> p2   [but that would be a self-loop for the transition RDS?]

     But note: we are modeling the process. We can have:

        p2 (state after DV) --(incomplete)--> transition RDS --> p2 (state after RDS) --(then DV)--> transition DV --> p2 (state after DV again)

     This would create a loop: p2 (DV done) -> RDS (if incomplete) -> p2 (same state as after DV) -> then we do DV again? 

     However, that doesn't model the fact that we do the DV activity again? We are stuck? 

     We must break the state p2? 

     Let me restructure:

        We can have:

        state after CR: p1
        state before DV: we don't have a state for "before DV" because DV is a transition? 

        We model:

        p1 -> DV -> p2   (p2: state after DV)

        Now, if we have to do RDS, we break:

        p2 -> (if incomplete) RDS -> p3   (p3: state after RDS)
        p3 -> DV -> p4   (p4: state after the second DV)

        But then we are at p4, and we have to check the documents again? So we need to go back to the same state as p2? 

        We can set p4 as the same state as p2? 

        Alternatively, we can have:

        p2 and p4 are the same state? Then we have:

        p1 -> DV -> p2
        p2 -> (incomplete) RDS -> p3
        p3 -> DV -> p2   (loop)

        This is the same as before: p2 is the state after DV, and we have a loop from p2 to p3 to p2.

     So we'll do:

        p0 (start) -> CR -> p1
        p1 -> DV -> p2
        p2 -> (complete) FC -> p4
        p2 -> (incomplete) RDS -> p3
        p3 -> DV -> p2   (loop)

     Similarly for FC and II:

        p4 (after FC) -> (if doubts) II -> p5
        p5 -> FC -> p4   (loop)
        p4 -> (if no doubts) CA -> p6

     Then:

        p6 (after CA) -> (if above) AP -> p8
        p6 (after CA) -> (if below) -> p8   [transition without label?]
        p8 -> P -> p9
        p9 -> N -> p10
        p10 -> CL -> p11

     And the initial marking: {p0:1}
     Final marking: {p11:1}

 11. Steps for the code:

     - Import necessary classes.
     - Create a PetriNet instance.
     - Create the places: p0, p1, p2, p3, p4, p5, p6, p7 (wait, we don't have p7? we have p5 and p6 for the FC/II loop? and p8 for after CA?).

        Let's name them:

        p0 = Place("start")
        p1 = Place("after_CR")
        p2 = Place("after_DV")   # state after document verification (before checking completeness)
        p3 = Place("after_RDS")
        p4 = Place("after_FC")   # state after fraud check (before checking doubts)
        p5 = Place("after_II")
        p6 = Place("after_CA")
        p7 = Place("after_AP_bypass")   # we need a place for after CA and before payment? Actually, we have two cases: after AP (above threshold) and after bypass (below threshold). We can combine them? 

        But note: after CA, we have two paths: one that does AP and one that doesn't. Then they both go to payment. So we can have:

        p6: after CA
        Then we have two transitions from p6: 
            - one for above threshold: labeled "AP" -> p7
            - one for below threshold: without label -> p7

        Then from p7 we do payment -> p8 -> notification -> p9 -> closure -> p10 (final)

     - Create transitions:

        t1: CR (Claim Registration) 
        t2: DV (Document Verification) 
        t3: RDS (Re-Document Submission) 
        t4: FC (Fraud Check)
        t5: II (In-depth Investigation) 
        t6: CA (Claim Assessment)
        t7: AP (Approval)   # for above threshold
        t8: bypass (for below threshold)   # label: None
        t9: P (Payment)
        t10: N (Notification)
        t11: CL (Closure)

     - Now, connect the places and transitions:

        p0 --t1--> p1
        p1 --t2--> p2
        p2 --t3--> p3   [if incomplete] -> but note: we have two transitions from p2: t3 (for RDS) and t4 (for FC). So we need two arcs from p2: one to t3 and one to t4.
        p2 --t4--> p4   [if complete]
        p3 --t2--> p2   [loop]   # because after RDS we do DV again
        p4 --t5--> p5   [if doubts]
        p4 --t6--> p6   [if no doubts]
        p5 --t4--> p4   [loop]   # after II we do FC again
        p6 --t7--> p7   [above threshold]
        p6 --t8--> p7   [below threshold]
        p7 --t9--> p8
        p8 --t10--> p9
        p9 --t11--> p10

     - But note: the flow from p3 to p2: we have an arc from p3 to t2 (DV). Then from t2 we go to p2.

     - However, the flow for the DV loop: 
          p2 (after DV) -> (incomplete) RDS -> p3 -> (re-submit) DV -> p2

        But note: the activity DV is a transition that we model. So from p3 we have an arc to t2 (DV) and then from t2 we go to p2.

     - Similarly, for FC loop: 
          p4 (after FC) -> (if doubts) II -> p5 -> (after II) we do FC again -> t4? But we are already at p5. We need to go back to FC? 

        We have: p5 --t4--> p4? But that would be a transition labeled FC? 

        Actually, we have a transition t4 for FC. But note: we already used t4 for the first FC. We can reuse the same transition? 

        The problem: the activity FC happens multiple times. So we can use the same transition t4 for every FC? 

        But then the flow: 
          p4 --t4--> ... but wait, we have two possibilities: from p4 we can go to t4 (for FC again) or to t6 (for CA). 

        We have two arcs from p4: one to t4 (for FC again) and one to t6 (for CA). 

        And from p5 we go to t4? Actually, we go to the same transition t4? 

        How? 

          p4 --(if doubts) t4? -> No, we have t5 for II and t4 for FC? 

        Actually, we have:

          p4 --t5--> p5   [for II]
          p4 --t6--> p6   [for CA]   (without doubts)

        Then after II (at p5) we do FC again? So we have:

          p5 --t4--> p4   (transition labeled FC)

        Then from p4 again we have two choices: doubts or not.

        So we can model the same transition t4 for the FC activity every time.

     - Similarly, for DV: we use the same transition t2 for DV every time.

     - Now, note that the transition t4 (FC) is used both as the first FC and as subsequent FCs? That's acceptable.

 12. Code structure:

     from pm4py.objects.petri_net.obj import PetriNet, Marking
     from pm4py.objects.petri_net.utils import petri_utils

     net = PetriNet(name="insurance_claim_process")

     # Create places
     p0 = PetriNet.Place("p0")
     p1 = PetriNet.Place("p1")
     p2 = PetriNet.Place("p2")
     p3 = PetriNet.Place("p3")
     p4 = PetriNet.Place("p4")
     p5 = PetriNet.Place("p5")
     p6 = PetriNet.Place("p6")
     p7 = PetriNet.Place("p7")
     p8 = PetriNet.Place("p8")
     p9 = PetriNet.Place("p9")
     p10 = PetriNet.Place("p10")

     net.places.update({p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10})

     # Create transitions
     t1 = PetriNet.Transition("t1", "Claim Registration")
     t2 = PetriNet.Transition("t2", "Document Verification")
     t3 = PetriNet.Transition("t3", "Re-Document Submission")
     t4 = PetriNet.Transition("t4", "Fraud Check")
     t5 = PetriNet.Transition("t5", "In-depth Investigation")
     t6 = PetriNet.Transition("t6", "Claim Assessment")
     t7 = PetriNet.Transition("t7", "Approval")
     t8 = PetriNet.Transition("t8", None)   # bypass for below threshold
     t9 = PetriNet.Transition("t9", "Payment")
     t10 = PetriNet.Transition("t10", "Notification")
     t11 = PetriNet.Transition("t11", "Closure")

     net.transitions.update({t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11})

     # Add arcs
     petri_utils.add_arc_from_to(p0, t1, net)
     petri_utils.add_arc_from_to(t1, p1, net)

     petri_utils.add_arc_from_to(p1, t2, net)
     petri_utils.add_arc_from_to(t2, p2, net)

     # From p2: two ways: to RDS (incomplete) or to FC (complete)
     petri_utils.add_arc_from_to(p2, t3, net)   # for incomplete documents -> RDS
     petri_utils.add_arc_from_to(p2, t4, net)   # for complete -> FC

     # RDS leads to p3, then from p3 we go back to DV (t2)
     petri_utils.add_arc_from_to(t3, p3, net)
     petri_utils.add_arc_from_to(p3, t2, net)   # after RDS we do DV again -> this will lead to p2 again

     # From p4: two ways: to II (doubts) or to CA (no doubts)
     petri_utils.add_arc_from_to(p4, t5, net)   # for doubts -> II
     petri_utils.add_arc_from_to(p4, t6, net)   # for no doubts -> CA

     # II leads to p5, then from p5 we go back to FC (t4)
     petri_utils.add_arc_from_to(t5, p5, net)
     petri_utils.add_arc_from_to(p5, t4, net)   # after II we do FC again -> this will lead to p4 again

     # From p6: two ways: AP (above threshold) or bypass (below threshold)
     petri_utils.add_arc_from_to(p6, t7, net)   # above threshold -> AP
     petri_utils.add_arc_from_to(p6, t8, net)   # below threshold -> bypass

     # Both AP and bypass lead to p7 (which is the state before payment)
     petri_utils.add_arc_from_to(t7, p7, net)
     petri_utils.add_arc_from_to(t8, p7, net)

     # Then payment, notification, closure
     petri_utils.add_arc_from_to(p7, t9, net)
     petri_utils.add_arc_from_to(t9, p8, net)
     petri_utils.add_arc_from_to(p8, t10, net)
     petri_utils.add_arc_from_to(t10, p9, net)
     petri_utils.add_arc_from_to(p9, t11, net)
     petri_utils.add_arc_from_to(t11, p10, net)

     # Initial marking: token at p0
     im = Marking()
     im[p0] = 1

     # Final marking: token at p10
     fm = Marking()
     fm[p10] = 1

 13. However, note: the example in the prompt removes a place at the end? We don't need to remove any place? 

     But the example does: 
        petri_utils.remove_place(net, sink)
        del fm[sink]

     We are not removing any place. So we don't need to do that.

 14. Let's check the loops:

     - DV loop: 
          p2 (after DV) -> (if incomplete) RDS -> p3 -> DV -> p2

     - FC loop:
          p4 (after FC) -> (if doubts) II -> p5 -> FC -> p4

     These loops are correct.

 15. We are done.

 However, note: the problem says that the final marking should represent a closed claim. We have p10 as the closed claim.

 Let's write the code accordingly.

 But note: the transition t8 (bypass) has label None. That is acceptable.

 But we must be cautious: the problem says "transitions labeled with the activity names". So we are only labeling the activities. The bypass is not an activity, so we leave it as None.

 Alternatively, we can set the label for t8 as "bypass" or "no approval needed"? But that might be considered an activity? 

 Since the problem does not specify an activity for the bypass, we set it to None.

 Let's code accordingly.

 However, note: the problem says "the claim must be approved by a senior manager if the amount surpasses a certain threshold". So when it doesn't surpass, we don't have an activity. So we are correct.

 Implementation:

 We'll create the Petri net as described.
</think>

To solve this problem, we need to construct an accepting Petri net for an insurance claim management process. The Petri net includes places (states), transitions (activities), and arcs that represent the flow of the process. The process involves several steps, including loops for document re-submission and in-depth investigation. The initial marking starts with a token in the start place, and the final marking ends with a token in the closed claim place.

### Approach
1. **Places and Transitions**: Define places for each state in the process and transitions for each activity. The places include states such as start, after registration, after document verification, etc. Transitions represent activities like claim registration, document verification, fraud check, etc.
2. **Loops for Re-submissions**: Model loops for document re-submission (RDS) and in-depth investigation (II) to handle cases where documents are incomplete or fraud doubts arise.
3. **Conditional Paths**: Include conditional paths for approval (AP) based on claim amount and bypass (no activity) for claims below the threshold.
4. **Arcs and Flow**: Connect places and transitions with arcs to form the logical sequence of activities, including loops for re-submissions.
5. **Initial and Final Markings**: Define the initial marking with a token in the start place and the final marking with a token in the closed claim place.

### Solution Code
```python
from pm4py.objects.petri_net.obj import PetriNet, Marking
from pm4py.objects.petri_net.utils import petri_utils

# Create a new Petri net
net = PetriNet(name="insurance_claim_process")

# Define places (states)
p_start = PetriNet.Place(name="start")
p_after_cr = PetriNet.Place(name="after_cr")
p_after_dv = PetriNet.Place(name="after_dv")
p_after_rds = PetriNet.Place(name="after_rds")
p_after_fc = PetriNet.Place(name="after_fc")
p_after_ii = PetriNet.Place(name="after_ii")
p_after_ca = PetriNet.Place(name="after_ca")
p_after_ap = PetriNet.Place(name="after_ap")
p_after_p = PetriNet.Place(name="after_p")
p_after_n = PetriNet.Place(name="after_n")
p_after_cl = PetriNet.Place(name="after_cl")  # Final place

# Add places to the net
net.places.update({p_start, p_after_cr, p_after_dv, p_after_rds, 
                   p_after_fc, p_after_ii, p_after_ca, p_after_ap, 
                   p_after_p, p_after_n, p_after_cl})

# Define transitions (activities)
t_cr = PetriNet.Transition(name="t_cr", label="Claim Registration")
t_dv = PetriNet.Transition(name="t_dv", label="Document Verification")
t_rds = PetriNet.Transition(name="t_rds", label="Re-Document Submission")
t_fc = PetriNet.Transition(name="t_fc", label="Fraud Check")
t_ii = PetriNet.Transition(name="t_ii", label="In-depth Investigation")
t_ca = PetriNet.Transition(name="t_ca", label="Claim Assessment")
t_ap = PetriNet.Transition(name="t_ap", label="Approval")
t_bypass = PetriNet.Transition(name="t_bypass", label=None)
t_p = PetriNet.Transition(name="t_p", label="Payment")
t_n = PetriNet.Transition(name="t_n", label="Notification")
t_cl = PetriNet.Transition(name="t_cl", label="Closure")

# Add transitions to the net
net.transitions.update({t_cr, t_dv, t_rds, t_fc, t_ii, t_ca, 
                        t_ap, t_bypass, t_p, t_n, t_cl})

# Add arcs to form the process flow
# Start -> Claim Registration
petri_utils.add_arc_from_to(p_start, t_cr, net)
petri_utils.add_arc_from_to(t_cr, p_after_cr, net)

# Claim Registration -> Document Verification
petri_utils.add_arc_from_to(p_after_cr, t_dv, net)
petri_utils.add_arc_from_to(t_dv, p_after_dv, net)

# Document Verification paths
# If documents incomplete -> Re-Document Submission
petri_utils.add_arc_from_to(p_after_dv, t_rds, net)
petri_utils.add_arc_from_to(t_rds, p_after_rds, net)
# After RDS -> Document Verification (loop back)
petri_utils.add_arc_from_to(p_after_rds, t_dv, net)

# If documents complete -> Fraud Check
petri_utils.add_arc_from_to(p_after_dv, t_fc, net)
petri_utils.add_arc_from_to(t_fc, p_after_fc, net)

# Fraud Check paths
# If doubts -> In-depth Investigation
petri_utils.add_arc_from_to(p_after_fc, t_ii, net)
petri_utils.add_arc_from_to(t_ii, p_after_ii, net)
# After II -> Fraud Check (loop back)
petri_utils.add_arc_from_to(p_after_ii, t_fc, net)

# If no doubts -> Claim Assessment
petri_utils.add_arc_from_to(p_after_fc, t_ca, net)
petri_utils.add_arc_from_to(t_ca, p_after_ca, net)

# Claim Assessment paths
# If amount above threshold -> Approval
petri_utils.add_arc_from_to(p_after_ca, t_ap, net)
petri_utils.add_arc_from_to(t_ap, p_after_ap, net)
# If amount below threshold -> Bypass (no activity)
petri_utils.add_arc_from_to(p_after_ca, t_bypass, net)
petri_utils.add_arc_from_to(t_bypass, p_after_ap, net)

# Approval/Bypass -> Payment
petri_utils.add_arc_from_to(p_after_ap, t_p, net)
petri_utils.add_arc_from_to(t_p, p_after_p, net)

# Payment -> Notification
petri_utils.add_arc_from_to(p_after_p, t_n, net)
petri_utils.add_arc_from_to(t_n, p_after_n, net)

# Notification -> Closure (final)
petri_utils.add_arc_from_to(p_after_n, t_cl, net)
petri_utils.add_arc_from_to(t_cl, p_after_cl, net)

# Define initial marking (token at start place)
im = Marking()
im[p_start] = 1

# Define final marking (token at closed claim place)
fm = Marking()
fm[p_after_cl] = 1

# The net, initial marking, and final marking are now defined and ready for use.
```

### Explanation
- **Places**: Represent different states in the process, such as `p_start` (start), `p_after_cr` (after claim registration), and `p_after_cl` (after closure).
- **Transitions**: Represent activities like claim registration (`t_cr`), document verification (`t_dv`), and fraud check (`t_fc`). Conditional transitions (e.g., `t_bypass` for claims below the threshold) handle different paths.
- **Arcs**: Connect places and transitions to form the process flow, including loops for document re-submission (`p_after_dv`  `t_rds`  `p_after_rds`  `t_dv`  `p_after_dv`) and in-depth investigation (`p_after_fc`  `t_ii`  `p_after_ii`  `t_fc`  `p_after_fc`).
- **Initial Marking (`im`)**: Starts with a token in `p_start`.
- **Final Marking (`fm`)**: Ends with a token in `p_after_cl`, representing the closed claim state.

This Petri net accurately models the insurance claim process with all necessary paths and loops.