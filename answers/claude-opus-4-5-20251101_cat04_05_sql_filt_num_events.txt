# DuckDB SQL Query: Filter Cases with Six or Fewer Events

## Solution

```sql
SELECT e.*
FROM event_log e
WHERE e.case_id IN (
    SELECT case_id
    FROM event_log
    GROUP BY case_id
    HAVING COUNT(*) <= 6
)
```

## Explanation

This query works in two parts:

1. **Subquery (Inner Query)**: Identifies which cases to keep
   - Groups all events by `case_id`
   - Uses `HAVING COUNT(*) <= 6` to filter only cases with six or fewer events
   - Returns the list of qualifying `case_id` values

2. **Main Query (Outer Query)**: Returns the complete event data
   - Selects all columns from `event_log`
   - Filters to include only events where `case_id` is in the qualifying list

## Alternative Approaches

### Using a Window Function (CTE approach)

```sql
WITH case_counts AS (
    SELECT 
        *,
        COUNT(*) OVER (PARTITION BY case_id) AS events_in_case
    FROM event_log
)
SELECT 
    case_id,
    activity,
    timestamp
FROM case_counts
WHERE events_in_case <= 6
```

### Using a JOIN

```sql
SELECT e.*
FROM event_log e
INNER JOIN (
    SELECT case_id
    FROM event_log
    GROUP BY case_id
    HAVING COUNT(*) <= 6
) valid_cases
ON e.case_id = valid_cases.case_id
```

## Performance Considerations

| Approach | Pros | Cons |
|----------|------|------|
| **Subquery (IN)** | Simple, readable | May be slower on very large datasets |
| **Window Function** | Single table scan | Higher memory usage for window calculation |
| **JOIN** | Often optimized well by DuckDB | Slightly more verbose |

For DuckDB specifically, all three approaches should perform similarly due to its efficient query optimizer, but the **window function approach** often performs best on larger datasets as it requires only a single pass through the data.