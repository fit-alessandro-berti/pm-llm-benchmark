```python
from pm4py.objects.petri_net.obj import PetriNet, Marking
from pm4py.objects.petri_net.utils import petri_utils

# Create net
net = PetriNet(name="Insurance_Claim_Process")

# Places
p_start = PetriNet.Place("p_start")
p_after_C = PetriNet.Place("p_after_C")          # after Insurance Claim filed
p_after_CR = PetriNet.Place("p_after_CR")        # after Claim Registration
p_after_DV = PetriNet.Place("p_after_DV")        # after Document Verification
p_docs_incomplete = PetriNet.Place("p_docs_incomplete")  # indicates need for RDS
p_after_RDS = PetriNet.Place("p_after_RDS")      # after Re-Document Submission
p_after_FC = PetriNet.Place("p_after_FC")        # after Fraud Check
p_needs_II = PetriNet.Place("p_needs_II")        # indicates need for In-depth Investigation
p_after_II = PetriNet.Place("p_after_II")        # after In-depth Investigation
p_after_CA = PetriNet.Place("p_after_CA")        # after Claim Assessment
p_after_AP = PetriNet.Place("p_after_AP")        # after Approval
p_after_P = PetriNet.Place("p_after_P")          # after Payment
p_after_N = PetriNet.Place("p_after_N")          # after Notification
p_end = PetriNet.Place("p_end")                  # final closed state

# Add places to net
for pl in [p_start, p_after_C, p_after_CR, p_after_DV, p_docs_incomplete, p_after_RDS,
           p_after_FC, p_needs_II, p_after_II, p_after_CA, p_after_AP, p_after_P, p_after_N, p_end]:
    net.places.add(pl)

# Transitions (labeled where they represent activities)
t_C = PetriNet.Transition("t_C", "C")           # Insurance Claim filed
t_CR = PetriNet.Transition("t_CR", "CR")        # Claim Registration
t_DV = PetriNet.Transition("t_DV", "DV")        # Document Verification
t_RDS = PetriNet.Transition("t_RDS", "RDS")     # Re-Document Submission
t_FC = PetriNet.Transition("t_FC", "FC")        # Fraud Check
t_II = PetriNet.Transition("t_II", "II")        # In-depth Investigation
t_CA = PetriNet.Transition("t_CA", "CA")        # Claim Assessment
t_AP = PetriNet.Transition("t_AP", "AP")        # Approval
t_P = PetriNet.Transition("t_P", "P")           # Payment
t_N = PetriNet.Transition("t_N", "N")           # Notification
t_CL = PetriNet.Transition("t_CL", "CL")        # Closure

# Internal routing transitions (silent/unlabeled) to model choices/loops
t_DV_ok = PetriNet.Transition("t_DV_ok", None)          # DV passed
t_DV_incomplete = PetriNet.Transition("t_DV_incomplete", None)  # DV failed -> RDS
t_FC_ok = PetriNet.Transition("t_FC_ok", None)          # FC passed
t_FC_doubt = PetriNet.Transition("t_FC_doubt", None)    # FC requires II
t_AP_needed = PetriNet.Transition("t_AP_needed", None)  # AP required (threshold exceeded)
t_AP_not_needed = PetriNet.Transition("t_AP_not_needed", None)  # AP skipped

# Add transitions to net
for tr in [t_C, t_CR, t_DV, t_RDS, t_FC, t_II, t_CA, t_AP, t_P, t_N, t_CL,
           t_DV_ok, t_DV_incomplete, t_FC_ok, t_FC_doubt, t_AP_needed, t_AP_not_needed]:
    net.transitions.add(tr)

# Arcs
# Start -> Claim filed
petri_utils.add_arc_from_to(p_start, t_C, net)
petri_utils.add_arc_from_to(t_C, p_after_C, net)

# Claim Registration
petri_utils.add_arc_from_to(p_after_C, t_CR, net)
petri_utils.add_arc_from_to(t_CR, p_after_CR, net)

# Document Verification with loop to RDS if incomplete
petri_utils.add_arc_from_to(p_after_CR, t_DV, net)
petri_utils.add_arc_from_to(t_DV, p_after_DV, net)
# Decision after DV
petri_utils.add_arc_from_to(p_after_DV, t_DV_ok, net)          # documents OK
petri_utils.add_arc_from_to(p_after_DV, t_DV_incomplete, net)  # documents incomplete
# If incomplete -> RDS -> back to DV
petri_utils.add_arc_from_to(t_DV_incomplete, p_docs_incomplete, net)
petri_utils.add_arc_from_to(p_docs_incomplete, t_RDS, net)
petri_utils.add_arc_from_to(t_RDS, p_after_RDS, net)
petri_utils.add_arc_from_to(p_after_RDS, t_DV, net)

# If DV OK -> Fraud Check
petri_utils.add_arc_from_to(t_DV_ok, p_after_FC, net)  # route token to FC input place
# (use p_after_FC as input place to FC)
petri_utils.add_arc_from_to(p_after_FC, t_FC, net)
petri_utils.add_arc_from_to(t_FC, p_after_FC)  # produce back to same place for branching

# After FC, either OK -> proceed to CA, or doubt -> II (loop possible)
petri_utils.add_arc_from_to(p_after_FC, t_FC_ok, net)
petri_utils.add_arc_from_to(p_after_FC, t_FC_doubt, net)
# If doubt -> II -> back to FC (loop can repeat multiple times)
petri_utils.add_arc_from_to(t_FC_doubt, p_needs_II, net)
petri_utils.add_arc_from_to(p_needs_II, t_II, net)
petri_utils.add_arc_from_to(t_II, p_after_II, net)
petri_utils.add_arc_from_to(p_after_II, t_FC, net)
# If FC OK -> proceed to CA
p_ready_for_CA = PetriNet.Place("p_ready_for_CA")
net.places.add(p_ready_for_CA)
petri_utils.add_arc_from_to(t_FC_ok, p_ready_for_CA, net)

# Claim Assessment
petri_utils.add_arc_from_to(p_ready_for_CA, t_CA, net)
petri_utils.add_arc_from_to(t_CA, p_after_CA, net)

# After CA, either Approval needed or not (silent routing)
petri_utils.add_arc_from_to(p_after_CA, t_AP_needed, net)
petri_utils.add_arc_from_to(p_after_CA, t_AP_not_needed, net)

# If approval needed -> AP -> join; if not -> skip to join
p_after_AP_decision = PetriNet.Place("p_after_AP_decision")
net.places.add(p_after_AP_decision)
petri_utils.add_arc_from_to(t_AP_needed, p_after_AP, net)
petri_utils.add_arc_from_to(p_after_AP, t_AP, net)
petri_utils.add_arc_from_to(t_AP, p_after_AP_decision, net)
petri_utils.add_arc_from_to(t_AP_not_needed, p_after_AP_decision, net)

# Payment
petri_utils.add_arc_from_to(p_after_AP_decision, t_P, net)
petri_utils.add_arc_from_to(t_P, p_after_P, net)

# Notification
petri_utils.add_arc_from_to(p_after_P, t_N, net)
petri_utils.add_arc_from_to(t_N, p_after_N, net)

# Closure -> end
petri_utils.add_arc_from_to(p_after_N, t_CL, net)
petri_utils.add_arc_from_to(t_CL, p_end, net)

# Initial and final markings
im = Marking()
im[p_start] = 1

fm = Marking()
fm[p_end] = 1
```
