# DuckDB SQL: Filter Cases with Six or Fewer Events

## Understanding the Problem

We need to:
1. **Count** the number of events per `case_id`.
2. **Exclude** any `case_id` where the count exceeds six.
3. **Return all event columns** for the remaining (qualifying) cases.

## The Query

```sql
SELECT *
FROM event_log
WHERE case_id IN (
    SELECT case_id
    FROM event_log
    GROUP BY case_id
    HAVING COUNT(*) <= 6
);
```

## How It Works — Step by Step

| Step | Clause | Purpose |
|------|--------|---------|
| **1** | `GROUP BY case_id` | Groups all events by their process instance. |
| **2** | `HAVING COUNT(*) <= 6` | Retains only those groups (cases) with **at most** six events. |
| **3** | `WHERE case_id IN (…)` | Filters the original table to return **all columns/rows** belonging to qualifying cases. |

### Execution Flow

```
event_log
    
    

  Subquery                
  GROUP BY case_id        
  HAVING COUNT(*) <= 6    
   qualifying case_ids 

           
           

  Outer Query                 
  SELECT * FROM event_log     
  WHERE case_id IN (...)      
   all events for those    
      qualifying cases        

```

## Alternative Approach (Window Function)

For larger datasets or when you want to avoid a subquery with a second scan, a **window-function** approach can be more efficient in DuckDB:

```sql
SELECT *
FROM (
    SELECT *,
           COUNT(*) OVER (PARTITION BY case_id) AS case_event_count
    FROM event_log
) sub
WHERE case_event_count <= 6;
```

### Why this works
- `COUNT(*) OVER (PARTITION BY case_id)` computes the total number of events **per case** and attaches that count to **every row** — no separate grouping pass needed.
- The outer `WHERE` then simply filters on that computed column.

## Key Considerations

- **Correctness**: Both approaches guarantee that *all* columns and *all* rows for qualifying cases are returned — not just aggregated summaries.
- **Performance**: The window-function variant performs a **single scan** of `event_log`, whereas the `IN`-subquery approach may scan the table twice. DuckDB's optimizer often handles both efficiently, but the window approach scales better on very large logs.
- **Ties / Duplicates**: The filter is based purely on the **count of rows** per `case_id`, so duplicate activities or identical timestamps within a case are each counted as separate events.