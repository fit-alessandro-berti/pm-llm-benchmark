Here is a single DuckDB SQL statement that performs all required steps.  
Replace `K` with the desired number of top variants (e.g., `3`):

```sql
WITH ordered_events AS (
    -- 1. Ensure events are ordered within each case by timestamp
    SELECT
        case_id,
        activity,
        "timestamp"
    FROM event_log
    QUALIFY TRUE  -- no-op; DuckDB just uses ORDER BY below
    ORDER BY case_id, "timestamp"
),
case_variants AS (
    -- 2. Build the ordered sequence (variant) per case
    SELECT
        case_id,
        STRING_AGG(activity, '->' ORDER BY "timestamp") AS variant
    FROM event_log
    GROUP BY case_id
),
variant_counts AS (
    -- 3. Count cases per variant
    SELECT
        variant,
        COUNT(*) AS case_count
    FROM case_variants
    GROUP BY variant
),
top_k_variants AS (
    -- 4. Select the top K variants by frequency
    SELECT
        variant,
        case_count
    FROM variant_counts
    ORDER BY case_count DESC
    LIMIT K
),
top_k_cases AS (
    -- 5. Keep only cases whose variant is in the top K
    SELECT
        cv.case_id
    FROM case_variants cv
    JOIN top_k_variants tv
      ON cv.variant = tv.variant
)
-- 6. Return all events from the original log for those top-K cases
SELECT
    el.*
FROM event_log el
JOIN top_k_cases tkc
  ON el.case_id = tkc.case_id
ORDER BY el.case_id, el."timestamp";
```

Explanation of main pieces:

- `case_variants`: builds a variant string per `case_id` using `STRING_AGG(activity, '->' ORDER BY timestamp)`.
- `variant_counts`: counts how many cases share each variant.
- `top_k_variants`: picks the top K variants by `case_count`.
- `top_k_cases`: identifies all `case_id`s whose variant is in those top K.
- Final `SELECT`: returns all original events for those cases, ordered chronologically within each case.