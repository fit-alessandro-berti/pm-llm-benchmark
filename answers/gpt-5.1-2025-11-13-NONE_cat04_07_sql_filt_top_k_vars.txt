Here’s a single DuckDB SQL query that performs all required steps.  
Assume you want the top `K` variants (replace `:K` with a number or a parameter):

```sql
WITH ordered_events AS (
    -- 1. Ensure activities are ordered within each case by timestamp
    SELECT
        case_id,
        activity,
        "timestamp"
    FROM event_log
    ORDER BY case_id, "timestamp"
),
variants AS (
    -- 2. Build the activity sequence (variant) for each case
    SELECT
        case_id,
        string_agg(activity, '->' ORDER BY "timestamp") AS variant
    FROM ordered_events
    GROUP BY case_id
),
variant_counts AS (
    -- 3. Count how many cases follow each variant
    SELECT
        variant,
        COUNT(*) AS case_count
    FROM variants
    GROUP BY variant
),
top_k_variants AS (
    -- 4. Select the top K variants by frequency
    SELECT
        variant
    FROM variant_counts
    ORDER BY case_count DESC, variant
    LIMIT :K
),
cases_in_top_k AS (
    -- 5. Keep only cases whose variant is one of the top K
    SELECT
        v.case_id
    FROM variants v
    JOIN top_k_variants tk
        ON v.variant = tk.variant
)
-- 6. Return all events for the selected cases, ordered by case and timestamp
SELECT
    e.*
FROM event_log e
JOIN cases_in_top_k c
    ON e.case_id = c.case_id
ORDER BY
    e.case_id,
    e."timestamp";
```

Notes:
- `string_agg(activity, '->' ORDER BY "timestamp")` constructs the ordered sequence of activities per case.
- Replace `:K` with an integer (e.g., `5`) or use DuckDB parameter binding if calling from code.