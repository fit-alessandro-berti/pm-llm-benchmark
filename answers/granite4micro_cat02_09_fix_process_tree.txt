To address the underfitting in the provided "Procure-to-Pay" process tree model and ensure it adheres strictly to the specified order of activities, we need to enforce a proper sequential flow while allowing parallel tasks where appropriate. The key is to distinguish between activities that must happen sequentially versus those that can occur in parallel or are optional.

### Issues with the Current Model

1. **Parallel Block Misuse**: The current model allows for receiving goods and invoices in parallel after creating and approving purchase requisitions, which might not be realistic. These tasks should generally follow the creation of a purchase order but don't necessarily need to happen simultaneously.
   
2. **Invoice Payment Before Receipt**: The structure permits paying an invoice before receiving it, violating the logical flow that requires payment upon receipt of goods.

### Corrected Process Tree Model

Here's how we can refine the model:

```python
from pm4py.objects.process_tree.obj import Operator, ProcessTree

# Define activities with correct sequencing and parallelism.
create_req = ProcessTree(label="Create_Purchase_Requisition")
approve_req = ProcessTree(label="Approve_Purchase_Requisition")

# Sequential step: Create Purchase Order after approval.
create_po = ProcessTree(operator=Operator.SEQUENCE, children=[approve_req], label="Create_Purchase_Order")

# Parallel tasks: Receive Goods and Invoice should be allowed to happen in parallel once the PO is created.
receive_goods = ProcessTree(label="Receive_Goods")
receive_invoice = ProcessTree(label="Receive_Invoice")

# Ensure matching of invoice with PO occurs after both goods and invoice are received, followed by payment.
match_invoice = ProcessTree(operator=Operator.SEQUENCE, children=[receive_goods, receive_invoice], label="Match_Invoice_to_PO")
pay_invoice = ProcessTree(operator=Operator.SEQUENCE, children=[match_invoice], label="Pay_Invoice")

# Closing the case after completing all activities in the procure-to-pay cycle.
close_case = ProcessTree(label="Close_Case")

# Root of the process tree
root = ProcessTree(
    operator=Operator.SEQUENCE,
    children=[
        create_req,
        approve_req,
        create_po,
        receive_goods,
        receive_invoice,
        match_invoice,
        pay_invoice,
        close_case
    ]
)
```

### Explanation

1. **Sequential Activities**: The `create_po` and `match_invoice` activities must occur in strict sequence—once the purchase requisition is approved, a purchase order should be created immediately without waiting for goods or invoices.

2. **Parallel Activity**: Receiving Goods (`receive_goods`) and Receiving Invoices (`receive_invoice`) can happen in parallel after the purchase order is created but before any invoice matching occurs. This reflects that while you receive items and an invoice at roughly the same time, they are independent processes.

3. **Invoice Matching**: The `match_invoice` activity must occur sequentially with both goods received and invoices received, ensuring logical validation of goods against documents like invoices.

4. **Payment**: Only after successful matching does payment (`pay_invoice`) take place, which aligns logically as payment is contingent upon valid goods receipt and invoice matching.

### Ensuring Conformance

The corrected model enforces the correct sequence of activities that mirrors real-world business processes in procure-to-pay cycles:

- **No Payment Before Goods Receipt**: By requiring `receive_goods` and `receive_invoice` to occur before `match_invoice`, we prevent premature payment, which is crucial for financial integrity.
  
- **Logical Sequence Compliance**: Each activity respects its logical prerequisites. For instance, goods must be received before invoices can be matched.

This structure ensures that the process tree conforms tightly to domain logic, reducing the possibility of invalid or incomplete cycles and allowing only the intended progression from procurement through payment.