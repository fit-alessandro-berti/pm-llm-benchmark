# DuckDB Process Variant Analysis Query

Here's a comprehensive solution that handles process variant extraction, ranking, and filtering:

```sql
-- Main query to identify top K variants and return their events
WITH RECURSIVE 
-- Step 1: Build the ordered sequence of activities for each case
case_sequences AS (
  SELECT 
    case_id,
    activity,
    timestamp,
    ROW_NUMBER() OVER (PARTITION BY case_id ORDER BY timestamp, activity) AS activity_order
  FROM event_log
),

-- Step 2: Aggregate activities into a sequence string per case
variant_sequences AS (
  SELECT 
    case_id,
    STRING_AGG(activity, '  ' ORDER BY activity_order) AS variant_sequence
  FROM case_sequences
  GROUP BY case_id
),

-- Step 3: Count cases per variant and rank by frequency
variant_rankings AS (
  SELECT 
    variant_sequence,
    COUNT(DISTINCT case_id) AS case_count,
    ROW_NUMBER() OVER (ORDER BY COUNT(DISTINCT case_id) DESC) AS variant_rank
  FROM variant_sequences
  GROUP BY variant_sequence
),

-- Step 4: Select top K variants (set K value here)
top_k_variants AS (
  SELECT 
    variant_sequence,
    case_count,
    variant_rank
  FROM variant_rankings
  WHERE variant_rank <= 10  -- Set K = 10 (adjust as needed)
),

-- Step 5: Get case_ids belonging to top K variants
top_k_cases AS (
  SELECT DISTINCT vs.case_id
  FROM variant_sequences vs
  INNER JOIN top_k_variants tkv 
    ON vs.variant_sequence = tkv.variant_sequence
)

-- Step 6: Return all events from cases in top K variants
SELECT 
  el.*
FROM event_log el
INNER JOIN top_k_cases tkc 
  ON el.case_id = tkc.case_id
ORDER BY el.case_id, el.timestamp;
```

---

## Enhanced Version with Statistics

If you want additional metrics and metadata:

```sql
WITH RECURSIVE 
case_sequences AS (
  SELECT 
    case_id,
    activity,
    timestamp,
    ROW_NUMBER() OVER (PARTITION BY case_id ORDER BY timestamp ASC) AS activity_order
  FROM event_log
),

variant_sequences AS (
  SELECT 
    case_id,
    STRING_AGG(activity, '  ' ORDER BY activity_order) AS variant_sequence,
    COUNT(*) AS sequence_length
  FROM case_sequences
  GROUP BY case_id
),

variant_rankings AS (
  SELECT 
    variant_sequence,
    COUNT(DISTINCT case_id) AS case_count,
    AVG(sequence_length) AS avg_length,
    MIN(sequence_length) AS min_length,
    MAX(sequence_length) AS max_length,
    ROW_NUMBER() OVER (ORDER BY COUNT(DISTINCT case_id) DESC) AS variant_rank
  FROM variant_sequences
  GROUP BY variant_sequence
),

top_k_variants AS (
  SELECT 
    variant_sequence,
    case_count,
    avg_length,
    min_length,
    max_length,
    variant_rank
  FROM variant_rankings
  WHERE variant_rank <= 10
),

top_k_cases AS (
  SELECT DISTINCT vs.case_id
  FROM variant_sequences vs
  INNER JOIN top_k_variants tkv 
    ON vs.variant_sequence = tkv.variant_sequence
)

SELECT 
  el.case_id,
  el.activity,
  el.timestamp,
  vs.variant_sequence,
  tkv.case_count,
  tkv.variant_rank
FROM event_log el
INNER JOIN top_k_cases tkc ON el.case_id = tkc.case_id
INNER JOIN variant_sequences vs ON el.case_id = vs.case_id
INNER JOIN top_k_variants tkv ON vs.variant_sequence = tkv.variant_sequence
ORDER BY tkv.variant_rank, el.case_id, el.timestamp;
```

---

## Parameterized Version (for reusability)

```sql
-- Define K parameter
DECLARE K INTEGER DEFAULT 10;

WITH case_sequences AS (
  SELECT 
    case_id,
    activity,
    timestamp,
    ROW_NUMBER() OVER (PARTITION BY case_id ORDER BY timestamp) AS seq_order
  FROM event_log
),

variant_sequences AS (
  SELECT 
    case_id,
    STRING_AGG(activity, '  ' ORDER BY seq_order) AS variant
  FROM case_sequences
  GROUP BY case_id
),

variant_stats AS (
  SELECT 
    variant,
    COUNT(*) AS frequency,
    ROW_NUMBER() OVER (ORDER BY COUNT(*) DESC) AS rank
  FROM variant_sequences
  GROUP BY variant
),

top_variants AS (
  SELECT variant FROM variant_stats WHERE rank <= K
)

SELECT el.*
FROM event_log el
WHERE el.case_id IN (
  SELECT vs.case_id 
  FROM variant_sequences vs
  WHERE vs.variant IN (SELECT variant FROM top_variants)
)
ORDER BY el.case_id, el.timestamp;
```

---

## Key Features

| Feature | Implementation |
|---------|----------------|
| **Ordered Sequences** | `ROW_NUMBER()` over `timestamp` per `case_id` |
| **Variant Identification** | `STRING_AGG()` to build pipe-separated sequences |
| **Frequency Counting** | `COUNT(DISTINCT case_id)` per variant |
| **Top K Selection** | `ROW_NUMBER()` ranking + `WHERE rank <= K` |
| **Event Filtering** | `INNER JOIN` on case_ids matching top variants |

---

## Usage Notes

- **Adjust K**: Change the `K = 10` parameter to your desired number of top variants
- **Variant Separator**: Modify `'  '` to any preferred delimiter
- **Performance**: For very large logs, consider indexing `(case_id, timestamp)`
- **Ties**: `ROW_NUMBER()` breaks ties arbitrarily; use `RANK()` to include all tied variants