### What the model says the loan process looks like (in plain terms)

Because every constraint has support/confidence **1.0**, you can read these as **hard business rules** that should always hold.

1. **Start by receiving the application**  
   - `init(Receive_Application)` + `existence(Receive_Application)` means every case begins with **Receive_Application** (and it must happen at least once).

2. **Run exactly one preliminary credit check (and it must be after intake)**  
   - `response(Receive_Application  Preliminary_Credit_Check)` forces a credit check after the application is received.  
   - `exactly_one(Preliminary_Credit_Check)` prevents repeated credit pulls (costly, and can harm the customer’s credit score).

3. **Collect additional documents (and only after the credit check)**  
   - `existence(Gather_Additional_Documents)` makes document collection mandatory in every case.  
   - `succession(Preliminary_Credit_Check  Gather_Additional_Documents)` enforces **both**:
     - if you do the credit check, you must later gather documents, and
     - if you gather documents, a credit check must have happened before.

4. **After each document-gathering round, perform a QA/compliance review (and they “alternate”)**  
   - `altsuccession(Gather_Additional_Documents  Quality_Assurance_Review)` creates an iterative pattern like:
     - Gather docs  QA review  (if needed) Gather more docs  QA review  …
   This prevents “collecting documents endlessly without validating them,” and also prevents QA reviews happening without a preceding document-gathering step.

5. **Once QA happens, the offer package is assembled immediately, then funds are transferred immediately**  
   - `chainsuccession(Quality_Assurance_Review  Assemble_Loan_Offer_Package)` means QA is **immediately followed** by assembling the offer package.  
   - `chainresponse(Assemble_Loan_Offer_Package  Transfer_Funds)` means assembling the offer is **immediately followed** by transferring funds.  
   - `responded_existence(Assemble_Loan_Offer_Package  Quality_Assurance_Review)` guarantees that if an offer package is assembled at all, **a QA review exists somewhere** (this becomes redundant if you already enforce the chain QA  Assemble).

   Practically, these “chain” constraints describe a **straight-through/automated handoff**: once QA clears, the system (or ops team) immediately produces the final package and disburses.

6. **Authorizing contract terms must happen (and must be backed by documents and QA first)**  
   - `coexistence(Gather_Additional_Documents, Authorize_Contract_Terms)` forces **both-or-neither**:  
     - you don’t authorize terms without having gathered documents, and
     - if you gather documents (which is mandatory here), authorization must occur at some point.
   - `precedence(Quality_Assurance_Review  Authorize_Contract_Terms)` means authorization can only happen if QA review happened earlier.

7. **Customer notification is tightly controlled around fund transfers**  
   - `altprecedence(Notify_Customer  Transfer_Funds)` forces that before each transfer there was a notification “since the previous transfer” (so transfers can’t happen “out of the blue”).  
   - `altresponse(Transfer_Funds  Notify_Customer)` forces that after each transfer, a notification must happen before any later transfer.

   Together, these imply a practical pattern like: **Notify  Transfer  Notify** (at least one “pre” message and one “post” confirmation per transfer, and no repeated transfers without intervening communication).

8. **Don’t continue core underwriting after customer notification**  
   - `nonsuccession(Notify_Customer  Preliminary_Credit_Check)` prevents doing the **preliminary credit check after notifying**—a proxy for “once you’ve communicated the outcome/status, don’t keep doing fundamental decisioning steps.”

9. **Don’t notify immediately after authorization**  
   - `nonchainsuccession(Authorize_Contract_Terms  Notify_Customer)` prevents an immediate “Authorize  Notify” jump, suggesting there must be some intervening work (booking the loan, verifying signatures, disbursement setup, etc.) before messaging the customer.

10. **A forbidden shortcut must never occur**  
   - `absence(Proceed_Without_Compliance)` encodes a non-negotiable rule: the process must **never** bypass mandatory compliance controls.

---

### Why these rules exist (real-world motivations)

- **Risk management:** credit check early (and only once) to avoid wasting effort on ineligible applicants and to reduce unnecessary bureau pulls.
- **Fraud prevention + KYC/AML:** mandatory document collection plus QA review cycles ensure identity, income, and authenticity checks happen before binding commitments.
- **Operational best practices:** alternating doc/QA cycles reduce rework; chain constraints reflect automation and tight handoffs once QA clears.
- **Regulatory/audit needs:** QA-before-authorization supports evidence that approvals were compliant and reviewed.
- **Customer satisfaction:** strong “transfer  notify” coupling prevents surprise deposits/withdrawals and reduces “Where is my money?” contacts.

---

### What can go wrong if steps are skipped or reordered

- **Transfer funds before QA / without proper authorization:** direct financial loss, funding fraud, severe regulatory exposure, costly reversals.
- **Skip document collection:** inability to prove identity/income  AML/KYC breaches, higher default/fraud rates.
- **Skip QA review:** incorrect pricing/terms, missing disclosures, policy violations, audit findings.
- **Run multiple credit checks:** customer dissatisfaction, possible consent/compliance issues, unnecessary cost.
- **Notify incorrectly (too early/too late):** broken expectations, complaints, reputational damage; notifying “approved” before funding is actually executed creates avoidable incidents.

---

### Important modeling caveat (consistency)

Under standard DECLARE semantics, two constraints appear to **conflict** with the rest:

- `noncoexistence(Transfer_Funds, Receive_Application)` would forbid any case that both receives an application **and** transfers funds—yet other constraints (docs  QA  assemble  transfer) effectively make **Transfer_Funds** unavoidable.  
- `chainprecedence(Authorize_Contract_Terms, Preliminary_Credit_Check)` also clashes with the enforced order credit check  docs  QA  authorization.

If the intent was “**don’t transfer funds until after receiving the application**” and “**authorize only after checks**,” those are usually expressed with **precedence/succession** constraints rather than noncoexistence/chainprecedence in the shown direction.