1. Anomalies in the DECLARE model

Given constraints:

- init: R
- existence: C
- responded_existence: E  A
- precedence: C  R
- noncoexistence: E ! C (E and C cannot coexist)

Key anomalies:

- A1: Mandatory close vs. forbidden coexistence with evaluation
  - existence(C) requires that C occurs in every trace.
  - noncoexistence(E, C) forbids E and C appearing together.
  - Result: Any trace that contains E becomes non-compliant, because C is required but cannot coexist with E.
  - Effectively, E is disallowed in all valid traces, which contradicts a realistic claims process where evaluation is essential.

- A2: Responded-existence direction is inverted for E and A
  - responded_existence(E: activities=[A]) means:
    - If E occurs, A must also occur (at least once in the trace), but
    - It does NOT require A to precede E; A could occur after E.
  - This allows evaluation before assignment, which undermines the intended flow where an adjuster is assigned before evaluation.

- A3: Precedence(C: activities=[R]) is underspecified
  - precedence(C: [R]) means C can only occur if R occurred before.
  - While this is reasonable (no closing without receiving), it:
    - Does not require other intermediate steps (A, E, P, N).
    - Combined with noncoexistence(E, C), it implicitly supports traces like R  C, skipping evaluation and all other key activities.

- A4: Missing constraints for core steps (A, E, P, N)
  - No:
    - requirement to perform A, E, P, N at all;
    - ordering constraints R  A  E  P  N  C;
    - linkage between A and adjuster specialization or claim_type.
  - This allows:
    - Claims closed without assignment, evaluation, approval, or notification.
    - Arbitrary or disordered execution paths inconsistent with the intended business logic.

- A5: Practical contradiction with typical business rules
  - Typical intent: any claim that is closed should normally have been evaluated.
  - Model: systematically prevents E from coexisting with C, thereby formalizing a behavior (closing without evaluation) that is likely undesired.


2. Hypotheses for why these anomalies exist

- H1: Misinterpretation of dependency semantics
  - The modeler may have:
    - Inverted the direction of responded_existence for E and A.
    - Misused noncoexistence(E, C) instead of a weaker constraint (e.g., E must precede C or C requires E).

- H2: Partial or obsolete translation of changing policies
  - Policies might have evolved (e.g., new fast-track rules, new audit requirements).
  - Some constraints were updated (e.g., mandatory closing logged as C), but others (like noncoexistence or E-related rules) were not removed or realigned.

- H3: Overfitting to noisy or incomplete event data
  - If historical logs:
    - Rarely recorded E before C, or had missing E events,
    - An automated discovery tool might:
      - Infer noncoexistence(E, C) incorrectly,
      - Infer responded_existence in the wrong direction due to spurious correlations.

- H4: Performance or SLA-driven shortcuts
  - Pressure to close claims quickly (e.g., small or auto-approved claims) may:
    - Encourage direct R  C flows.
    - Lead someone to encode constraints that implicitly allow skipping E, while accidentally blocking proper E+C combinations.

- H5: Ambiguous interpretation of E and C
  - E might be used inconsistently (e.g., only for complex claims).
  - C might be used for technical closure, not “business closure”.
  - Constraints may have been designed without a clear, shared definition of each activity.


3. SQL-based verification strategies

Note: Adapt table/column names as needed; queries assume claim_events.activity uses single-letter codes.

3.1. Claims closed without evaluation (C with no E)

- Goal: Check if undesired R  C-without-E behavior is present.

SQL:
SELECT
    ce.claim_id
FROM claim_events ce
GROUP BY ce.claim_id
HAVING
    BOOL_OR(ce.activity = 'C')
    AND NOT BOOL_OR(ce.activity = 'E');

3.2. Traces where E and C coexist (violations of noncoexistence(E, C))

- Goal: Detect real-life evidence contradicting the noncoexistence constraint.

SQL:
SELECT
    ce.claim_id
FROM claim_events ce
GROUP BY ce.claim_id
HAVING
    BOOL_OR(ce.activity = 'E')
    AND BOOL_OR(ce.activity = 'C');

3.3. Traces where C occurs without prior R (violations of intended precedence)

- Goal: Ensure that closing never happens before receiving.

SQL:
SELECT DISTINCT c_close.claim_id
FROM claim_events c_close
LEFT JOIN LATERAL (
    SELECT 1
    FROM claim_events c_r
    WHERE c_r.claim_id = c_close.claim_id
      AND c_r.activity = 'R'
      AND c_r.timestamp < c_close.timestamp
    LIMIT 1
) prior_r ON TRUE
WHERE c_close.activity = 'C'
  AND prior_r IS NULL;

3.4. Traces where E occurs without any A (violations of “evaluations should be assigned”)

- Goal: Check if evaluation is done when no adjuster was assigned.

SQL:
SELECT
    ce.claim_id
FROM claim_events ce
GROUP BY ce.claim_id
HAVING
    BOOL_OR(ce.activity = 'E')
    AND NOT BOOL_OR(ce.activity = 'A');

3.5. Cases where E occurs before A (verifying anomaly A2)

- Goal: Detect evaluation activities that precede assignment in time.

SQL:
SELECT DISTINCT e.claim_id
FROM claim_events e
JOIN claim_events a
  ON a.claim_id = e.claim_id
WHERE e.activity = 'E'
  AND a.activity = 'A'
  AND e.timestamp < a.timestamp;

(Optionally, restrict to claims having at least one A; if no A exists, they are already caught by 3.4.)

3.6. Check if A, E, P, N are frequently skipped before C

- Goal: Assess how often claims are closed without key steps.

SQL:
SELECT
    ce.claim_id,
    BOOL_OR(ce.activity = 'A') AS has_assign,
    BOOL_OR(ce.activity = 'E') AS has_evaluate,
    BOOL_OR(ce.activity = 'P') AS has_approve,
    BOOL_OR(ce.activity = 'N') AS has_notify,
    BOOL_OR(ce.activity = 'C') AS has_close
FROM claim_events ce
GROUP BY ce.claim_id
HAVING BOOL_OR(ce.activity = 'C');

Use the result to compute proportions of:
- C without E
- C without A
- C without P
- C without N

3.7. Alignment between A and adjusters table (sanity check on assignment quality)

- Goal: Confirm that assigned resources are valid adjusters and plausibly specialized.

Example: assignments where resource is not a known adjuster.

SQL:
SELECT DISTINCT
    ce.claim_id,
    ce.resource
FROM claim_events ce
LEFT JOIN adjusters a
  ON ce.resource::VARCHAR = a.name
WHERE ce.activity = 'A'
  AND a.adjuster_id IS NULL;

Example: mismatch between claim_type and adjuster specialization (requires joining claims).

-- Home claims evaluated by non-home specialists (as an example check)
SELECT DISTINCT
    c.claim_id,
    c.claim_type,
    ce.resource AS evaluator,
    a.specialization
FROM claim_events ce
JOIN claims c
  ON c.claim_id = ce.claim_id
JOIN adjusters a
  ON ce.resource::VARCHAR = a.name
WHERE ce.activity = 'E'
  AND c.claim_type = 'home_insurance'
  AND a.specialization <> 'home';

3.8. Order conformance to intended ideal flow (R  A  E  P  N  C)

- Goal: Measure how often traces respect the intended ordering (even though the model doesn’t enforce it).

Illustrative check for any step out-of-order relative to C:

SELECT DISTINCT ce.claim_id
FROM claim_events ce
WHERE ce.activity = 'C'
  AND EXISTS (
      SELECT 1 FROM claim_events x
      WHERE x.claim_id = ce.claim_id
        AND x.activity IN ('R','A','E','P','N')
        AND x.timestamp > ce.timestamp
  );

These queries, taken together, show whether the anomalies in the model are artifacts of poor specification or are actually reflected (or contradicted) by real execution data.