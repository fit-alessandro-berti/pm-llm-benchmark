**Trace that the model accepts but that is illegal in a “real” OrdertoCash process**

```
Receive_Order,
Check_Inventory,
Ship_Order,
Authorize_Payment,
Package_Items,
Close_Order
```

---

### Why this trace is problematic

1. **Domain rule** – In a standard OrdertoCash flow the **payment must be authorized before the goods are shipped**.  
   The business reason is simple: the company should not hand over product until it is sure that the customer has paid (or at least that the payment is guaranteed).

2. **What the model does** –  
   * The root of the tree forces the sequence `Receive_Order  Check_Inventory  XOR  Close_Order`.  
   * Inside the XOR the **successful branch** is defined as a **parallel** operator (`PARALLEL`) whose children are `Authorize_Payment`, `Package_Items` and `Ship_Order`.  
   * A parallel operator imposes **no ordering constraints** among its children – any interleaving of the three activities is considered a valid execution of that branch.

3. **Consequences** – Because the three activities are placed in a parallel block, the model treats the ordering  

   ```
   Ship_Order  Authorize_Payment  Package_Items
   ```

   as a perfectly valid execution of the successful branch. The trace above therefore **fits** the tree (it follows the required SEQUENCE up to the XOR, it satisfies the parallel block, and finally it ends with the mandatory `Close_Order`).

4. **Why it must be rejected** – From the business perspective the trace violates the essential constraint *“payment before shipping”*. Allowing a shipment before the payment is authorized would lead to:

   * **Financial risk** – the company may ship product without any guarantee of payment.  
   * **Process inconsistency** – the “OrdertoCash” name itself stresses that cash (or a payment guarantee) is obtained **before** the cash (the product) leaves the warehouse.

Hence the model is **underfitting**: it is too permissive because it does not encode the ordering dependency between `Authorize_Payment` and `Ship_Order`. A correct model would either:

* Replace the `PARALLEL` operator with a **SEQUENCE** that enforces `Authorize_Payment  Package_Items  Ship_Order`, **or**  
* Keep the parallelism for `Package_Items` and `Ship_Order` but make `Authorize_Payment` a **preceding** activity (e.g., a **SEQ** of `Authorize_Payment` followed by a **PARALLEL** of the other two).

---

### (Optional) Another illustration of the same issue

The same underfitting also shows up in the **duplicateclose** problem:

```
Receive_Order,
Check_Inventory,
Cancel_Order,
Close_Order,
Close_Order
```

Because `Close_Order` appears both inside the cancelbranch and again as the final step of the root sequence, the model permits two consecutive `Close_Order` events, which is meaningless in practice. This further demonstrates that the current tree does not capture all necessary domain constraints.