# Analysis of Anomalies in the Insurance Claim POWL Model

---

## 1. Identified Anomalies

### Anomaly 1: Loop Between Evaluation and Approval — `LOOP(E, P)`

In process-tree semantics, `LOOP(E, P)` means: execute **E** (the *do*-body), then optionally execute **P** (the *redo*-body) followed by **E** again, repeating indefinitely. This produces traces such as:

| Possible Trace | Interpretation |
|---|---|
| `E` | Evaluate once, never approve |
| `E  P  E` | Evaluate, approve, re-evaluate |
| `E  P  E  P  E` | Multiple rounds of re-evaluation and re-approval |

**What's wrong:**
- A claim can be *evaluated without ever being approved* (the loop exits after the first `E`).
- A claim can cycle through *multiple approvals and re-evaluations*, which is unusual — normally a claim is evaluated once, then approved or rejected once.
- The final iteration always ends on `E`, meaning the process can terminate mid-evaluation without a conclusive approval step.

### Anomaly 2: XOR Allowing Notification to Be Skipped — `XOR(N, skip)`

The exclusive choice between **Notify Customer (N)** and a **silent/skip transition** means the process model explicitly permits skipping customer notification entirely.

**What's wrong:**
- Customer notification is typically a regulatory or contractual obligation. Allowing it to be silently skipped violates compliance requirements and undermines customer experience.
- There is no guard condition visible in the model — the skip appears unconditional.

### Anomaly 3: Premature Claim Closure via Partial Ordering — `A  C`

The partial order defines these edges:
```
R  A  loop  xor
R  A  C
```

Crucially, the edge `A  C` exists **without** requiring `loop` or `xor` to complete first. There is **no edge** `xor  C`. This means:

- **C is only constrained to occur after A**, not after evaluation, approval, or notification.
- A claim can be **closed immediately after adjuster assignment**, entirely bypassing evaluation (`E`), approval (`P`), and notification (`N`).
- Even if evaluation and notification *do* occur, there is no ordering guarantee that they finish *before* closure — they could execute **concurrently** with `C`.

This is the most severe anomaly: it fundamentally breaks the process integrity.

---

## 2. Hypotheses for Why These Anomalies Exist

### Hypothesis H1: Iterative Rework Was Intentionally Modeled but Over-Generalized (Loop)

**Rationale:** In practice, some claims legitimately require re-evaluation — for example, when new evidence surfaces or an initial evaluation is contested. A business analyst may have introduced the loop to accommodate this. However, the loop structure was implemented too broadly:
- It should have been `LOOP(sequence(E, P), Rework_Trigger)` (evaluate *and* approve as a unit, with an explicit re-open trigger), not `LOOP(E, P)` (which allows exiting after `E` without `P`).
- This suggests **partial implementation of a rework policy** or **miscommunication** between the domain expert (who described "sometimes we re-evaluate") and the process modeler (who encoded it as a generic loop).

### Hypothesis H2: Notification Skip Was a Temporary Workaround That Became Permanent (XOR)

**Rationale:** The skip path may have been introduced to handle edge cases — e.g., claims that are internally withdrawn, duplicate submissions, or test claims — where notification is unnecessary. Over time, the workaround was never removed or refined with proper guard conditions. Alternatively:
- A system migration might have left notification as optional during a transition period.
- There may be a **technical defect** in the notification subsystem, and the skip was added as an escape valve to prevent the entire process from blocking.

### Hypothesis H3: The Premature Close Path Is a Data-Driven Artifact or Modeling Error (Partial Order)

**Rationale:** The `A  C` edge without requiring the evaluation–approval–notification chain could stem from:
- **Fast-track closure for invalid or duplicate claims**: Some claims may be identified as invalid immediately after adjuster assignment and closed without further processing. If this business rule exists, it was modeled as a structural shortcut rather than an explicit XOR branch with a "Reject/Invalidate" activity.
- **Modeling tool limitation or human error**: The modeler may have forgotten to add the `xor  C` edge, or the tool did not enforce completeness of the partial order.
- **Process mining artifact**: If this POWL was *discovered* from event logs, the `A  C` edge may reflect noisy data (e.g., backdated closures, system glitches) that the mining algorithm encoded as a valid path.

### Hypothesis H4: Departmental Silos Led to Inconsistent Requirements

**Rationale:** If the claims department, the adjusters' team, and the customer service unit each contributed requirements independently:
- The claims team may have insisted on the loop for rework flexibility.
- Customer service may not have been consulted on mandatory notification.
- Operations may have required a "close anytime" capability for housekeeping.
- Without end-to-end process ownership, these requirements were stitched together without coherence checks.

---

## 3. Database Queries to Verify Hypotheses

### Query 1: Claims Closed Without Any Evaluation or Approval

*Verifies Anomaly 3 (premature closure) and Hypothesis H3.*

```sql
-- Find claims that have a "Close Claim" event but lack 
-- either "Evaluate Claim" or "Approve Claim" events entirely.
SELECT 
    c.claim_id,
    c.claim_type,
    c.claim_amount,
    c.submission_date,
    close_evt.timestamp AS closed_at
FROM claims c
JOIN claim_events close_evt 
    ON c.claim_id = close_evt.claim_id 
    AND close_evt.activity = 'C'
WHERE NOT EXISTS (
    SELECT 1 
    FROM claim_events e 
    WHERE e.claim_id = c.claim_id 
      AND e.activity = 'E'
)
OR NOT EXISTS (
    SELECT 1 
    FROM claim_events e 
    WHERE e.claim_id = c.claim_id 
      AND e.activity = 'P'
)
ORDER BY close_evt.timestamp DESC;
```

### Query 2: Claims Closed Before Evaluation or Approval Completed (Temporal Check)

*Verifies Anomaly 3 with timestamp-based evidence.*

```sql
-- Find claims where "Close Claim" occurred BEFORE 
-- the last "Evaluate Claim" or "Approve Claim" event.
SELECT 
    ce_close.claim_id,
    ce_close.timestamp AS close_time,
    MAX(ce_eval.timestamp) AS last_evaluation,
    MAX(ce_appr.timestamp) AS last_approval
FROM claim_events ce_close
LEFT JOIN claim_events ce_eval 
    ON ce_close.claim_id = ce_eval.claim_id 
    AND ce_eval.activity = 'E'
LEFT JOIN claim_events ce_appr 
    ON ce_close.claim_id = ce_appr.claim_id 
    AND ce_appr.activity = 'P'
WHERE ce_close.activity = 'C'
GROUP BY ce_close.claim_id, ce_close.timestamp
HAVING ce_close.timestamp < MAX(ce_eval.timestamp)
    OR ce_close.timestamp < MAX(ce_appr.timestamp)
    OR MAX(ce_eval.timestamp) IS NULL
    OR MAX(ce_appr.timestamp) IS NULL;
```

### Query 3: Claims with Multiple Approval Cycles (Loop Evidence)

*Verifies Anomaly 1 and Hypothesis H1.*

```sql
-- Count how many times each claim was evaluated and approved,
-- flagging those with more than one cycle.
SELECT 
    ce.claim_id,
    COUNT(*) FILTER (WHERE ce.activity = 'E') AS eval_count,
    COUNT(*) FILTER (WHERE ce.activity = 'P') AS approve_count
FROM claim_events ce
WHERE ce.activity IN ('E', 'P')
GROUP BY ce.claim_id
HAVING COUNT(*) FILTER (WHERE ce.activity = 'E') > 1
    OR COUNT(*) FILTER (WHERE ce.activity = 'P') > 1
ORDER BY eval_count DESC, approve_count DESC;
```

### Query 4: Claims Evaluated but Never Approved (Loop Exit After E)

*Verifies the loop anomaly — exiting after E without P.*

```sql
-- Claims that have at least one Evaluate event but zero Approve events.
SELECT 
    c.claim_id,
    c.claim_type,
    c.claim_amount,
    MIN(ce.timestamp) AS first_evaluation,
    MAX(ce.timestamp) AS last_evaluation
FROM claims c
JOIN claim_events ce 
    ON c.claim_id = ce.claim_id 
    AND ce.activity = 'E'
WHERE NOT EXISTS (
    SELECT 1 
    FROM claim_events p 
    WHERE p.claim_id = c.claim_id 
      AND p.activity = 'P'
)
GROUP BY c.claim_id, c.claim_type, c.claim_amount
ORDER BY c.claim_amount DESC;
```

### Query 5: Frequency of Skipped Customer Notifications

*Verifies Anomaly 2 and Hypothesis H2.*

```sql
-- Compare claims that include a Notify step vs. those that skip it,
-- among claims that reached the Close stage.
SELECT 
    notified.status,
    COUNT(*) AS claim_count,
    ROUND(100.0 * COUNT(*) / SUM(COUNT(*)) OVER (), 2) AS pct
FROM (
    SELECT 
        c.claim_id,
        CASE 
            WHEN EXISTS (
                SELECT 1 FROM claim_events n 
                WHERE n.claim_id = c.claim_id AND n.activity = 'N'
            ) THEN 'Notified'
            ELSE 'Skipped'
        END AS status
    FROM claims c
    WHERE EXISTS (
        SELECT 1 FROM claim_events cls 
        WHERE cls.claim_id = c.claim_id AND cls.activity = 'C'
    )
) notified
GROUP BY notified.status;
```

### Query 6: Correlation Between Notification Skipping and Claim Attributes

*Deepens investigation into H2 — is skipping correlated with claim type, amount, or region?*

```sql
-- Check if notification skipping correlates with claim type or amount ranges.
SELECT 
    c.claim_type,
    adj.region,
    CASE 
        WHEN c.claim_amount < 1000 THEN 'Low (<1K)'
        WHEN c.claim_amount < 10000 THEN 'Medium (1K-10K)'
        ELSE 'High (>10K)'
    END AS amount_bucket,
    COUNT(*) AS total_closed_claims,
    COUNT(*) FILTER (
        WHERE NOT EXISTS (
            SELECT 1 FROM claim_events n 
            WHERE n.claim_id = c.claim_id AND n.activity = 'N'
        )
    ) AS skipped_notification,
    ROUND(
        100.0 * COUNT(*) FILTER (
            WHERE NOT EXISTS (
                SELECT 1 FROM claim_events n 
                WHERE n.claim_id = c.claim_id AND n.activity = 'N'
            )
        ) / COUNT(*), 2
    ) AS skip_rate_pct
FROM claims c
JOIN claim_events ce_assign 
    ON c.claim_id = ce_assign.claim_id 
    AND ce_assign.activity = 'A'
LEFT JOIN adjusters adj 
    ON ce_assign.resource = adj.name
WHERE EXISTS (
    SELECT 1 FROM claim_events cls 
    WHERE cls.claim_id = c.claim_id AND cls.activity = 'C'
)
GROUP BY c.claim_type, adj.region, amount_bucket
ORDER BY skip_rate_pct DESC;
```

### Query 7: Trace Sequence Validation (Full Conformance Check)

*Holistic check — identifies all claims whose activity sequence deviates from the ideal flow RAEPNC.*

```sql
-- Reconstruct the ordered activity trace for each claim and flag deviations.
WITH traces AS (
    SELECT 
        claim_id,
        STRING_AGG(activity, '  ' ORDER BY timestamp) AS trace
    FROM claim_events
    GROUP BY claim_id
)
SELECT 
    trace,
    COUNT(*) AS num_claims,
    ROUND(100.0 * COUNT(*) / SUM(COUNT(*)) OVER (), 2) AS pct
FROM traces
GROUP BY trace
ORDER BY num_claims DESC;
```

This produces a frequency distribution of all observed traces, immediately revealing how often the ideal path is followed versus how often anomalous paths (premature closures, skipped notifications, repeated evaluations) actually occur in the data.

---

## Summary

| Anomaly | Severity | Key Verification Query |
|---|---|---|
| **Loop(E, P)**: Repeated eval/approve cycles; possible exit without approval | Medium | Queries 3 & 4 |
| **XOR(N, skip)**: Customer notification silently skippable | Medium–High | Queries 5 & 6 |
| **A  C without requiring loop/xor**: Premature closure | **Critical** | Queries 1 & 2 |
| **Missing xor  C edge**: No guarantee notification precedes closure | High | Query 2 (temporal) |

If the queries confirm that these anomalous paths are actually taken in production data (especially premature closures and systematic notification skipping), the process model should be corrected by: (1) adding the `xor  C` edge, (2) removing the `A  C` shortcut (or replacing it with an explicit reject/invalidate branch), (3) making notification mandatory, and (4) restructuring the loop so that approval is not optional within each iteration.