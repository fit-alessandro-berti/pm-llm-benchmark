# Step-by-step DuckDB solution

```sql
WITH
/* 1. let every event remember its position in its case */
numbered AS (
  SELECT *,
         row_number() OVER (PARTITION BY case_id ORDER BY timestamp) AS n
  FROM event_log
),

/* 2. build 3-line sliding windows that contain the exact sequence */
sequence_candidates AS (
  SELECT a.case_id,                 -- case that owns the three events
         a.timestamp AS ts_approve, -- start of sequence
         b.timestamp AS ts_create,  -- middle event
         c.timestamp AS ts_confirm  -- end of sequence
  FROM numbered a
  JOIN numbered b  -- following row
       ON b.case_id = a.case_id
      AND b.n = a.n + 1
  JOIN numbered c  -- row after the following row
       ON c.case_id = a.case_id
      AND c.n = b.n + 1
  WHERE a.activity = 'Approve Purchase Requisition'
    AND b.activity = 'Create Order'
    AND c.activity = 'Confirm Order'
),
/* 3. keep those windows only if create->confirm took > 5 days */
bad_cases AS (
  SELECT DISTINCT case_id
  FROM sequence_candidates
  WHERE ts_confirm - ts_create > INTERVAL '5 day'
)

/* 4. return every event EXCEPT those that sit in a bad case */
SELECT case_id, activity, timestamp
FROM event_log
WHERE case_id NOT IN (SELECT case_id FROM bad_cases)
ORDER BY case_id, timestamp;
```

## What the query does

1. `numbered` numbers the events in each case chronologically.
2. `sequence_candidates` finds every instance in which  
   “Approve Purchase Requisition  Create Order  Confirm Order”  
   appear consecutively (no gap).
3. `bad_cases` keeps only the cases whose create-to-confirm interval exceeds 5 days.
4. The final `SELECT` returns the complete log *minus* all events from the cases that matched the unwanted behaviour.