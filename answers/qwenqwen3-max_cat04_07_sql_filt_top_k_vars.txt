Here's a DuckDB SQL query that accomplishes all the requirements:

```sql
WITH case_sequences AS (
    -- Step 1: Construct the ordered sequence of activities for each case_id
    SELECT 
        case_id,
        STRING_AGG(activity, ' -> ' ORDER BY timestamp) AS variant_sequence
    FROM event_log
    GROUP BY case_id
),
variant_counts AS (
    -- Step 2 & 3: Group by variant sequence and count cases, then get top K variants
    SELECT 
        variant_sequence,
        COUNT(*) AS variant_count
    FROM case_sequences
    GROUP BY variant_sequence
    ORDER BY variant_count DESC
    LIMIT K
),
top_k_cases AS (
    -- Get all case_ids that belong to the top K variants
    SELECT DISTINCT cs.case_id
    FROM case_sequences cs
    INNER JOIN variant_counts vc 
        ON cs.variant_sequence = vc.variant_sequence
)
-- Step 4: Return all events from cases that are part of the top K variants
SELECT el.*
FROM event_log el
INNER JOIN top_k_cases tkc 
    ON el.case_id = tkc.case_id
ORDER BY el.case_id, el.timestamp;
```

**Key components explained:**

1. **`case_sequences` CTE**: Uses `STRING_AGG(activity, ' -> ' ORDER BY timestamp)` to create an ordered sequence string for each `case_id`. The `ORDER BY timestamp` within the aggregation ensures activities are concatenated in chronological order.

2. **`variant_counts` CTE**: Groups by the `variant_sequence` to count how many cases follow each unique variant, then orders by count in descending order and limits to the top K variants using `LIMIT K`.

3. **`top_k_cases` CTE**: Joins back to get all `case_id`s that belong to the top K variants identified in the previous step.

4. **Final SELECT**: Returns all original events from the `event_log` table, but only for cases that are in the `top_k_cases` set, maintaining the original event structure.

**Usage note**: Replace `K` in the `LIMIT K` clause with your desired number of top variants (e.g., `LIMIT 5` for top 5 variants).

**Alternative without delimiter**: If you prefer a cleaner sequence representation without the `' -> '` delimiter, you can use:
```sql
STRING_AGG(activity, '' ORDER BY timestamp) AS variant_sequence
```
However, the delimiter makes the sequences more readable and helps avoid ambiguity when activity names might be substrings of each other.

The query efficiently handles all requirements while maintaining good performance through proper use of CTEs and joins.