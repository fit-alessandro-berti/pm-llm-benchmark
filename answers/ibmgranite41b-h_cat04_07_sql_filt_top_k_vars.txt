To achieve the task as described, we'll follow these steps in our DuckDB query:

1. **Extract Ordered Activity Sequences**: We will first compute a sequence of activities for each `case_id` by sorting the events within each case based on their `timestamp`.

2. **Group and Count Variants**: Next, we group cases by this ordered activity sequence to identify unique process variants. Then, we count how many times each variant appears across all cases.

3. **Identify Top K Variants**: We determine the top K most frequent variants based on our counts from step 2.

4. **Filter Events**: Finally, we filter the original event log to include only those events that belong to cases part of these top K variants and return them.

Here is a DuckDB SQL query that accomplishes this:

```sql
-- Step 1: Extract ordered activity sequences per case_id
WITH OrderedActivities AS (
    SELECT 
        case_id,
        STRING_AGG(activity, ', ') OVER (PARTITION BY case_id ORDER BY timestamp) AS order_sequence
    FROM event_log
)

-- Step 2: Group by the sequence to count cases and find top K variants
SELECT
    order_sequence,
    COUNT(*) AS variant_count
FROM OrderedActivities
GROUP BY order_sequence

-- Determine the Top K Variants based on their frequency (number of cases)
WITH RankedVariants AS (
    SELECT 
        order_sequence, 
        variant_count,
        ROW_NUMBER() OVER (ORDER BY variant_count DESC) AS rn
    FROM (
        SELECT 
            order_sequence,
            COUNT(*) AS variant_count
        FROM OrderedActivities
        GROUP BY order_sequence
    )
)

-- Step 3: Filter events to only those from top K variants
SELECT DISTINCT event_log.*
FROM event_log, RankedVariants
WHERE RankedVariants.rn <= :top_k   -- Replace :top_k with the desired number of top variants

ORDER BY RankedVariants.variant_count DESC;
```

### Explanation:

- **Step 1 (OrderedActivities)**: Uses `STRING_AGG` to concatenate activities for each case_id, ordered by their timestamps. This sequence is stored as a column in our CTE.

- **Step 2**: Groups the data by this newly created order_sequence to count how many cases fall into each variant and determines top K variants using window functions (`ROW_NUMBER`). Variants are ranked based on their frequency (number of cases), with `rn` representing the rank. Replace `:top_k` with your desired number for the top variants.

- **Step 3**: Filters back to the original event log, keeping only events that belong to cases which have a sequence in one of our top K ranks (`rn <= :top_k`). This ensures we only return events from relevant case sequences.

- The final `SELECT` returns all distinct records (events) matching these criteria. You can adjust the column list and ordering as needed for your specific requirements.

### Notes:

- Replace `:top_k` with the desired number of top variants you wish to filter by.
- Ensure that there are no null values in columns used for sorting or grouping (`case_id`, `activity`, `timestamp`) to avoid unexpected behavior.
- This query assumes all activities within a case follow chronological order based on their timestamps. If this assumption does not hold, the activity ordering could be incorrect and would need adjustment.

This solution leverages DuckDB's window functions efficiently to group by sequences, count occurrences, rank variants, and filter down events accordingly, providing an elegant way to extract relevant subsets from large logs.