<think>
 The user wants a Python dictionary representing a DECLARE model for a product design and launch process. I need to map the activities to appropriate DECLARE constraints based on the process description.

 Activities:
 - IG (Idea Generation)
 - DD (Design Draft)
 - TFC (Technical Feasibility Check)
 - CE (Cost Evaluation)
 - PC (Prototype Creation)
 - LT (Laboratory Testing)
 - UT (User Testing)
 - AG (Approval Gate)
 - MP (Marketing Plan)
 - FL (Final Launch)

 Process flow (logical):
 1. IG - must happen (existence), typically starts the process (init)
 2. DD - follows IG
 3. TFC and CE - can happen after DD, maybe in parallel or sequence?
 4. PC - after design is feasible and costs evaluated
 5. LT and UT - testing phases after prototype
 6. AG - approval after testing
 7. MP - after approval (marketing prep)
 8. FL - final step (must happen at end)

 DECLARE constraints to consider:

 Unary constraints:
 - 'existence': All activities should probably exist in the log at some point (or at least the main ones)
 - 'absence': Not sure if any activities should be absent... maybe none for this scenario
 - 'exactly_one': Maybe AG (Approval Gate) happens exactly once? Or FL? Or IG?
 - 'init': IG (Idea Generation) should start the process

 Binary constraints:
 - 'responded_existence': If A happens, B must happen (somewhere)
   - If IG happens, FL must happen (eventually a product is launched or the process is abandoned? Maybe not always)
   - If DD happens, PC should happen? Or AG?
   - If PC happens, LT and UT should happen
   
 - 'coexistence': A and B happen together (if A happens, B happens and vice versa)
   - TFC and CE might coexist (both needed before proceeding)
   - LT and UT might coexist (both testing phases)

 - 'response': If A happens, B must happen after A
   - IG -> DD
   - DD -> TFC
   - DD -> CE
   - TFC -> PC
   - CE -> PC
   - PC -> LT
   - PC -> UT
   - LT -> AG
   - UT -> AG
   - AG -> MP
   - MP -> FL

 - 'precedence': B can only happen if A happened before
   - DD preceded by IG
   - TFC preceded by DD
   - CE preceded by DD
   - PC preceded by TFC and CE
   - LT preceded by PC
   - UT preceded by PC
   - AG preceded by LT and UT
   - MP preceded by AG
   - FL preceded by MP

 - 'succession': Both response and precedence (A before B and B after A)
   - IG -> DD
   - DD -> {TFC, CE}
   - {TFC, CE} -> PC
   - PC -> {LT, UT}
   - {LT, UT} -> AG
   - AG -> MP
   - MP -> FL

 - 'altresponse': If A happens, B must happen after A, without A happening again in between (no repetition of A before B)
   - Useful for milestones: IG -> DD (one idea, one draft? Maybe not strict)
   
 - 'altprecedence': Similar for precedence
   
 - 'altsuccession': Combination

 - 'chainresponse': B must happen immediately after A
   - Maybe MP -> FL (marketing then immediate launch? Not necessarily)
   - Maybe AG -> MP?
   
 - 'chainprecedence': A must happen immediately before B
   
 - 'chainsuccession': Both

 - 'noncoexistence': A and B cannot both happen in the same case
   - Maybe "Product Cancelled" vs "Final Launch", but we don't have cancellation activities
   
 - 'nonsuccession': A cannot be followed by B
   
 - 'nonchainsuccession': A cannot be immediately followed by B

 Let me construct a realistic model:

 Unary:
 - 'init': {'IG': {'support': 1.0, 'confidence': 1.0}} - Process starts with idea generation
 - 'existence': {'IG': ..., 'FL': ...} - Both must happen (start and end)
 - 'exactly_one': {'AG': ..., 'FL': ...} - Approval and Launch happen exactly once per product

 Binary:
 - 'succession': 
   - ('IG', 'DD'): Idea followed by design, and design must be preceded by idea
   - ('DD', 'TFC'): Design then feasibility
   - ('DD', 'CE'): Design then cost eval
   - ('TFC', 'PC'): Feasibility then prototype
   - ('CE', 'PC'): Cost eval then prototype
   - ('PC', 'LT'): Prototype then lab test
   - ('PC', 'UT'): Prototype then user test
   - ('LT', 'AG'): Lab test then approval
   - ('UT', 'AG'): User test then approval
   - ('AG', 'MP'): Approval then marketing
   - ('MP', 'FL'): Marketing then launch

 - 'coexistence':
   - ('TFC', 'CE'): Both must happen if one happens (technical and financial validation go together)
   - ('LT', 'UT'): Both testing phases must coexist

 - 'responded_existence':
   - ('IG', 'FL'): If there's an idea, eventually there should be a launch (or process completion)

 Actually, looking at the format specification again:
 "For the keys ... the value is a dictionary containing as keys the activities and as corresponding value the support (1.0) and confidence of the declarative rule."

 For unary constraints: keys are activities (strings), values are {'support': 1.0, 'confidence': float}

 For binary constraints: keys are activities... but wait, usually in DECLARE models, binary constraints have tuples of activities as keys. Let me re-read carefully.

 "For the keys {'responded_existence', ...}, the value is a dictionary containing as keys the activities and as corresponding value the support (1.0) and confidence of the declarative rule."

 This is ambiguous. Does it mean keys are single activities (for unary) and keys are tuples of activities (for binary)? Or does it mean something else?

 Looking at standard pm4py DECLARE format:
 Typically, for binary constraints, the key is a tuple (activity_a, activity_b).

 Example from pm4py documentation:
 ```python
 declare_model = {
     'existence': {'a': {'support': 1.0, 'confidence': 0.8}},
     'absence': {},
     'exactly_one': {},
     'init': {'a': {'support': 1.0, 'confidence': 0.8}},
     'responded_existence': {('a', 'b'): {'support': 1.0, 'confidence': 0.8}},
     'coexistence': {('a', 'b'): {'support': 1.0, 'confidence': 0.8}},
     'response': {('a', 'b'): {'support': 1.0, 'confidence': 0.8}},
     ...
 }
 ```

 So yes, for binary constraints, the keys should be tuples of two activities.

 Let me structure the model:

 1. **init**: Process must start with IG
    {'IG': {'support': 1.0, 'confidence': 1.0}}

 2. **existence**: Key activities must occur
    {'IG': ..., 'DD': ..., 'FL': ...} - Maybe all main activities, or at least start, middle, end

 3. **exactly_one**: Activities that happen exactly once per case
    {'AG': ..., 'FL': ...} - Approval and Launch are typically once per product

 4. **absence**: Activities that should not happen (empty or maybe activities not in our list, but I'll keep it empty)

 5. **responded_existence**: If A happens, B must happen somewhere in the trace
    - ('IG', 'FL'): If idea generated, eventually launched (or abandoned, but let's say completed)
    - ('DD', 'PC'): If design drafted, eventually prototype created

 6. **coexistence**: If A happens, B happens and vice versa
    - ('TFC', 'CE'): Technical check and cost evaluation go together
    - ('LT', 'UT'): Lab testing and user testing go together

 7. **response**: If A happens, B must happen after A
    - ('IG', 'DD')
    - ('DD', 'TFC')
    - ('DD', 'CE')
    - ('TFC', 'PC')
    - ('CE', 'PC')
    - ('PC', 'LT')
    - ('PC', 'UT')
    - ('LT', 'AG')
    - ('UT', 'AG')
    - ('AG', 'MP')
    - ('MP', 'FL')

 8. **precedence**: B can only happen if A happened before
    - ('IG', 'DD'): DD only if IG before
    - ('DD', 'TFC')
    - ('DD', 'CE')
    - ('TFC', 'PC')
    - ('CE', 'PC')
    - ('PC', 'LT')
    - ('PC', 'UT')
    - ('LT', 'AG')
    - ('UT', 'AG')
    - ('AG', 'MP')
    - ('MP', 'FL')

 9. **succession**: Both response and precedence (A before B and B after A)
    - Many of the above pairs could be succession instead of separate response/precedence
    - Let's put the main flow in succession: ('IG', 'DD'), ('AG', 'MP'), ('MP', 'FL')
    - And maybe ('DD', 'PC') if we consider TFC and CE as optional/detailed steps, but actually they are mandatory

 Actually, to avoid redundancy, I'll use:
 - **succession** for the main linear flow: IG -> DD -> ... -> FL
 - **coexistence** for parallel activities that must both occur
 - **response** for dependencies where order matters but maybe not strict immediate precedence

 But wait, if I use succession for ('IG', 'DD'), I don't need response or precedence for that pair.

 Let me organize:

 Linear flow: IG -> DD -> (TFC || CE) -> PC -> (LT || UT) -> AG -> MP -> FL

 Where (A || B) means A and B happen but can be in any order or parallel.

 Constraints:
 - **init**: IG
 - **existence**: IG, FL (must start and end), maybe all others?
 - **exactly_one**: AG, FL, IG (each product has one idea, one approval, one launch)
 - **succession**: 
   - ('IG', 'DD')
   - ('DD', 'PC') - but only after both TFC and CE... hmm, DECLARE doesn't easily express "A after (B and C)"
   - ('PC', 'AG') - but only after both LT and UT
   - ('AG', 'MP')
   - ('MP', 'FL')
 
 - **coexistence**: ('TFC', 'CE'), ('LT', 'UT') - if one happens, both happen
 - **response**: 
   - ('DD', 'TFC') - design response to TFC
   - ('DD', 'CE')
   - ('PC', 'LT')
   - ('PC', 'UT')
   - ('LT', 'AG')
   - ('UT', 'AG')
 
 - **precedence**: (similar to response pairs but reversed)

 Actually, for binary constraints, I should populate a good variety to show understanding.

 Let me create a comprehensive but realistic model:

 ```python
 declare_model = {
     # Unary constraints
     'existence': {
         'IG': {'support': 1.0, 'confidence': 1.0},
         'DD': {'support': 1.0, 'confidence': 1.0},
         'PC': {'support': 1.0, 'confidence': 1.0},
         'AG': {'support': 1.0, 'confidence': 1.0},
         'MP': {'support': 1.0, 'confidence': 1.0},
         'FL': {'support': 1.0, 'confidence': 1.0}
     },
     'absence': {
         # No activities should be absent in a complete process, or we could put a "Cancellation" activity as absent if we want only successful paths
     },
     'exactly_one': {
         'IG': {'support': 1.0, 'confidence': 1.0},  # One idea per product case
         'AG': {'support': 1.0, 'confidence': 1.0},  # One approval gate
         'FL': {'support': 1.0, 'confidence': 1.0}   # One final launch
     },
     'init': {
         'IG': {'support': 1.0, 'confidence': 1.0}
     },
     
     # Binary constraints
     'responded_existence': {
         ('IG', 'FL'): {'support': 1.0, 'confidence': 1.0},  # If idea exists, eventually launch (successful product)
         ('DD', 'PC'): {'support': 1.0, 'confidence': 1.0},  # If design exists, prototype exists
         ('PC', 'LT'): {'support': 1.0, 'confidence': 1.0},  # If prototype exists, lab test exists
         ('PC', 'UT'): {'support': 1.0, 'confidence': 1.0}   # If prototype exists, user test exists
     },
     'coexistence': {
         ('TFC', 'CE'): {'support': 1.0, 'confidence': 1.0},  # Technical and cost evaluation go together
         ('LT', 'UT'): {'support': 1.0, 'confidence': 1.0}    # Both testings happen together
     },
     'response': {
         ('IG', 'DD'): {'support': 1.0, 'confidence': 1.0},
         ('DD', 'TFC'): {'support': 1.0, 'confidence': 0.9},  # Usually after design, but maybe 90% confidence
         ('DD', 'CE'): {'support': 1.0, 'confidence': 0.9},
         ('TFC', 'PC'): {'support': 1.0, 'confidence': 1.0},
         ('CE', 'PC'): {'support': 1.0, 'confidence': 1.0},
         ('PC', 'LT'): {'support': 1.0, 'confidence': 1.0},
         ('PC', 'UT'): {'support': 1.0, 'confidence': 1.0},
         ('LT', 'AG'): {'support': 1.0, 'confidence': 1.0},
         ('UT', 'AG'): {'support': 1.0, 'confidence': 1.0},
         ('AG', 'MP'): {'support': 1.0, 'confidence': 1.0},
         ('MP', 'FL'): {'support': 1.0, 'confidence': 1.0}
     },
     'precedence': {
         ('IG', 'DD'): {'support': 1.0, 'confidence': 1.0},
         ('DD', 'TFC'): {'support': 1.0, 'confidence': 1.0},
         ('DD', 'CE'): {'support': 1.0, 'confidence': 1.0},
         ('TFC', 'PC'): {'support': 1.0, 'confidence': 1.0},
         ('CE', 'PC'): {'support': 1.0, 'confidence': 1.0},
         ('PC', 'LT'): {'support': 1.0, 'confidence': 1.0},
         ('PC', 'UT'): {'support': 1.0, 'confidence': 1.0},
         ('LT', 'AG'): {'support': 1.0, 'confidence': 1.0},
         ('UT', 'AG'): {'support': 1.0, 'confidence': 1.0},
         ('AG', 'MP'): {'support': 1.0, 'confidence': 1.0},
         ('MP', 'FL'): {'support': 1.0, 'confidence': 1.0}
     },
     'succession': {
         # Using succession for critical handoffs where both order constraints apply strictly
         ('IG', 'DD'): {'support': 1.0, 'confidence': 1.0},
         ('AG', 'MP'): {'support': 1.0, 'confidence': 1.0},
         ('MP', 'FL'): {'support': 1.0, 'confidence': 1.0}
     },
     'altresponse': {
         # Alternative response - no repetition of source before target
         ('IG', 'DD'): {'support': 1.0, 'confidence': 1.0}  # One idea leads to one design draft before another idea
     },
     'altprecedence': {},
     'altsuccession': {},
     'chainresponse': {
         # Immediate succession
         ('AG', 'MP'): {'support': 1.0, 'confidence': 0.8},  # Marketing plan often immediately follows approval
     },
     'chainprecedence': {},
     'chainsuccession': {},
     'noncoexistence': {
         # Activities that cannot happen together (if we had cancellation vs launch, but we don't)
     },
     'nonsuccession': {
         # FL cannot be followed by IG (no launch then new idea in same case)
         ('FL', 'IG'): {'support': 1.0, 'confidence': 1.0},
         ('FL', 'DD'): {'support': 1.0, 'confidence': 1.0}
     },
     'nonchainsuccession': {}
 }
 ```

 Wait, I should check: In 'nonsuccession', the constraint means A cannot be followed by B. So FL cannot be followed by IG makes sense (end of process).

 Also, I need to make sure I cover all the required keys mentioned in the prompt, even if empty.

 The prompt says: "DECLARE model in pm4py is expressed as a Python dictionary containing the following keys" and lists all of them. So I should include all keys in my output, even if they map to empty dictionaries.

 Also, for binary constraints, the keys are tuples of strings.

 Let me verify the format once more:
 - support is 1.0 (as per prompt)
 - confidence is a float (I should vary them slightly to show understanding, or use 1.0 for strict rules)

 Actually, looking at the prompt: "containing as keys the activities and as corresponding value the support (1.0) and confidence"

 It says "support (1.0)" which might mean the value should include 'support': 1.0, and also 'confidence': value.

 So my format is correct.

 Let me refine the model to be more realistic:

 1. **init**: IG starts the process.
 2. **existence**: All activities except maybe some... actually, all activities defined should exist in a complete process trace.
 3. **exactly_one**: IG, FL, AG (critical milestones that happen once). PC might happen multiple times (iterative prototyping), TFC might happen multiple times (re-checks), etc.
 4. **absence**: Empty or perhaps activities from other processes that shouldn't appear here.
 5. **responded_existence**: 
    - ('IG', 'FL'): Complete process from idea to launch
    - ('DD', 'PC'): Design leads to prototype
    - ('PC', 'LT'), ('PC', 'UT'): Prototype leads to testing
 6. **coexistence**: 
    - ('TFC', 'CE'): Both evaluations must occur together
    - ('LT', 'UT'): Both tests must occur together
 7. **response**: The flow from one stage to next
    - ('IG', 'DD')
    - ('DD', 'TFC'), ('DD', 'CE')
    - ('TFC', 'PC'), ('CE', 'PC')
    - ('PC', 'LT'), ('PC', 'UT')
    - ('LT', 'AG'), ('UT', 'AG')
    - ('AG', 'MP')
    - ('MP', 'FL')
 8. **precedence**: Same pairs as response for strict ordering
 9. **succession**: For pairs where both precedence and response hold strictly. I'll pick key transitions: ('IG', 'DD'), ('AG', 'MP'), ('MP', 'FL')
 10. **altresponse**: For strict no-repetition between specific steps, maybe ('PC', 'AG') - one prototype cycle per approval? Or ('IG', 'DD').
 11. **altprecedence**: Empty or similar
 12. **altsuccession**: Empty
 13. **chainresponse**: Immediate steps. Maybe ('AG', 'MP') - approval immediately triggers marketing.
 14. **chainprecedence**: Empty
 15. **chainsuccession**: Empty
 16. **noncoexistence**: Empty (or if I had "Cancel" and "Launch" as mutually exclusive)
 17. **nonsuccession**: Prevent backward jumps. FL should not be followed by anything, but specifically ('FL', 'IG'), ('FL', 'DD'), etc.
 18. **nonchainsuccession**: Specific immediate backward jumps prevented.

 Actually, to make it clean and realistic, I'll use:
 - **succession** for the main linear backbone: IG  DD  PC  AG  MP  FL (simplified)
 - **coexistence** for parallel mandatory activities: (TFC, CE) and (LT, UT)
 - **response** for the detailed dependencies that branch/merge
 - **precedence** for the detailed constraints
 - **exactly_one** for milestones
 - **init** for start

 But using both succession and (response+precedence) for the same pair is redundant. I'll distribute them:
 - Use **succession** for: IGDD, AGMP, MPFL
 - Use **response** for: DDTFC, DDCE, TFCPC, CEPC, PCLT, PCUT, LTAG, UTAG
 - Use **precedence** for: TFCPC, CEPC (to ensure PC has both prerequisites)

 Wait, if I put ('TFC', 'PC') in both response and precedence, that's equivalent to succession. I should avoid duplication or use succession instead.

 Let me organize clearly:

 Unary:
 - existence: IG, DD, TFC, CE, PC, LT, UT, AG, MP, FL (all must happen)
 - absence: {} 
 - exactly_one: IG, AG, FL (unique milestones)
 - init: IG

 Binary:
 - responded_existence: ('IG', 'FL'), ('DD', 'PC'), ('PC', 'LT'), ('PC', 'UT')
 - coexistence: ('TFC', 'CE'), ('LT', 'UT')
 - response: ('IG', 'DD'), ('DD', 'TFC'), ('DD', 'CE'), ('PC', 'LT'), ('PC', 'UT'), ('LT', 'AG'), ('UT', 'AG'), ('AG', 'MP'), ('MP', 'FL'), ('TFC', 'PC'), ('CE', 'PC')
 - precedence: ('IG', 'DD'), ('DD', 'TFC'), ('DD', 'CE'), ('TFC', 'PC'), ('CE', 'PC'), ('PC', 'LT'), ('PC', 'UT'), ('LT', 'AG'), ('UT', 'AG'), ('AG', 'MP'), ('MP', 'FL')
 - succession: {} (or move some critical pairs here instead of separate response/precedence)
 - altresponse: {}
 - altprecedence: {}
 - altsuccession: {}
 - chainresponse: {}
 - chainprecedence: {}
 - chainsuccession: {}
 - noncoexistence: {}
 - nonsuccession: ('FL', 'IG'), ('FL', 'DD'), ('FL', 'AG')... (nothing after FL)
 - nonchainsuccession: {}

 Actually, to show variety and avoid empty sections being boring, I'll populate some of the "alt" and "chain" variants with realistic constraints:
 - **chainresponse**: ('AG', 'MP') - immediate trigger
 - **altresponse**: ('PC', 'AG') - prototype to approval without another prototype in between (if we assume single prototype iteration for simplicity, or exactly_one on PC)
 - **nonsuccession**: ('FL', 'IG'), ('AG', 'DD') (no going back to design after approval)

 Also, I should note that ('TFC', 'PC') and ('CE', 'PC') represent that PC depends on both. In DECLARE, this is modeled as two separate precedence/response constraints.

 Final check on the output format: It should be a Python dictionary literal that can be copied and used.

 I'll provide comments explaining the logic for major constraints.

 One detail: The prompt lists the keys with single quotes like `'existence'`. I should use single quotes in the Python code for consistency, though Python accepts both.

 Structure:
 ```python
 declare_model = {
     'existence': {
         'IG': {'support': 1.0, 'confidence': 1.0},
         'DD': {'support': 1.0, 'confidence': 1.0},
         ...
     },
     'absence': {},
     'exactly_one': {
         'IG': {'support': 1.0, 'confidence': 1.0},
         ...
     },
     'init': {
         'IG': {'support': 1.0, 'confidence': 1.0}
     },
     'responded_existence': {
         ('IG', 'FL'): {'support': 1.0, 'confidence': 1.0},
         ...
     },
     ...
 }
 ```

 This looks good. I'll write it out now.
</think>
 ```python
declare_model = {
    # Unary Constraints: Individual activity requirements
    
    'existence': {
        'IG': {'support': 1.0, 'confidence': 1.0},  # Every product starts with an idea
        'DD': {'support': 1.0, 'confidence': 1.0},  # Design draft must occur
        'TFC': {'support': 1.0, 'confidence': 1.0}, # Technical check must occur
        'CE': {'support': 1.0, 'confidence': 1.0},  # Cost evaluation must occur
        'PC': {'support': 1.0, 'confidence': 1.0},  # Prototype must be created
        'LT': {'support': 1.0, 'confidence': 1.0},  # Laboratory testing required
        'UT': {'support': 1.0, 'confidence': 1.0},  # User testing required
        'AG': {'support': 1.0, 'confidence': 1.0},  # Management approval required
        'MP': {'support': 1.0, 'confidence': 1.0},  # Marketing plan required
        'FL': {'support': 1.0, 'confidence': 1.0}   # Final launch must occur
    },
    
    'absence': {
        # No forbidden activities in this scenario (all listed activities are permitted)
    },
    
    'exactly_one': {
        'IG': {'support': 1.0, 'confidence': 1.0},  # Exactly one idea generation per product case
        'AG': {'support': 1.0, 'confidence': 1.0},  # Exactly one approval gate
        'FL': {'support': 1.0, 'confidence': 1.0}   # Exactly one final launch
    },
    
    'init': {
        'IG': {'support': 1.0, 'confidence': 1.0}   # Process must start with Idea Generation
    },
    
    # Binary Constraints: Relationships between activities
    
    'responded_existence': {
        # If source occurs, target must occur somewhere in the trace
        ('IG', 'FL'): {'support': 1.0, 'confidence': 1.0},  # Idea implies eventual launch (complete process)
        ('DD', 'PC'): {'support': 1.0, 'confidence': 1.0},  # Design implies prototype creation
        ('PC', 'LT'): {'support': 1.0, 'confidence': 1.0},  # Prototype implies lab testing
        ('PC', 'UT'): {'support': 1.0, 'confidence': 1.0}   # Prototype implies user testing
    },
    
    'coexistence': {
        # If one occurs, the other must occur (mutual implication)
        ('TFC', 'CE'): {'support': 1.0, 'confidence': 1.0},  # Technical and cost evaluation always together
        ('LT', 'UT'): {'support': 1.0, 'confidence': 1.0}    # Both testing phases required together
    },
    
    'response': {
        # If source occurs, target must occur after it (temporal succession)
        ('IG', 'DD'): {'support': 1.0, 'confidence': 1.0},
        ('DD', 'TFC'): {'support': 1.0, 'confidence': 0.9},  # Usually follows, slight flexibility
        ('DD', 'CE'): {'support': 1.0, 'confidence': 0.9},
        ('TFC', 'PC'): {'support': 1.0, 'confidence': 1.0},
        ('CE', 'PC'): {'support': 1.0, 'confidence': 1.0},
        ('PC', 'LT'): {'support': 1.0, 'confidence': 1.0},
        ('PC', 'UT'): {'support': 1.0, 'confidence': 1.0},
        ('LT', 'AG'): {'support': 1.0, 'confidence': 1.0},
        ('UT', 'AG'): {'support': 1.0, 'confidence': 1.0},
        ('AG', 'MP'): {'support': 1.0, 'confidence': 1.0},
        ('MP', 'FL'): {'support': 1.0, 'confidence': 1.0}
    },
    
    'precedence': {
        # Target can only occur if source occurred before it
        ('IG', 'DD'): {'support': 1.0, 'confidence': 1.0},
        ('DD', 'TFC'): {'support': 1.0, 'confidence': 1.0},
        ('DD', 'CE'): {'support': 1.0, 'confidence': 1.0},
        ('TFC', 'PC'): {'support': 1.0, 'confidence': 1.0},
        ('CE', 'PC'): {'support': 1.0, 'confidence': 1.0},
        ('PC', 'LT'): {'support': 1.0, 'confidence': 1.0},
        ('PC', 'UT'): {'support': 1.0, 'confidence': 1.0},
        ('LT', 'AG'): {'support': 1.0, 'confidence': 1.0},
        ('UT', 'AG'): {'support': 1.0, 'confidence': 1.0},
        ('AG', 'MP'): {'support': 1.0, 'confidence': 1.0},
        ('MP', 'FL'): {'support': 1.0, 'confidence': 1.0}
    },
    
    'succession': {
        # Combination of response and precedence (strict ordering)
        ('IG', 'DD'): {'support': 1.0, 'confidence': 1.0},
        ('AG', 'MP'): {'support': 1.0, 'confidence': 1.0},
        ('MP', 'FL'): {'support': 1.0, 'confidence': 1.0}
    },
    
    'altresponse': {
        # Response with no repetition of source before target
        ('PC', 'AG'): {'support': 1.0, 'confidence': 1.0}  # Single prototype cycle before approval
    },
    
    'altprecedence': {
        # Precedence with no repetition of source after target starts
    },
    
    'altsuccession': {
        # Both altresponse and altprecedence
    },
    
    'chainresponse': {
        # Target must immediately follow source
        ('AG', 'MP'): {'support': 1.0, 'confidence': 0.8}  # Marketing planning often starts immediately after approval
    },
    
    'chainprecedence': {
        # Source must immediately precede target
    },
    
    'chainsuccession': {
        # Immediate succession in both directions
    },
    
    'noncoexistence': {
        # Activities that cannot occur in the same case (none in this happy-path scenario)
    },
    
    'nonsuccession': {
        # Source cannot be followed by target (prevents backward jumps)
        ('FL', 'IG'): {'support': 1.0, 'confidence': 1.0},  # Cannot return to idea generation after launch
        ('FL', 'DD'): {'support': 1.0, 'confidence': 1.0},  # Cannot return to design after launch
        ('AG', 'DD'): {'support': 1.0, 'confidence': 1.0},  # Cannot return to design after approval
        ('AG', 'PC'): {'support': 1.0, 'confidence': 0.9}   # Usually cannot return to prototyping after approval
    },
    
    'nonchainsuccession': {
        # Source cannot immediately precede target
        ('FL', 'AG'): {'support': 1.0, 'confidence': 1.0}   # Launch does not immediately follow approval (marketing in between)
    }
}
```