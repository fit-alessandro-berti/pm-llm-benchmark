# Process Tree Discovery

## Analyzing the Event Log

**Observed traces:**

| Case | Trace |
|------|-------|
| 1 | RA  VF  AE  **RMI  VF**  AD  SC  AC |
| 2 | RA  VF  AE  AD  SC  AC |
| 3 | RA  VF  AE  **RMI  RMI  VF**  AD  SC  AC |

**Key observations:**
- All cases share the backbone: `RA  VF  AE  ...  AD  SC  AC`
- After **AE**, there is an *optional* rework phase: one or more **RMI**s followed by a re-**VF**
- Case 3 shows that *multiple* RMIs can occur before a single re-validation

## Final Process Tree

```
 ( 'RA', 'VF', 'AE', * ( ,  ( * ( 'RMI',  ), 'VF' ) ), 'AD', 'SC', 'AC' )
```

### Structural Breakdown

```
  (main sequence)
 'RA'                          Receive Application
 'VF'                          Validate Form
 'AE'                          Assess Eligibility
 * (outer loop – optional rework)
                             (do-part: silent, allows skipping the loop entirely)
     (redo-part: rework round)
        * (inner loop – one or more info requests)
           'RMI'            Request Missing Info (at least once)
                           (silent redo allows repeating RMI)
        'VF'                 Re-validate Form
 'AD'                          Approval Decision
 'SC'                          Send Confirmation
 'AC'                          Archive Case
```

### Trace Verification

| Case | Outer loop | Inner loop (`*('RMI',)`) | Resulting visible trace |  |
|------|-----------|---------------------------|------------------------|---|
| 2 | Exit immediately ( only) | — | RA, VF, AE, **AD**, SC, AC |  |
| 1 | 1 iteration | 1× RMI | RA, VF, AE, **RMI, VF**, AD, SC, AC |  |
| 3 | 1 iteration | 2× RMI | RA, VF, AE, **RMI, RMI, VF**, AD, SC, AC |  |

### Python Construction

```python
from pm4py.objects.process_tree.obj import ProcessTree, Operator

# Root: main sequence
root = ProcessTree(operator=Operator.SEQUENCE)

RA = ProcessTree(label="RA", parent=root)
VF1 = ProcessTree(label="VF", parent=root)
AE = ProcessTree(label="AE", parent=root)

# Outer loop: * ( ,  ( * ( 'RMI',  ), 'VF' ) )
outer_loop = ProcessTree(operator=Operator.LOOP, parent=root)
tau_do = ProcessTree(label=None, parent=outer_loop)          #  (do-part)

redo_seq = ProcessTree(operator=Operator.SEQUENCE, parent=outer_loop)  # redo-part

# Inner loop: * ( 'RMI',  )    one or more RMIs
inner_loop = ProcessTree(operator=Operator.LOOP, parent=redo_seq)
RMI = ProcessTree(label="RMI", parent=inner_loop)
tau_inner = ProcessTree(label=None, parent=inner_loop)       #  (allows repeating RMI)
inner_loop.children.append(RMI)
inner_loop.children.append(tau_inner)

VF2 = ProcessTree(label="VF", parent=redo_seq)
redo_seq.children.append(inner_loop)
redo_seq.children.append(VF2)

outer_loop.children.append(tau_do)
outer_loop.children.append(redo_seq)

AD = ProcessTree(label="AD", parent=root)
SC = ProcessTree(label="SC", parent=root)
AC = ProcessTree(label="AC", parent=root)

root.children.extend([RA, VF1, AE, outer_loop, AD, SC, AC])
```

### Design Rationale

| Quality | How it is addressed |
|---------|-------------------|
| **Fitness** | All three observed traces are perfectly reproducible |
| **Precision** | Every rework round *must* end with a VF (no dangling RMI); the loop can only be skipped entirely or produce valid RMIVF blocks |
| **Simplicity** | Only two nested loops (outer for rework rounds, inner for repeated requests), with minimal use of ; no unnecessary parallelism or XOR choices |