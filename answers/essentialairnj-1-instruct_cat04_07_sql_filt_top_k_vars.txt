Let's assume we are using DuckDB and we'll solve the problem step-by-step using Python scripts. Specifically, DuckDB can be queried using its Python API. Here’s the solution:

```python
import duckdb

# Connect to the DuckDB database
con = duckdb.connect()  # This will create an in-memory database

# Assuming that event_log table is already created and populated in DuckDB with the given columns
# Here we're just demonstrating how you might construct this SQL query

# Step 1: Identify all unique process variants
# This involves generating the activity sequence for each case_id by sorting by timestamp
query_variants = """
WITH case_sequences AS (
    SELECT
        case_id,
        string_agg(activity, ' => ') AS variant
    FROM event_log
    GROUP BY case_id
)
SELECT
    variant,
    COUNT(*) AS case_count
FROM case_sequences
GROUP BY variant
ORDER BY case_count DESC
LIMIT :K
"""

# Step 2: Filter down to the cases belonging to the top K variants
# Assuming :K is provided as an argument to the query (we will simulate this with Python)
K = 5  # Specify how many variants to consider

# Step 3: Retrieve all events simplified from those cases
query_events = """
WITH top_variants AS (
    SELECT
        case_id
    FROM case_sequences
    WHERE case_id IN (
        SELECT
            case_id
        FROM (
            SELECT
                case_id,
                ROW_NUMBER() OVER (ORDER BY COUNT(*) DESC) AS rn
            FROM case_sequences
            GROUP BY case_id
            HAVING COUNT(*) >= :K
        ) AS ranked_cases
    )
)
SELECT
    *
FROM event_log
WHERE case_id IN (SELECT case_id FROM top_variants)
"""

# Execute the queries
variants_result = con.execute(query_variants, {"K": K}).fetchall()

# Since we are joining and using a common table expression, we need both steps to run together.
# The final output should be the merged results.
# However, the second query aims to filter out based on the top K cases, thus it naturally will produce
# the correct set of cases and their associated events.
events_result = con.execute(query_events, {"K": K}).df()

# Print the event log of the top K cases
print(events_result)
```

This SQL constructs a series of common table expressions that:

1. Generate a sequence of activities (`variant`) for each case (`case_id`) in the `event_log` table.
2. Count how many `case_id` map to a specific `variant`. It sorts the variants by count to find the top K variants.
3. Reverses the process and filters the `event_log` to only include `case_id` that are part of the top K variants.

Note: The `ROW_NUMBER()` function is used here to rank cases by their variant count in the second query, though `ROW_NUMBER()` is not directly necessary as we are using `string_agg` and `COUNT(*)` to find the top K variants. The second query's intention is to filter down `event_log` based on the `case_id` from the top K variants.

Also, the given prompt does not expressly define which variant represents a case with a single activity, so the above query will include cases with equivalent single activities as different variants unless those sequences are considered the same. That's assumed to be the case here given the definition of a process variant provided.