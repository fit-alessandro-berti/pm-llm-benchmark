<think>
We need to produce a DuckDB SQL query that does the steps:

1. For each case_id, get the ordered sequence of activities according to timestamp. This can be done using string_agg(activity, ' -> ' ORDER BY timestamp) or list_agg(activity ORDER BY timestamp). In DuckDB, string_agg supports ORDER BY.

2. Group by that sequence to count cases per variant.

3. Determine top K variants by frequency. K can be a parameter, e.g., 5.

4. Then filter the original event log to only those case_id where the case's variant is among the top K.

We need to produce a query that does all this. Possibly using CTEs.

Let's outline:

WITH variants AS (
    SELECT
        case_id,
        string_agg(activity, '->' ORDER BY timestamp) AS variant
    FROM event_log
    GROUP BY case_id
),
variant_counts AS (
    SELECT
        variant,
        COUNT(*) AS case_count
    FROM variants
    GROUP BY variant
),
top_variants AS (
    SELECT
        variant,
        case_count
    FROM variant_counts
    ORDER BY case_count DESC
    LIMIT 5  -- K
)
SELECT e.*
FROM event_log e
JOIN variants v ON e.case_id = v.case_id
JOIN top_variants tv ON v.variant = tv.variant;

That returns all events for cases in top variants.

Alternatively, we can compute top variants using rank and filter.

But we need to ensure that variant string is deterministic; we could use list_agg and convert to string.

Potential issues: large number of activities per case; string length may be large.

Alternatively, we could compute variant as array of activities using list_agg(...). Then join arrays.

But for simplicity, string.

We may also want to ensure that we handle ties for top K; we can use rank() and filter rank <= K.

Potential extension: parameterizing K.

We can also use a subquery for top variants.

Let's produce a final query with CTEs and a parameter.

We could also use a variable: define K as a macro parameter.

In DuckDB, we can use a parameter placeholder: ?

But for readability, we can set K as a constant.

User wants to return all events from original log that belong only to cases which are part of these top K variants.

Thus the final SELECT includes all columns from event_log.

We also need to ensure correct ordering of events in final result; maybe order by case_id, timestamp.

We can optionally include variant and case_count.

But the requirement is to return events.

Thus final SELECT can be:

SELECT e.*
FROM event_log e
JOIN (
    SELECT case_id, variant
    FROM (
        SELECT
            case_id,
            string_agg(activity, '->' ORDER BY timestamp) AS variant,
            RANK() OVER (ORDER BY COUNT(*) DESC) AS rnk
        FROM event_log
        GROUP BY case_id
        -- Actually this is wrong: we need to rank variants, not cases.
    ) t
) ... Hmm.

Better to compute variant counts first.

Thus:

WITH case_variant AS (
    SELECT
        case_id,
        string_agg(activity, '->' ORDER BY timestamp) AS variant
    FROM event_log
    GROUP BY case_id
),
variant_stats AS (
    SELECT
        variant,
        COUNT(*) AS case_cnt,
        RANK() OVER (ORDER BY COUNT(*) DESC) AS rnk
    FROM case_variant
    GROUP BY variant
),
top_variants AS (
    SELECT variant
    FROM variant_stats
    WHERE rnk <= 5  -- K
)
SELECT e.*
FROM event_log e
JOIN case_variant cv ON e.case_id = cv.case_id
JOIN top_variants tv ON cv.variant = tv.variant
ORDER BY e.case_id, e.timestamp;

That's it.

If we want to handle ties: using DENSE_RANK.

We might also include an option to treat K as a parameter: set K = 5.

Thus we can define a macro: define K=5; but not needed.

We can also use a subquery for top_variants:

SELECT variant FROM (
    SELECT variant, COUNT(*) AS cnt
    FROM case_variant
    GROUP BY variant
    ORDER BY cnt DESC
    LIMIT 5
) t;

But using rank ensures ties.

Thus final answer.

We should also mention that string_agg ORDER BY is supported in DuckDB.

Alternatively, we could use list_agg, which returns an array and join.

Thus final answer includes the query and explanation.

Potential improvements: For large logs, using list_agg and hashing for variant identification.

But the user likely expects a straightforward query.

Thus answer: Provide the query with CTEs.

Now I'll produce the answer.

We'll include comments.

Possibly we need to provide a parameter for K.

Thus we can use a variable: SET K = 5; then use that variable in query.

DuckDB supports variables: set variable.

But not necessary.

Thus final answer: Provide the query.

Now let's write the final answer.


</think>

Below is a **singlestatement DuckDB query** that does everything you asked for:

1. **Build the ordered activity sequence for each case** (`case_variant`).  
2. **Count how many cases share the same sequence** (`variant_stats`).  
3. **Pick the topK variants** (using `DENSE_RANK` so ties are kept together).  
4. **Return the original events that belong only to those topK cases**.

```sql
-- --------------------------------------------------------------------
-- 1  Parameters (change K to whatever you need)
-- --------------------------------------------------------------------
-- DuckDB lets you use a scalar variable – set it once and reference it
-- throughout the statement.  If you prefer a hardcoded value just replace
-- :K with a literal (e.g. 5).
PREPARE top_k AS SELECT 5 AS K;   --  change 5 to your desired K

-- --------------------------------------------------------------------
-- 2  Main query (CTEs + final SELECT)
-- --------------------------------------------------------------------
WITH
-- ---------------------------------------------------------------
-- 2.1  Build the activity sequence for each case (ordered by timestamp)
-- ---------------------------------------------------------------
case_variant AS (
    SELECT
        case_id,
        -- string_agg respects the ORDER BY clause  deterministic variant string
        string_agg(activity, ' -> ' ORDER BY timestamp) AS variant
    FROM event_log
    GROUP BY case_id
),

-- ---------------------------------------------------------------
-- 2.2  Count cases per variant and rank them by frequency
-- ---------------------------------------------------------------
variant_stats AS (
    SELECT
        variant,
        COUNT(*) AS case_cnt,
        DENSE_RANK() OVER (ORDER BY COUNT(*) DESC) AS rnk   -- 1 = most frequent
    FROM case_variant
    GROUP BY variant
),

-- ---------------------------------------------------------------
-- 2.3  Keep only the topK variants (ties are kept together)
-- ---------------------------------------------------------------
top_variants AS (
    SELECT variant
    FROM variant_stats
    WHERE rnk <= (SELECT K FROM top_k)   -- :K or the prepared variable
)

-- ---------------------------------------------------------------
-- 2.4  Return the original events that belong to the topK cases
-- ---------------------------------------------------------------
SELECT
    e.*,
    cv.variant                     -- optional: helps you see which variant a row belongs to
FROM event_log AS e
JOIN case_variant AS cv
  ON e.case_id = cv.case_id
JOIN top_variants AS tv
  ON cv.variant = tv.variant
ORDER BY e.case_id, e.timestamp;   -- deterministic order for the output
```

### How it works, stepbystep

| CTE | Purpose | Key DuckDB feature |
|-----|---------|--------------------|
| **`case_variant`** | Turns each `case_id` into a single string that represents the ordered list of activities. | `string_agg(activity, ' -> ' ORDER BY timestamp)` – the `ORDER BY` inside the aggregate guarantees the activities appear in the same order they happened. |
| **`variant_stats`** | Counts how many cases have exactly the same variant string and ranks the variants by that count. | `COUNT(*)` + window function `DENSE_RANK() OVER (ORDER BY COUNT(*) DESC)`. |
| **`top_variants`** | Filters to the topK variants (ties stay together). | Simple `WHERE rnk <= K`. |
| **Final SELECT** | Joins the original log back to the filtered casevariant mapping so you get every event *only* for cases that belong to a topK variant. | Normal inner joins; the `ORDER BY` at the end makes the result set reproducible. |

### Tweaking the query

* **Different separator** – change `' -> '` in `string_agg` to anything you like (e.g., `'|'` or just `','`).  
* **Array instead of string** – if you prefer a native array, replace `string_agg` with `list_agg(activity ORDER BY timestamp)` and compare arrays in the join (`cv.variant = tv.variant`).  
* **Parameterising K** – you can replace the `PREPARE` block with a literal (`WHERE rnk <= 5`) or use a DuckDB *macro* (`DEFINE K=5; … WHERE rnk <= K`).  
* **Handling very long variants** – for extremely long activity lists you might want to hash the variant string (`hash(string_agg(...))`) to keep the intermediate tables smaller, then join on the hash.

That’s it – the query returns exactly the rows from `event_log` whose `case_id`s belong to the most frequent *K* process variants. 