```python
log_skeleton = {
    # If the first activity occurs, it has the same number of occurrences as the second
    "equivalence": {
        ("RO", "IC"),   # Each received order leads to exactly one invoice
        ("IC", "RP"),   # Each invoice is followed by exactly one payment record
        ("PO", "GSL"),  # Each packed order gets exactly one shipping label
        ("GSL", "D"),   # Each shipping label leads to exactly one dispatch
    },

    # If the first activity occurs, the second must have been executed previously
    "always_before": {
        ("CA", "RO"),   # Availability check only after receiving the order
        ("RI", "CA"),   # Reserve items only after availability check
        ("PI", "RI"),   # Pick items only after items are reserved
        ("QC", "PI"),   # Quality check only after items are picked
        ("PO", "QC"),   # Pack order only after quality check
        ("GSL", "PO"),  # Generate label only after packing
        ("D", "GSL"),   # Dispatch only after label generation
        ("IC", "RO"),   # Invoice only after receiving the order
        ("RP", "IC"),   # Record payment only after invoice
    },

    # If the first activity occurs, the second is executed in one of the following events
    "always_after": {
        ("RO", "CA"),   # After receiving an order, availability must be checked
        ("CA", "RI"),   # After checking availability, items must be reserved
        ("RI", "PI"),   # After reserving items, they must be picked
        ("PI", "QC"),   # After picking items, they must be quality checked
        ("QC", "PO"),   # After quality check, the order must be packed
        ("PO", "GSL"),  # After packing, a shipping label must be generated
        ("GSL", "D"),   # After generating label, the order must be dispatched
        ("RO", "IC"),   # After receiving order, an invoice must be issued
        ("IC", "RP"),   # After issuing invoice, payment must be recorded
    },

    # The two activities cannot co-exist inside the same case
    "never_together": {
        # Example business rule: an order that is dispatched must always be paid;
        # if you want to model unpaid-but-dispatched as impossible:
        # ("D_unpaid", "RP"),  # This would require separate activities, so left empty here.
    },

    # Bounds the number of occurrences for an activity in a case
    # Here we assume each activity happens exactly once per order case
    "activ_freq": {
        "RO": {1},
        "CA": {1},
        "RI": {1},
        "PI": {1},
        "QC": {1},
        "PO": {1},
        "GSL": {1},
        "D": {1},
        "IC": {1},
        "RP": {1},
    },

    # If the first activity occurs, the second shall occur immediately after
    "directly_follows": {
        ("RO", "CA"),
        ("CA", "RI"),
        ("RI", "PI"),
        ("PI", "QC"),
        ("QC", "PO"),
        ("PO", "GSL"),
        ("GSL", "D"),
        ("D", "IC"),
        ("IC", "RP"),
    },
}
```