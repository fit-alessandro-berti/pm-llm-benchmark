The visualization shows a **process model using Petri-net style notation** for handling a customer request, plus a legend of control-flow patterns.

### Main process (left and center)

- Rectangles with rounded corners are **activities**:
  - **a – register request**
  - **b – examine thoroughly**
  - **c – examine casually**
  - **d – check ticket**
  - **f – reinitiate request**
  - **e – decide**
  - **g – pay compensation**
  - **h – reject request**
  - **z – end**

- Small black circles are **places** (conditions or states).  
- Arrows connect activities through these places, defining the possible order of execution.

Flow (informally):
1. The process starts with **a (register request)**.
2. Then one or more analysis activities may occur:
   - **b (examine thoroughly)**  
   - **c (examine casually)**  
   - **d (check ticket)**  
   There are multiple arcs and loops, so these tasks can occur in different orders and may repeat.
3. **f (reinitiate request)** represents returning the case for more examination; arcs loop back from and to earlier tasks.
4. At some point, the case reaches **e (decide)**.
5. From **e**, the process branches to either:
   - **g (pay compensation)** then **z (end)**, or
   - **h (reject request)** then **z (end)**.

### Control-flow legend (bottom right)

The grey box explains the routing semantics:

- **XOR-split / XOR-join** – exclusive choice and merge (one of many paths).
- **AND-split / AND-join** – parallel branching and synchronization (all paths).
- **OR-split / OR-join** – inclusive choice and merge (one or more paths).

Each pattern is drawn with the same Petri-net style: a rectangular activity connected to one or more places and arrows showing how tokens can split or join.