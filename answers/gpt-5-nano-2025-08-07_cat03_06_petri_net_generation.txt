Here's a self-contained Python snippet that builds an accepting Petri net for the Insurance Claim scenario you described. It uses one transition per activity (CR, DV, FC, II, CA, AP, P, N, CL) and places that model the states between activities. It also includes a re-documentation loop (RDS) after DV and an optional loop with II after FC. The initial marking has a token in a start place, and the final marking tokens the final/closed place.

```python
from pm4py.objects.petri_net.obj import PetriNet, Marking
from pm4py.objects.petri_net.utils import petri_utils

# Create the Petri net
net = PetriNet(name="InsuranceClaim_Accepting_Net")

# Transitions (activities)
cr_t   = PetriNet.Transition(name="CR",  label="Claim Registration")
dv_t   = PetriNet.Transition(name="DV",  label="Document Verification")
rds_t  = PetriNet.Transition(name="RDS", label="Re-Document Submission")
rds_ret_t = PetriNet.Transition(name="RDS_ret", label="Return from RDS")
ii_t   = PetriNet.Transition(name="II",  label="In-depth Investigation")
ca_t   = PetriNet.Transition(name="CA",  label="Claim Assessment")
ap_t   = PetriNet.Transition(name="AP",  label="Approval")
pay_t  = PetriNet.Transition(name="P",   label="Payment")
noti_t  = PetriNet.Transition(name="N",  label="Notification")
cl_t   = PetriNet.Transition(name="CL",  label="Closure")

# Places (states between activities)
start_p = PetriNet.Place(name="start")

cr_p    = PetriNet.Place(name="CR_done")
dv_p    = PetriNet.Place(name="DV_done")

fc_p    = PetriNet.Place(name="FC_done")  # State after FC (ready for CA)
ca_p    = PetriNet.Place(name="CA_done")
ap_p    = PetriNet.Place(name="AP_done")
pay_p   = PetriNet.Place(name="P_done")
noti_p  = PetriNet.Place(name="N_done")
final_p = PetriNet.Place(name="final")     # final/closed place

# Helper: add all to the net
net.places.add(start_p)

net.places.add(cr_p)
net.places.add(dv_p)
net.places.add(fc_p)
net.places.add(ca_p)
net.places.add(ap_p)
net.places.add(pay_p)
net.places.add(noti_p)
net.places.add(final_p)

net.transitions.add(cr_t)
net.transitions.add(dv_t)
net.transitions.add(rds_t)
net.transitions.add(rds_ret_t)
net.transitions.add(ii_t)
net.transitions.add(ca_t)
net.transitions.add(ap_t)
net.transitions.add(pay_t)
net.transitions.add(noti_t)
net.transitions.add(cl_t)

# Arcs: input and output connections (using pm4py's helper)
# Start -> CR
petri_utils.add_arc_from_to(start_p, cr_t, net)
petri_utils.add_arc_from_to(cr_t, cr_p, net)

# CR -> DV
petri_utils.add_arc_from_to(cr_p, dv_t, net)
petri_utils.add_arc_from_to(dv_t, dv_p, net)

# DV -> FC (proceed) and DV -> RDS (optional re-submission)
petri_utils.add_arc_from_to(dv_p, rds_t, net)  # option 1: RDS path
petri_utils.add_arc_from_to(rds_t, dv_p, net)  # (RDS) completes; returns to DV (see RDS_ret)
# The normal path to Fraud Check (FC) after DV
petri_utils.add_arc_from_to(dv_p, fc_t, net)
petri_utils.add_arc_from_to(fc_t, fc_p, net)

# RDS loop: after completing RDS, return token to DV's state
petri_utils.add_arc_from_to(dv_p, rds_t, net)      # (duplicate of above DV->RDS, kept for clarity)
petri_utils.add_arc_from_to(rds_t, rds_ret_t, net)
petri_utils.add_arc_from_to(rds_ret_t, dv_p, net)

# FC -> CA (and II loop on FC)
petri_utils.add_arc_from_to(fc_p, ii_t, net)
petri_utils.add_arc_from_to(ii_t, fc_p, net)  # II loops on FC state (self-loop style)

petri_utils.add_arc_from_to(fc_p, ca_t, net)
petri_utils.add_arc_from_to(ca_t, ca_p, net)

# CA -> AP
petri_utils.add_arc_from_to(ca_p, ap_t, net)
petri_utils.add_arc_from_to(ap_t, pay_p, net)

# PAY -> NOTI -> FINAL
petri_utils.add_arc_from_to(pay_p, noti_t, net)
petri_utils.add_arc_from_to(noti_t, noti_p, net)

petri_utils.add_arc_from_to(noti_p, cl_t, net)
petri_utils.add_arc_from_to(cl_t, final_p, net)

# Optionally, connect final transition to an explicit final marking (if desired)
# (Here final_p is already the final place to be marked; you can also create a separate "final" place if preferred.)

# Initial and final markings
im = Marking()
im[start_p] = 1  # a new claim arrives

fm = Marking()
fm[final_p] = 1  # claim is closed

# Optional: print basic info
# print("Net built with", len(net.places), "places and", len(net.transitions), "transitions.")

# The net, im, and fm are ready to be used with PM4Py workflows.
```

Notes
- Transitions CR, DV, FC, II, CA, AP, P, N, CL model the main flow.
- RDS and RDS_ret implement the re-submission loop after DV. The token can circulate back to DV, allowing the process to loop through DV/RDS as needed.
- II forms a loop with FC to allow multiple in-depth investigations after Fraud Check but before Claim Assessment.
- The initial marking places a token in the start place, representing a new claim arrival.
- The final marking places a token in the final (closed) place, representing a closed claim.