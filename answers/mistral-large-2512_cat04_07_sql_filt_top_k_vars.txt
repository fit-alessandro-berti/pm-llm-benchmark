# DuckDB SQL Query for Process Variant Analysis

Here's a comprehensive solution that addresses all requirements in a single query:

```sql
WITH
-- Step 1: Create ordered activity sequences for each case
activity_sequences AS (
    SELECT
        case_id,
        STRING_AGG(activity, ' > ' ORDER BY timestamp) AS variant
    FROM event_log
    GROUP BY case_id
),

-- Step 2: Count cases per variant and rank them by frequency
variant_counts AS (
    SELECT
        variant,
        COUNT(*) AS case_count,
        RANK() OVER (ORDER BY COUNT(*) DESC) AS frequency_rank
    FROM activity_sequences
    GROUP BY variant
),

-- Step 3: Identify top K variants (change K as needed)
top_variants AS (
    SELECT variant
    FROM variant_counts
    WHERE frequency_rank <= 5  -- Set K=5 for top 5 variants
),

-- Step 4: Get all cases that belong to top variants
top_cases AS (
    SELECT case_id
    FROM activity_sequences
    WHERE variant IN (SELECT variant FROM top_variants)
)

-- Final result: All events from cases in top variants
SELECT e.*
FROM event_log e
JOIN top_cases t ON e.case_id = t.case_id
ORDER BY e.case_id, e.timestamp;
```

## Explanation:

1. **activity_sequences**: Creates the process variant for each case by string-aggregating activities in timestamp order.

2. **variant_counts**: Counts how many cases share each variant and ranks them by frequency.

3. **top_variants**: Filters to keep only the top K variants (here K=5, but you can adjust this).

4. **top_cases**: Identifies all case_ids that belong to the top variants.

5. **Final query**: Returns all events from the original log that belong to cases in the top variants.

## Customization:

- To change the number of top variants, modify the `WHERE frequency_rank <= 5` condition (e.g., change to 10 for top 10 variants).
- The separator in the variant string (' > ') can be changed to any other delimiter if needed.
- The final result is ordered by case_id and timestamp to maintain process flow visibility.