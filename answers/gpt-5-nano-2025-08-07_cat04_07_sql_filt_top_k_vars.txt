Here's a single DuckDB SQL script that accomplishes all four steps:

- Builds the ordered per-case activity sequence
- Groups by sequence to count variants
- Picks the top K variants by case count
- Returns all events for cases belonging to those top variants (excluding other cases)

Assumptions:
- event_log(case_id, activity, timestamp)
- timestamp is comparable for ordering
- top_k is the number of top variants you want (use a concrete integer or bind a parameter)

SQL:

WITH
  -- 1) Per-case, build the ordered activity sequence (as a delimited string)
  case_variants AS (
    SELECT
      case_id,
      array_to_string(array_agg(activity ORDER BY timestamp), '|') AS variant_seq
    FROM event_log
    GROUP BY case_id
  ),

  -- 2) Count how many cases follow each variant_seq
  variant_counts AS (
    SELECT
      variant_seq,
      COUNT(*) AS variant_case_count
    FROM case_variants
    GROUP BY variant_seq
  ),

  -- 3) Identify the top K variants by frequency
  top_variants AS (
    SELECT variant_seq
    FROM variant_counts
    ORDER BY variant_case_count DESC
    LIMIT ?  -- set this to your desired K (e.g., LIMIT 5)
  )

-- 4) Return all events that belong to cases whose variant_seq is in the top K
SELECT e.*
FROM event_log AS e
JOIN case_variants AS cv
  ON e.case_id = cv.case_id
JOIN top_variants AS tv
  ON cv.variant_seq = tv.variant_seq
ORDER BY e.case_id, e.timestamp;

Notes and tips:
- The variant sequence uses a delimiter ('|' in the example) to form a unique key for each case’s ordered activity list. You can change the delimiter if you prefer.
- If you want deterministic tie-breaking for top-K when counts are equal, add a secondary ORDER BY criterion in top_variants, e.g., ORDER BY variant_case_count DESC, variant_seq ASC (you can reference a temporary column in variant_counts if needed).
- If you’re running this as a prepared statement, replace the ? with your parameter marker (e.g., $1) or bind the value 5 at execution time.