Below is a **selfcontained Python script** that builds an **accepting Petri net** for the insuranceclaim process you described.  
It uses the `pm4py` classes you mentioned (`PetriNet`, `Marking`, `petri_utils`) and creates:

* **Places** – the “states” of the process (start, after each activity, and the final closed state).  
* **Transitions** – labelled with the activity names (`CR`, `DV`, `RDS`, `FC`, `II`, `CA`, `AP`, `P`, `N`, `CL`).  
* **Arcs** – connect the places and transitions, including the two loops you need:  

  * **Documentverification  Redocument submission  Documentverification** (when documents are incomplete).  
  * **Fraudcheck  Indepth investigation  Fraudcheck** (when the fraud unit needs another look).  

* **Initial marking** – a token in the start place (`p_start`).  
* **Final marking** – a token in the closedclaim place (`p_cl`).  

You can copypaste the code into a Python environment where `pm4py` is installed and run it directly.

```python
# --------------------------------------------------------------
# Accepting Petri net for the insuranceclaim management process
# --------------------------------------------------------------

from pm4py.objects.petri_net.obj import PetriNet, Marking
from pm4py.objects.petri_net.utils import petri_utils

# -----------------------------------------------------------------
# 1.  Create the net
# -----------------------------------------------------------------
net = PetriNet(name="InsuranceClaimProcess")

# -----------------------------------------------------------------
# 2.  Define the places (states)
# -----------------------------------------------------------------
p_start = PetriNet.Place("p_start")   # claim just arrived (initial)
p_cr    = PetriNet.Place("p_cr")      # after Claim Registration
p_dv    = PetriNet.Place("p_dv")      # after Document Verification
p_rds   = PetriNet.Place("p_rds")     # ReDocument Submission needed
p_fc    = PetriNet.Place("p_fc")      # after Fraud Check
p_ii    = PetriNet.Place("p_ii")      # Indepth Investigation
p_ca    = PetriNet.Place("p_ca")      # after Claim Assessment
p_ap    = PetriNet.Place("p_ap")      # after Approval (if required)
p_p     = PetriNet.Place("p_p")       # after Payment
p_n     = PetriNet.Place("p_n")       # after Notification
p_cl    = PetriNet.Place("p_cl")      # Claim Closed (final)

# Add all places to the net
for pl in [p_start, p_cr, p_dv, p_rds, p_fc, p_ii,
           p_ca, p_ap, p_p, p_n, p_cl]:
    net.places.add(pl)

# -----------------------------------------------------------------
# 3.  Define the transitions (activities) – label = activity code
# -----------------------------------------------------------------
t_cr  = PetriNet.Transition("t_cr",  label="CR")   # Claim Registration
t_dv  = PetriNet.Transition("t_dv",  label="DV")   # Document Verification
t_rds = PetriNet.Transition("t_rds", label="RDS")  # ReDocument Submission
t_fc  = PetriNet.Transition("t_fc",  label="FC")   # Fraud Check
t_ii  = PetriNet.Transition("t_ii",  label="II")   # Indepth Investigation
t_ca  = PetriNet.Transition("t_ca",  label="CA")   # Claim Assessment
t_ap  = PetriNet.Transition("t_ap",  label="AP")   # Approval
t_p   = PetriNet.Transition("t_p",   label="P")    # Payment
t_n   = PetriNet.Transition("t_n",   label="N")    # Notification
t_cl  = PetriNet.Transition("t_cl",  label="CL")   # Closure

# Add all transitions to the net
for tr in [t_cr, t_dv, t_rds, t_fc, t_ii,
           t_ca, t_ap, t_p, t_n, t_cl]:
    net.transitions.add(tr)

# -----------------------------------------------------------------
# 4.  Connect places  transitions (normal flow + loops)
# -----------------------------------------------------------------
# 4.1  Start  Claim Registration
petri_utils.add_arc_from_to(p_start, t_cr, net)
petri_utils.add_arc_from_to(t_cr, p_cr, net)

# 4.2  Registration  Document Verification
petri_utils.add_arc_from_to(p_cr, t_dv, net)
petri_utils.add_arc_from_to(t_dv, p_dv, net)

# 4.3  Loop for missing documents:
#       DV  RDS  DV
petri_utils.add_arc_from_to(p_dv, t_rds, net)      # go to resubmission
petri_utils.add_arc_from_to(t_rds, p_rds, net)    # token in RDS place
petri_utils.add_arc_from_to(p_rds, t_dv, net)     # after RDS, rerun DV

# 4.4  After a *successful* DV  Fraud Check
petri_utils.add_arc_from_to(p_dv, t_fc, net)
petri_utils.add_arc_from_to(t_fc, p_fc, net)

# 4.5  Loop for fraud investigation:
#       FC  II  FC
petri_utils.add_arc_from_to(p_fc, t_ii, net)      # start investigation
petri_utils.add_arc_from_to(t_ii, p_ii, net)      # token in II place
petri_utils.add_arc_from_to(p_ii, t_fc, net)      # after II, rerun FC

# 4.6  After fraud check passes  Claim Assessment
petri_utils.add_arc_from_to(p_fc, t_ca, net)
petri_utils.add_arc_from_to(t_ca, p_ca, net)

# 4.7  Optional Approval (only if amount > threshold)
petri_utils.add_arc_from_to(p_ca, t_ap, net)
petri_utils.add_arc_from_to(t_ap, p_ap, net)

# 4.8  Payment can be reached either directly from CA (no approval needed)
#       or from AP (approval required)
petri_utils.add_arc_from_to(p_ap, t_p, net)      # after approval
petri_utils.add_arc_from_to(p_ca, t_p, net)      # bypass approval
petri_utils.add_arc_from_to(t_p, p_p, net)

# 4.9  Notification  Closure
petri_utils.add_arc_from_to(p_p, t_n, net)
petri_utils.add_arc_from_to(t_n, p_n, net)

petri_utils.add_arc_from_to(p_n, t_cl, net)
petri_utils.add_arc_from_to(t_cl, p_cl, net)

# -----------------------------------------------------------------
# 5.  Define the initial and final markings
# -----------------------------------------------------------------
# Initial marking – token in the start place (new claim arrived)
im = Marking()
im[p_start] = 1

# Final marking – token in the closedclaim place
fm = Marking()
fm[p_cl] = 1

# -----------------------------------------------------------------
# The net `net` together with `im` (initial) and `fm` (final)
# now represents an **accepting Petri net** for the described process.
# -----------------------------------------------------------------
```

### How to use it

```python
# Example: check that the net is wellformed
from pm4py.objects.petri_net.utils import petri_utils
assert petri_utils.is_well_defined(net, im, fm)
```

You can feed `net`, `im`, and `fm` to any of the `pm4py` analysis / simulation utilities (e.g., `pm4py.algo.simulation.petri_net_simulator`) to verify that the process can indeed reach the final marking, or to generate execution traces for testing.