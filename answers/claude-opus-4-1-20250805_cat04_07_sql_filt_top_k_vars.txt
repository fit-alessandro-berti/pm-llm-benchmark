Here's a comprehensive DuckDB SQL query that solves this problem:

```sql
WITH case_sequences AS (
    -- Step 1: Create ordered sequence of activities for each case
    SELECT 
        case_id,
        STRING_AGG(activity, '->' ORDER BY timestamp) AS variant
    FROM event_log
    GROUP BY case_id
),
variant_counts AS (
    -- Step 2: Count cases per variant
    SELECT 
        variant,
        COUNT(*) AS case_count
    FROM case_sequences
    GROUP BY variant
),
top_k_variants AS (
    -- Step 3: Identify top K variants by frequency
    -- Replace K with actual number (e.g., 5 for top 5 variants)
    SELECT 
        variant,
        case_count
    FROM variant_counts
    ORDER BY case_count DESC
    LIMIT 5  -- Change this to your desired K value
),
cases_in_top_variants AS (
    -- Step 4: Get case_ids that belong to top K variants
    SELECT 
        cs.case_id,
        cs.variant,
        tv.case_count
    FROM case_sequences cs
    INNER JOIN top_k_variants tv ON cs.variant = tv.variant
)
-- Step 5: Return all events from cases in top K variants
SELECT 
    el.case_id,
    el.activity,
    el.timestamp,
    citv.variant,
    citv.case_count AS variant_frequency
FROM event_log el
INNER JOIN cases_in_top_variants citv ON el.case_id = citv.case_id
ORDER BY citv.case_count DESC, el.case_id, el.timestamp;
```

## Alternative Version with Parameterized K

If you want to make K easily configurable, you can use a variable or parameter:

```sql
-- Set the K value
SET VARIABLE k_value = 5;

WITH case_sequences AS (
    SELECT 
        case_id,
        STRING_AGG(activity, '->' ORDER BY timestamp) AS variant
    FROM event_log
    GROUP BY case_id
),
variant_counts AS (
    SELECT 
        variant,
        COUNT(*) AS case_count,
        ROW_NUMBER() OVER (ORDER BY COUNT(*) DESC) AS rank
    FROM case_sequences
    GROUP BY variant
),
top_k_variants AS (
    SELECT 
        variant,
        case_count
    FROM variant_counts
    WHERE rank <= getvariable('k_value')
),
cases_in_top_variants AS (
    SELECT 
        cs.case_id,
        cs.variant,
        tv.case_count
    FROM case_sequences cs
    INNER JOIN top_k_variants tv ON cs.variant = tv.variant
)
SELECT 
    el.case_id,
    el.activity,
    el.timestamp,
    citv.variant,
    citv.case_count AS variant_frequency
FROM event_log el
INNER JOIN cases_in_top_variants citv ON el.case_id = citv.case_id
ORDER BY citv.case_count DESC, el.case_id, el.timestamp;
```

## Query Explanation:

1. **`case_sequences` CTE**: Groups events by `case_id` and creates the process variant by concatenating activities in timestamp order using `STRING_AGG` with `ORDER BY`.

2. **`variant_counts` CTE**: Counts how many cases follow each unique variant pattern.

3. **`top_k_variants` CTE**: Selects the top K most frequent variants. The `LIMIT` clause controls K (change it to your desired value).

4. **`cases_in_top_variants` CTE**: Identifies which cases belong to the top K variants by joining with the top variants list.

5. **Final SELECT**: Returns all original events from the event log, but only for cases that match one of the top K variants. Additional columns show the variant pattern and its frequency for context.

## Key Features:

- **Preserves original event data**: Returns all columns from the original event log
- **Efficient filtering**: Uses CTEs to build up the logic step by step
- **Configurable K**: Easy to adjust the number of top variants to include
- **Additional context**: Includes the variant pattern and frequency in the output for analysis
- **Proper ordering**: Results are ordered by variant frequency, then by case and timestamp

This query effectively implements a process mining pattern discovery algorithm, identifying the most common process paths through your system.