# Accepting Petri Net for Insurance Claim Management

## Process Analysis

The process follows this flow with two loops:

```
start  C  CR  DV  RDS (loop)  FC  II (loop)  CA  AP  P  N  CL  end
```

## Python Code

```python
from pm4py.objects.petri_net.obj import PetriNet, Marking
from pm4py.objects.petri_net.utils import petri_utils

#  Create the Petri Net 
net = PetriNet(name="insurance_claim_management")

#  Create Places (states between activities) 
start = PetriNet.Place(name="start")          # New claim arrives
p1    = PetriNet.Place(name="p1")             # Claim filed, awaiting registration
p2    = PetriNet.Place(name="p2")             # Registered, awaiting doc verification
p3    = PetriNet.Place(name="p3")             # Docs verified, awaiting fraud check (or re-submit)
p4    = PetriNet.Place(name="p4")             # Fraud check done, awaiting assessment (or investigation)
p5    = PetriNet.Place(name="p5")             # Assessed, awaiting approval
p6    = PetriNet.Place(name="p6")             # Approved, awaiting payment
p7    = PetriNet.Place(name="p7")             # Paid, awaiting notification
p8    = PetriNet.Place(name="p8")             # Notified, awaiting closure
end   = PetriNet.Place(name="end")            # Claim closed

for place in [start, p1, p2, p3, p4, p5, p6, p7, p8, end]:
    net.places.add(place)

#  Create Transitions (activities) 
t_c   = PetriNet.Transition(name="t_C",   label="Insurance Claim (C)")
t_cr  = PetriNet.Transition(name="t_CR",  label="Claim Registration (CR)")
t_dv  = PetriNet.Transition(name="t_DV",  label="Document Verification (DV)")
t_rds = PetriNet.Transition(name="t_RDS", label="Re-Document Submission (RDS)")
t_fc  = PetriNet.Transition(name="t_FC",  label="Fraud Check (FC)")
t_ii  = PetriNet.Transition(name="t_II",  label="In-depth Investigation (II)")
t_ca  = PetriNet.Transition(name="t_CA",  label="Claim Assessment (CA)")
t_ap  = PetriNet.Transition(name="t_AP",  label="Approval (AP)")
t_p   = PetriNet.Transition(name="t_P",   label="Payment (P)")
t_n   = PetriNet.Transition(name="t_N",   label="Notification (N)")
t_cl  = PetriNet.Transition(name="t_CL",  label="Closure (CL)")

for trans in [t_c, t_cr, t_dv, t_rds, t_fc, t_ii, t_ca, t_ap, t_p, t_n, t_cl]:
    net.transitions.add(trans)

#  Add Arcs: Main sequential flow 
#   start  [C]  p1  [CR]  p2  [DV]  p3  [FC]  p4
#    [CA]  p5  [AP]  p6  [P]  p7  [N]  p8  [CL]  end

petri_utils.add_arc_from_to(start, t_c, net)
petri_utils.add_arc_from_to(t_c,   p1,  net)

petri_utils.add_arc_from_to(p1,    t_cr, net)
petri_utils.add_arc_from_to(t_cr,  p2,   net)

petri_utils.add_arc_from_to(p2,    t_dv, net)
petri_utils.add_arc_from_to(t_dv,  p3,   net)

petri_utils.add_arc_from_to(p3,    t_fc, net)
petri_utils.add_arc_from_to(t_fc,  p4,   net)

petri_utils.add_arc_from_to(p4,    t_ca, net)
petri_utils.add_arc_from_to(t_ca,  p5,   net)

petri_utils.add_arc_from_to(p5,    t_ap, net)
petri_utils.add_arc_from_to(t_ap,  p6,   net)

petri_utils.add_arc_from_to(p6,    t_p,  net)
petri_utils.add_arc_from_to(t_p,   p7,   net)

petri_utils.add_arc_from_to(p7,    t_n,  net)
petri_utils.add_arc_from_to(t_n,   p8,   net)

petri_utils.add_arc_from_to(p8,    t_cl, net)
petri_utils.add_arc_from_to(t_cl,  end,  net)

#  Add Arcs: Loop 1 – Document Re-Submission 
#   After DV (p3), if docs incomplete  RDS  back to p2 (before DV)
petri_utils.add_arc_from_to(p3,    t_rds, net)
petri_utils.add_arc_from_to(t_rds, p2,    net)

#  Add Arcs: Loop 2 – In-depth Investigation 
#   After FC (p4), if doubts  II  back to p3 (before FC)
petri_utils.add_arc_from_to(p4,    t_ii, net)
petri_utils.add_arc_from_to(t_ii,  p3,   net)

#  Define Initial and Final Markings 
im = Marking()
im[start] = 1      # One token in start = a new claim has arrived

fm = Marking()
fm[end] = 1         # One token in end = claim is closed and archived
```

## Structural Summary

```
         [RDS] 
                         
start  [C]  [CR]  p2  [DV]  p3  [FC]  p4  [CA]  [AP]  [P]  [N]  [CL]  end
                                                 
                                    [II] 
```

| Component | Count | Details |
|-----------|-------|---------|
| **Places** | 10 | `start`, `p1`–`p8`, `end` |
| **Transitions** | 11 | C, CR, DV, **RDS**, FC, **II**, CA, AP, P, N, CL |
| **Arcs** | 26 | 22 (main flow) + 4 (two loops × 2 arcs each) |

**Key design decisions:**

- **Loop 1 (DV  RDS):** Place `p3` (post-DV) enables *either* `FC` (proceed) *or* `RDS` (re-submit). `RDS` returns the token to `p2` (pre-DV), forcing document re-verification.
- **Loop 2 (FC  II):** Place `p4` (post-FC) enables *either* `CA` (proceed) *or* `II` (investigate). `II` returns the token to `p3` (pre-FC), forcing a fresh fraud check. Both loops can execute zero or more times before the process advances — exactly matching the scenario's "multiple times" requirement.