This scenario describes a complex workflow that requires modeling sequential steps, conditional branching (approval threshold), and iterative loops (document re-submission, repeated investigation).

Here is the construction of the accepting Petri net in Python:

```python
from pm4py.objects.petri_net.obj import PetriNet, Marking
from pm4py.objects.petri_net.utils import petri_utils

# 1. Initialize the Petri Net
net = PetriNet(name="Insurance_Claim_Management")

# --- Places (States/Conditions) ---
# Start/End places
P_START = PetriNet.Place(name="P_Claim_Arrived")
P_END = PetriNet.Place(name="P_Claim_Closed")

# Intermediate states
P_CR = PetriNet.Place(name="P_Claim_Registered")
P_DV_READY = PetriNet.Place(name="P_Documents_Ready_For_Verification")
P_DV_OUT = PetriNet.Place(name="P_Document_Verification_Complete")
P_RDS_WAIT = PetriNet.Place(name="P_Waiting_for_RDS") # For incomplete docs loop

P_FC_READY = PetriNet.Place(name="P_Ready_For_Fraud_Check")
P_II_WAIT = PetriNet.Place(name="P_Waiting_for_Investigation") # For multi-iteration investigation loop

P_ASSESSED = PetriNet.Place(name="P_Assessment_Complete")
P_APPROVAL_DECISION = PetriNet.Place(name="P_Decision_Pending")
P_APPROVED = PetriNet.Place(name="P_Claim_Approved")
P_REJECTED_OR_LOWER_PAID = PetriNet.Place(name="P_Payment_Ready") # Simplified path for lower amounts

P_PAID = PetriNet.Place(name="P_Payment_Processed")
P_NOTIFIED = PetriNet.Place(name="P_Notification_Sent")

# Add all places to the net
net.places.update({
    P_START, P_END, P_CR, P_DV_READY, P_DV_OUT, P_RDS_WAIT,
    P_FC_READY, P_II_WAIT, P_ASSESSED, P_APPROVAL_DECISION, 
    P_APPROVED, P_REJECTED_OR_LOWER_PAID, P_PAID, P_NOTIFIED
})

# --- Transitions (Activities) ---
T_CR = PetriNet.Transition(name="T_Claim_Registration", label="Claim Registration (CR)")
T_DV = PetriNet.Transition(name="T_Doc_Verification", label="Document Verification (DV)")
T_RDS = PetriNet.Transition.Transition(name="T_Re_Doc_Submission", label="Re-Document Submission (RDS)") # Only used if DV fails

T_FC = PetriNet.Transition(name="T_Fraud_Check", label="Fraud Check (FC)")
T_II = PetriNet.Transition(name="T_InDepth_Investigation", label="In-depth Investigation (II)") # Can loop

T_CA = PetriNet.Transition(name="T_Claim_Assessment", label="Claim Assessment (CA)")

# Approval Gates (Splitting flow based on assessment value)
T_CHECK_APPROVAL = PetriNet.Transition(name="T_Check_Approval_Threshold", label="Check Threshold")
T_APPROVE = PetriNet.Transition(name="T_Approve", label="Approval (AP) - High Value")
T_LOW_PAYMENT = PetriNet.Transition(name="T_Low_Payment_Proceed", label="Low Value Payment Proceed")

T_P = PetriNet.Transition(name="T_Payment", label="Payment (P)")
T_N = PetriNet.Transition(name="T_Notification", label="Notification (N)")
T_CL = PetriNet.Transition(name="T_Closure", label="Closure (CL)")

# Add all transitions to the net
net.transitions.update({
    T_CR, T_DV, T_RDS, T_FC, T_II, T_CA, T_CHECK_APPROVAL, T_APPROVE, 
    T_LOW_PAYMENT, T_P, T_N, T_CL
})

# --- Arcs (Connecting the flow) ---

# 1. Start -> CR
petri_utils.add_arc_from_to(P_START, T_CR, net)

# 2. CR -> DV Ready
petri_utils.add_arc_from_to(T_CR, P_DV_READY, net)

# 3. Document Verification Flow (Loop for RDS)
petri_utils.add_arc_from_to(P_DV_READY, T_DV, net)
# Success path from DV
petri_utils.add_arc_from_to(T_DV, P_DV_OUT, net)
# Failure path (Rethrow token back to RDS wait state)
petri_utils.add_arc_from_to(T_DV, P_RDS_WAIT, net)
petri_utils.add_arc_from_to(P_RDS_WAIT, T_RDS, net)
# RDS feeds back to DV Ready for re-verification
petri_utils.add_arc_from_to(T_RDS, P_DV_READY, net)

# 4. DV Out -> FC Ready
petri_utils.add_arc_from_to(P_DV_OUT, T_FC, net)

# 5. Fraud Check Flow (Loop for II)
petri_utils.add_arc_from_to(T_FC, P_FC_READY, net)
# Success path from FC
petri_utils.add_arc_from_to(P_FC_READY, T_CA, net)
# Failure/Doubt path (Loop back via II)
petri_utils.add_arc_from_to(P_FC_READY, P_II_WAIT, net)
petri_utils.add_arc_from_to(P_II_WAIT, T_II, net)
# After Investigation, loop back to Fraud Check (FC Ready state)
petri_utils.add_arc_from_to(T_II, P_FC_READY, net)


# 6. Assessment -> Approval Check
petri_utils.add_arc_from_to(T_CA, P_APPROVAL_DECISION, net)
petri_utils.add_arc_from_to(P_APPROVAL_DECISION, T_CHECK_APPROVAL, net)

# 7. Approval Split
# If threshold exceeded (High Value) -> Requires explicit Approval (AP)
petri_utils.add_arc_from_to(T_CHECK_APPROVAL, P_APPROVED, net, condition='> Threshold') 
petri_utils.add_arc_from_to(P_APPROVED, T_APPROVE, net)
# If threshold not exceeded (Low Value) -> Proceed directly to Payment Ready
petri_utils.add_arc_from_to(T_CHECK_APPROVAL, P_REJECTED_OR_LOWER_PAID, net, condition='<= Threshold')
petri_utils.add_arc_from_to(T_LOW_PAYMENT, P_REJECTED_OR_LOWER_PAID, net) # T_LOW_PAYMENT acts as the transition for low value proceed

# Connect both high-value approved path and low-value path to Payment Ready
petri_utils.add_arc_from_to(T_APPROVE, P_PAID, net) # Assume approval implies payment is ready to be processed
petri_utils.add_arc_from_to(P_REJECTED_OR_LOWER_PAID, P_PAID, net)


# 8. Payment -> Notification -> Closure
petri_utils.add_arc_from_to(P_PAID, T_P, net)
petri_utils.add_arc_from_to(T_P, P_NOTIFIED, net)
petri_utils.add_arc_from_to(P_NOTIFIED, T_N, net)
petri_utils.add_arc_from_to(T_N, P_END, net)


# --- Initial and Final Markings ---

# Initial Marking: Start with one token in P_Claim_Arrived
im = Marking()
im[P_START] = 1

# Final Marking: Token in P_END (Claim Closed)
fm = Marking()
fm[P_END] = 1

print("Accepting Petri Net Constructed Successfully.")
print(f"Total Places: {len(net.places)}")
print(f"Total Transitions: {len(net.transitions)}")

# Verification of markings (optional)
print(f"\nInitial Marking (im): {im}")
print(f"Final Marking (fm): {fm}")
```