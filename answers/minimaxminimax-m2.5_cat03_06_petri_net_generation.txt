<think>
The user is asking to "Construct an accepting Petri net for this scenario." They provide a description of a process for insurance claim management. The process has steps: C (Insurance Claim), CR, DV, RDS (optional), FC, II (optional), CA, AP (conditional on amount threshold), P, N, CL. There can be loops: between DV and RDS, and between FC and II.

The user wants Python code constructing the Petri net using pm4py library. The code should create places and transitions accordingly, with arcs connecting them, and define initial and final markings.

We need to produce a solution: a python code block that defines a Petri net, with appropriate places (states), transitions labeled with activity names, arcs connecting them, and include loops for RDS and II. Also initial and final marking: a start place with token, and final marking on a place representing closed claim.

We need to think about the semantics: The initial claim (C) may be considered the start of process. They likely want a start place "start" representing new claim arriving. Then transition "Insurance Claim" leading to a place after "C"? The problem description: "Customer files an Insurance Claim (C), after which the following steps take place..." So perhaps the first activity is "Insurance Claim (C)", then "Claim Registration (CR)", etc. However, in typical process modeling, the start event is "Insurance Claim" (the filing). But the question says "The initial marking should place a token in a start place, representing a new claim arriving." So we should have a place "Start" that is initial. Then transition "Insurance Claim" from start to a place representing claim filed. But the given description may also treat "Insurance Claim (C)" as the initial activity that triggers the process. The user explicitly says "Consider a complex insurance claim management process ... A customer files an Insurance Claim (C), after which the following steps take place: ...". So maybe we should model: place start -> transition "Insurance Claim (C)" -> place after C (maybe "Claim Registered"?). Then continue with steps: Claim Registration (CR) etc. But the first step after C is Claim Registration (CR), so perhaps the transition "Insurance Claim (C)" leads to place "Claim Filed". Then transition "Claim Registration (CR)" leads to place "Documents Verified"? Actually we have Document Verification after CR: after registration, documents verification takes place. However, they also have Document Verification (DV) as a separate activity. In typical process: Claim Registration (CR) then Document Verification (DV). So maybe we have:

- Place after start: "Claim filed" (call it p_claim_filed). Then transition "Claim Registration (CR)" moves from p_claim_filed to p_doc_verif (maybe p_doc_verification). Then transition "Document Verification (DV)" moves from p_doc_verif to p_fraud_check? Actually the sequence is: CR -> DV -> FC -> CA -> AP -> P -> N -> CL. In some cases loops: after DV there can be RDS (re-document submission) that loops back to DV (or maybe to CR?). Similarly, after FC there can be II loop back to FC (or maybe to CA?). The loops are like: DV -> (if documents incomplete) -> RDS -> (back to DV) -> ... So the loop is between DV and RDS. For FC -> (if doubts) -> II -> (back to FC) -> ... So it's a loop from FC to II and back to FC. But also note that after loops, the process proceeds to next step.

Thus we need to design a net that reflects these possibilities.

Let's define:

- Start place: p_start.
- Transition "Insurance Claim (C)" from p_start to p_claim_filed? Actually they might want the first transition to be "Insurance Claim (C)" to represent the filing event. Then after that, the claim is registered automatically? The description "Customer files an Insurance Claim (C), after which the following steps take place: 1. Claim Registration (CR): The claim is logged into the system." So the process begins when a claim is filed. Then "Claim Registration" is the first activity after the claim is filed. So perhaps the first activity is C itself. So start token in start place, then transition C leads to some place representing claim being filed (maybe p_filed). Then transition CR from that place to next place (p_doc_verification). Then DV, etc.

Thus the net should include the following transitions and places:

Transitions:

- "Insurance Claim (C)"
- "Claim Registration (CR)"
- "Document Verification (DV)"
- "Re-Document Submission (RDS)" (optional loop)
- "Fraud Check (FC)"
- "In-depth Investigation (II)" (optional loop)
- "Claim Assessment (CA)"
- "Approval (AP)" (conditional: if amount > threshold; maybe this is represented as a separate transition; but for modeling we treat as a normal transition).
- "Payment (P)"
- "Notification (N)"
- "Closure (CL)"

Potential places:

- p_start (initial marking)
- p_claim_filed (after C)
- p_claim_registered (after CR)
- p_doc_verified (after DV, before FC)
- p_fraud_checked (after FC)
- p_claim_assessed (after CA)
- p_approved (after AP)
- p_payment (after P)
- p_notification (after N)
- p_closed (final marking)

But also need to incorporate loops:

- After DV, if docs incomplete, go to RDS, which leads back to either p_doc_verified (or p_claim_registered?). The description says "If documents are incomplete after Document Verification (DV), a re-submission of documents step occurs (RDS) before the process continues." So the flow is: after DV, if incomplete -> RDS -> (back to DV). So we can create a place "p_doc_verified" which has an outgoing transition "DV" to p_doc_verified? Actually DV is the activity; after DV we are at a place p_doc_verified? Then we need a decision: either proceed to next step (Fraud Check) or loop to RDS. In Petri nets, you typically have a place before the transition; so maybe we have a place p_doc_verified, then transition "DV" leads to p_after_dv. Then we have a decision (i.e., two outgoing arcs from p_after_dv: one to next step (FC), and one to RDS loop). However, for loops, you could have a place p_doc_pending, then transition "RDS" leads to p_doc_verified again. Let's design more concretely:

- p_start -> transition C -> p_claim_filed
- p_claim_filed -> transition CR -> p_claim_registered
- p_claim_registered -> transition DV -> p_doc_verification (or p_doc_verified)
- From p_doc_verification, we have two possible outgoing transitions: either go to "FC" (Fraud Check) if docs are ok, or go to "RDS" (Re-Document Submission) if docs are incomplete. After RDS, we need to go back to the place before DV to re-verify. So we need to connect RDS transition back to p_claim_registered (or p_doc_pending?) Actually after RDS, the documents are re-submitted, which then leads to DV again. So we could loop back to the place before DV (i.e., p_claim_registered). Then transition DV again from p_claim_registered to p_doc_verification.

Thus: p_claim_registered -> transition DV -> p_doc_verification. Then p_doc_verification has two outgoing arcs: one to FC (to proceed) and one to RDS. The transition RDS leads back to p_claim_registered (or maybe to p_claim_registered). Then from p_claim_registered again we go through DV, and eventually we go to FC. However, need to ensure proper semantics: after RDS, the process goes to DV again. So we need to loop: p_doc_verification -> RDS -> p_claim_registered. Then p_claim_registered -> DV -> p_doc_verification. So that is a loop.

Similarly for fraud check:

- p_doc_verification -> transition FC -> p_fraud_checked
- Then from p_fraud_checked we have two outgoing arcs: one to CA (if no suspicion), and one to II (if suspicion). Then transition II leads back to p_fraud_checked? Or maybe back to p_fraud_checked? Actually after II (in-depth investigation), we need to check again, i.e., go back to FC. So we could have p_fraud_checked -> transition FC -> p_fraud_checked? Wait that's not correct. Let's define: after FC, we are at a place p_fraud_checked (the result of FC). Then we can either go to CA (if ok) or to II for further investigation. The transition II leads back to p_fraud_checked (so that after investigation, we go through FC again). But maybe we need a place "p_fraud_checked" before FC and after FC. Actually we need a place before FC: p_doc_verification (or p_fraud_check_pending?). Let's re-evaluate.

Simplify: The standard modeling for loops: we have a place p_fraud_check_pending, then transition "FC" leads to p_fraud_checked. Then from p_fraud_checked, we can either go to CA or go to II. After II (which is a transition), we need to go back to p_fraud_check_pending to re-run FC. So we need to decide which place we treat as the start of the loop. Typically we have a place before the transition that can be visited multiple times. So we can define a place "p_fraud_check_pending". Then transition FC from p_fraud_check_pending to p_fraud_checked. Then from p_fraud_checked, either go to CA or go to II. The transition II goes from p_fraud_checked back to p_fraud_check_pending (so after investigation, we go to the check again). That models a loop: FC -> p_fraud_checked -> II -> p_fraud_check_pending -> FC again.

Alternatively, we can have a transition "FC" from p_doc_verification to p_fraud_checked, then a decision: from p_fraud_checked, go to CA or go to II. Then transition II leads back to p_doc_verification? Actually after II, you want to re-do the fraud check, so you go back to p_doc_verification (the place before FC). So we can have II from p_fraud_checked to p_doc_verification. That is also a loop: FC -> p_fraud_checked -> II -> p_doc_verification -> FC again.

But the description says: "If the Fraud Check (FC) raises doubts, an additional In-depth Investigation (II) is performed. This can happen multiple times before proceeding to Claim Assessment (CA)." So the loop is between FC and II: after FC, if doubts, do II, then go back to FC. So we can model as: p_doc_verification -> FC -> p_fraud_checked. Then from p_fraud_checked, we have two outgoing arcs: one to CA (if passes) and one to II (if doubts). Then transition II leads back to p_doc_verification (or to the place before FC). Actually to re-run FC after II, we need to go to p_doc_verification (or to the place before FC). However, the phrase "This can happen multiple times before proceeding to Claim Assessment (CA)" suggests that after II we go back to FC (i.e., we repeat the Fraud Check). So we can have II transition from p_fraud_checked back to p_doc_verification, then FC again. But that would skip the step of FC? Actually if we go back to p_doc_verification, we need to apply FC again to get to p_fraud_checked. That's fine. So we can define the loop as p_doc_verification -> FC -> p_fraud_checked -> II -> p_doc_verification. Then from p_fraud_checked we also have direct transition to CA (when no doubts). That works.

Thus final flow after loops is: after FC passes, go to Claim Assessment (CA). Then from CA go to Approval (AP). Then Payment (P), Notification (N), Closure (CL). Then final place.

Thus overall places and transitions:

- p_start (initial)
- p_claim_filed (after C)
- p_claim_registered (after CR)
- p_doc_verification (after DV)
- p_fraud_checked (after FC)
- p_claim_assessed (after CA)
- p_approved (after AP)
- p_payment (after P)
- p_notification (after N)
- p_closed (final)

We also need loops:

- Between p_doc_verification and p_claim_registered via RDS.
- Between p_fraud_checked and p_doc_verification via II.

But note: after RDS we go to p_claim_registered to re-do DV. So after RDS, we go to p_claim_registered (the place before DV). Then we do DV again to p_doc_verification. So we need to connect transition RDS from p_doc_verification to p_claim_registered. However, to have a proper loop, we also need a place after RDS that leads back to DV. But that's p_claim_registered. So we can have RDS transition directly from p_doc_verification to p_claim_registered. Then from p_claim_registered we have transition DV again to p_doc_verification. That models the loop: p_claim_registered -> DV -> p_doc_verification -> (either go to FC or loop back via RDS) -> p_claim_registered. Good.

Similarly for FC and II: we have p_doc_verification -> FC -> p_fraud_checked. Then from p_fraud_checked we have two outgoing arcs: to CA (the normal path) and to II (the loop). Then II transition goes back to p_doc_verification (so after II, we go back to do FC again). That models the loop: p_doc_verification -> FC -> p_fraud_checked -> II -> p_doc_verification.

Thus the net can be built as:

- start place p_start
- transition t_C (label "Insurance Claim (C)") from p_start to p_claim_filed
- transition t_CR (label "Claim Registration (CR)") from p_claim_filed to p_claim_registered
- transition t_DV (label "Document Verification (DV)") from p_claim_registered to p_doc_verification
- transition t_RDS (label "Re-Document Submission (RDS)") from p_doc_verification to p_claim_registered (loop)
- transition t_FC (label "Fraud Check (FC)") from p_doc_verification to p_fraud_checked
- transition t_II (label "In-depth Investigation (II)") from p_fraud_checked to p_doc_verification (loop)
- transition t_CA (label "Claim Assessment (CA)") from p_fraud_checked to p_claim_assessed
- transition t_AP (label "Approval (AP)") from p_claim_assessed to p_approved
- transition t_P (label "Payment (P)") from p_approved to p_payment
- transition t_N (label "Notification (N)") from p_payment to p_notification
- transition t_CL (label "Closure (CL)") from p_notification to p_closed

We also need final marking: token at p_closed.

We also need initial marking: token at p_start.

Thus we can code it:

```python
from pm4py.objects.petri_net.obj import PetriNet, Marking
from pm4py.objects.petri_net.utils import petri_utils

# Create the Petri net
net = PetriNet("insurance_claim_net")

# Places
start = PetriNet.Place("start")
p_claim_filed = PetriNet.Place("p_claim_filed")
p_claim_registered = PetriNet.Place("p_claim_registered")
p_doc_verification = PetriNet.Place("p_doc_verification")
p_fraud_checked = PetriNet.Place("p_fraud_checked")
p_claim_assessed = PetriNet.Place("p_claim_assessed")
p_approved = PetriNet.Place("p_approved")
p_payment = PetriNet.Place("p_payment")
p_notification = PetriNet.Place("p_notification")
p_closed = PetriNet.Place("p_closed")

# Add places to net
for p in [start, p_claim_filed, p_claim_registered, p_doc_verification,
           p_fraud_checked, p_claim_assessed, p_approved, p_payment,
           p_notification, p_closed]:
    net.places.add(p)

# Transitions (with labels)
t_C = PetriNet.Transition("Insurance Claim (C)", "Insurance Claim (C)")
t_CR = PetriNet.Transition("Claim Registration (CR)", "Claim Registration (CR)")
t_DV = PetriNet.Transition("Document Verification (DV)", "Document Verification (DV)")
t_RDS = PetriNet.Transition("Re-Document Submission (RDS)", "Re-Document Submission (RDS)")
t_FC = PetriNet.Transition("Fraud Check (FC)", "Fraud Check (FC)")
t_II = PetriNet.Transition("In-depth Investigation (II)", "In-depth Investigation (II)")
t_CA = PetriNet.Transition("Claim Assessment (CA)", "Claim Assessment (CA)")
t_AP = PetriNet.Transition("Approval (AP)", "Approval (AP)")
t_P = PetriNet.Transition("Payment (P)", "Payment (P)")
t_N = PetriNet.Transition("Notification (N)", "Notification (N)")
t_CL = PetriNet.Transition("Closure (CL)", "Closure (CL)")

# Add transitions to net
for t in [t_C, t_CR, t_DV, t_RDS, t_FC, t_II, t_CA, t_AP, t_P, t_N, t_CL]:
    net.transitions.add(t)

# Add arcs
petri_utils.add_arc_from_to(start, t_C, net)
petri_utils.add_arc_from_to(t_C, p_claim_filed, net)

petri_utils.add_arc_from_to(p_claim_filed, t_CR, net)
petri_utils.add_arc_from_to(t_CR, p_claim_registered, net)

petri_utils.add_arc_from_to(p_claim_registered, t_DV, net)
petri_utils.add_arc_from_to(t_DV, p_doc_verification, net)

# Loop: document verification -> RDS -> back to p_claim_registered
petri_utils.add_arc_from_to(p_doc_verification, t_RDS, net)
petri_utils.add_arc_from_to(t_RDS, p_claim_registered, net)

# Fraud check
petri_utils.add_arc_from_to(p_doc_verification, t_FC, net)
petri_utils.add_arc_from_to(t_FC, p_fraud_checked, net)

# Loop: fraud check -> II -> back to p_doc_verification
petri_utils.add_arc_from_to(p_fraud_checked, t_II, net)
petri_utils.add_arc_from_to(t_II, p_doc_verification, net)

# Continue to claim assessment
petri_utils.add_arc_from_to(p_fraud_checked, t_CA, net)
petri_utils.add_arc_from_to(t_CA, p_claim_assessed, net)

# Approval
petri_utils.add_arc_from_to(p_claim_assessed, t_AP, net)
petri_utils.add_arc_from_to(t_AP, p_approved, net)

# Payment
petri_utils.add_arc_from_to(p_approved, t_P, net)
petri_utils.add_arc_from_to(t_P, p_payment, net)

# Notification
petri_utils.add_arc_from_to(p_payment, t_N, net)
petri_utils.add_arc_from_to(t_N, p_notification, net)

# Closure (final)
petri_utils.add_arc_from_to(p_notification, t_CL, net)
petri_utils.add_arc_from_to(t_CL, p_closed, net)

# Initial marking
im = Marking()
im[start] = 1

# Final marking
fm = Marking()
fm[p_closed] = 1

# Optionally, you can also add the net, im, fm to a dictionary for later use
```

Make sure to note that we used the correct class names: `PetriNet.Place`, `PetriNet.Transition`. And we imported `petri_utils`.

One nuance: In pm4py, the transition label is given as the second argument to the Transition constructor: `PetriNet.Transition(name, label)`. The name can be same as label or different. In the example, they used `PetriNet.Transition(name="execute_activity", label="Execute Activity")`. So we can do similarly: `PetriNet.Transition(name="Insurance Claim (C)", label="Insurance Claim (C)")`.

Thus final code is ready.

We need to provide the code with proper imports and definitions, and also describe the net in text? The question: "Your task: Construct an accepting Petri net for this scenario. The Petri net should have places representing states between these activities, transitions labeled with the activity names, and arcs connecting them to form a logical sequence with possible loops (e.g., between DV and RDS if documents need re-submission, between FC and II if in-depth investigation is required multiple times). The initial marking should place a token in a start place, representing a new claim arriving. The final marking should represent a closed claim. Provide the Python code for constructing the Petri net using `pm4py.objects.petri_net.obj.PetriNet`, `pm4py.objects.petri_net.obj.Marking`, and `pm4py.objects.petri_net.utils.petri_utils`, and define both the initial marking (im) and final marking (fm)."

Thus we need to output code. Also could add comments describing the net.

Thus answer should be a code block with imports, net creation, place creation, transition creation, arcs, initial and final marking. Should also mention that we might also want to add additional arcs for the loops.

We also need to be careful about naming: In pm4py, the class for places and transitions is `PetriNet.Place` and `PetriNet.Transition`. However, the import in example is `from pm4py.objects.petri_net.obj import PetriNet, Marking`. So we can do `PetriNet.Place` and `PetriNet.Transition`. The `petri_utils` is imported as `from pm4py.objects.petri_net.utils import petri_utils`. Then we can use `petri_utils.add_arc_from_to(source, target, net)`.

We need to ensure that we use correct syntax for adding arcs: The function expects either a place and transition, or transition and place. The order matters: `add_arc_from_to(source, target, net)`. The source can be a place or transition; the target can be transition or place. For arcs from place to transition, we pass place first then transition. For arcs from transition to place, we pass transition first then place. In our code we used that.

We also need to add the net, im, fm for later usage.

Thus final answer: Provide code with comments.

Potential improvements: Add a "sink" place? Not needed. The example removed sink. But we don't need to remove any place.

Thus answer: Provide code.

Also note: The user may want to see the net visualized. But they only asked for code.

Thus answer will be code with explanation.

We can also add that we can use `pm4py.view_petri_net` to visualize, but not needed.

Thus answer: Provide code.

We'll also add some comments to explain each part.

Thus final answer is code block.

Potential pitfalls: The `PetriNet.Transition` constructor expects name and label. In the example they used `PetriNet.Transition(name="execute_activity", label="Execute Activity")`. So we can pass name and label as separate arguments: `PetriNet.Transition("Insurance Claim (C)", "Insurance Claim (C)")`. Or we can pass as keyword arguments: `PetriNet.Transition(name="Insurance Claim (C)", label="Insurance Claim (C)")`. Both are fine.

Thus
</think>
Below is a complete, selfcontained Python script that builds an **accepting Petri net** for the insuranceclaim process described in the prompt.  
The net contains:

* a *start* place with one token (the initial marking),  
* a *closed* place that holds the token when the process finishes (the final marking),  
* places that represent the different states between the activities,  
* transitions labeled with the activity names, and  
* two loops – one for *ReDocument Submission* (RDS) and one for *Indepth Investigation* (II).

You can copypaste the code into a Python environment that has **pm4py** installed (e.g. `pip install pm4py`).

```python
# --------------------------------------------------------------
# Accepting Petri net for the insuranceclaim management process
# --------------------------------------------------------------

# Imports --------------------------------------------------------------------
from pm4py.objects.petri_net.obj import PetriNet, Marking
from pm4py.objects.petri_net.utils import petri_utils

# Create an (empty) Petri net -----------------------------------------------
net = PetriNet("insurance_claim_net")

# ----------------------------------------------------------------------
# PLACES
# ----------------------------------------------------------------------
# Each place represents a state in the process.
start                = PetriNet.Place("start")
p_claim_filed        = PetriNet.Place("p_claim_filed")
p_claim_registered  = PetriNet.Place("p_claim_registered")
p_doc_verification   = PetriNet.Place("p_doc_verification")
p_fraud_checked      = PetriNet.Place("p_fraud_checked")
p_claim_assessed     = PetriNet.Place("p_claim_assessed")
p_approved           = PetriNet.Place("p_approved")
p_payment            = PetriNet.Place("p_payment")
p_notification       = PetriNet.Place("p_notification")
p_closed             = PetriNet.Place("p_closed")          # final state

# Add all places to the net
for p in (start, p_claim_filed, p_claim_registered, p_doc_verification,
           p_fraud_checked, p_claim_assessed, p_approved, p_payment,
           p_notification, p_closed):
    net.places.add(p)

# ----------------------------------------------------------------------
# TRANSITIONS
# ----------------------------------------------------------------------
# Each transition corresponds to an activity (the label that will be shown
# in a process tree / BPMN / Petri net visualisation).
t_C    = PetriNet.Transition("Insurance Claim (C)",            "Insurance Claim (C)")
t_CR   = PetriNet.Transition("Claim Registration (CR)",        "Claim Registration (CR)")
t_DV   = PetriNet.Transition("Document Verification (DV)",     "Document Verification (DV)")
t_RDS  = PetriNet.Transition("ReDocument Submission (RDS)",   "ReDocument Submission (RDS)")
t_FC   = PetriNet.Transition("Fraud Check (FC)",               "Fraud Check (FC)")
t_II   = PetriNet.Transition("Indepth Investigation (II)",    "Indepth Investigation (II)")
t_CA   = PetriNet.Transition("Claim Assessment (CA)",           "Claim Assessment (CA)")
t_AP   = PetriNet.Transition("Approval (AP)",                  "Approval (AP)")
t_P    = PetriNet.Transition("Payment (P)",                    "Payment (P)")
t_N    = PetriNet.Transition("Notification (N)",               "Notification (N)")
t_CL   = PetriNet.Transition("Closure (CL)",                   "Closure (CL)")

# Add all transitions to the net
for t in (t_C, t_CR, t_DV, t_RDS, t_FC, t_II,
           t_CA, t_AP, t_P, t_N, t_CL):
    net.transitions.add(t)

# ----------------------------------------------------------------------
# ARCS (flow relations)
# ----------------------------------------------------------------------
# 1  Start of the process – a new claim arrives
petri_utils.add_arc_from_to(start,                t_C,   net)
petri_utils.add_arc_from_to(t_C,                  p_claim_filed, net)

# 2  Claim registration
petri_utils.add_arc_from_to(p_claim_filed,       t_CR,  net)
petri_utils.add_arc_from_to(t_CR,                 p_claim_registered, net)

# 3  Document verification (DV)
petri_utils.add_arc_from_to(p_claim_registered,  t_DV,  net)
petri_utils.add_arc_from_to(t_DV,                 p_doc_verification, net)

# 4  Loop: if documents are incomplete  redocument submission (RDS)
petri_utils.add_arc_from_to(p_doc_verification,  t_RDS, net)
petri_utils.add_arc_from_to(t_RDS,                p_claim_registered, net)   # back to the state *before* DV

# 5  Fraud check (FC)
petri_utils.add_arc_from_to(p_doc_verification,  t_FC,  net)
petri_utils.add_arc_from_to(t_FC,                 p_fraud_checked, net)

# 6  Loop: if doubts arise  indepth investigation (II)
petri_utils.add_arc_from_to(p_fraud_checked,     t_II,  net)
petri_utils.add_arc_from_to(t_II,                p_doc_verification, net)   # repeat FC after the investigation

# 7  Continue with the “happypath” after the loops
petri_utils.add_arc_from_to(p_fraud_checked,     t_CA,  net)
petri_utils.add_arc_from_to(t_CA,                p_claim_assessed, net)

# 8  Approval (AP) – senior manager signoff for highvalue claims
petri_utils.add_arc_from_to(p_claim_assessed,    t_AP,  net)
petri_utils.add_arc_from_to(t_AP,                p_approved, net)

# 9  Payment (P)
petri_utils.add_arc_from_to(p_approved,          t_P,   net)
petri_utils.add_arc_from_to(t_P,                 p_payment, net)

#   Notification (N)
petri_utils.add_arc_from_to(p_payment,            t_N,   net)
petri_utils.add_arc_from_to(t_N,                 p_notification, net)

# 11  Closure (CL) – final step
petri_utils.add_arc_from_to(p_notification,       t_CL,  net)
petri_utils.add_arc_from_to(t_CL,                 p_closed, net)

# ----------------------------------------------------------------------
# MARKINGS (initial and final)
# ----------------------------------------------------------------------
# Initial marking – a token in the start place
im = Marking()
im[start] = 1

# Final marking – a token in the place that represents a closed claim
fm = Marking()
fm[p_closed] = 1

# ----------------------------------------------------------------------
# (Optional) You can now visualise the net with pm4py, e.g.:
#   from pm4py.visualization.petri_net import visualizer as vn
#   vn.view(net, im, fm)
# ----------------------------------------------------------------------
```

### What the net models

| Place / Transition | Meaning in the process |
|--------------------|-----------------------|
| **start**          | A new claim arrives (initial token). |
| **t_C  p_claim_filed** | The claim is filed. |
| **t_CR  p_claim_registered** | Claim is registered in the system. |
| **t_DV  p_doc_verification** | Documents are verified. |
| **t_RDS  p_claim_registered** | If documents are incomplete, a *redocument submission* loop brings the token back to the “registered” state, so the verification can be repeated. |
| **t_FC  p_fraud_checked** | Fraud check is performed. |
| **t_II  p_doc_verification** | If fraud doubts arise, an *indepth investigation* loop returns the token to the “document verification” state, forcing another fraud check. |
| **t_CA  p_claim_assessed** | Claim is assessed. |
| **t_AP  p_approved** | Approval (senior manager) for highvalue claims. |
| **t_P  p_payment** | Payment is executed. |
| **t_N  p_notification** | Customer is notified. |
| **t_CL  p_closed** | The claim is closed – this place holds the final token. |

The two loops (`DV  RDS  …` and `FC  II  …`) allow the process to repeat those activities any number of times before moving forward, exactly as described in the scenario. The initial marking (`im`) contains a single token in **start**, and the final marking (`fm`) contains a single token in **p_closed**, making this an **accepting Petri net**.