Below is one way of encoding the described flow as an accepting Petri net. Each activity is a transition carrying the given label, and places model the states in between. The loops for resubmitting documents and repeated investigations are realized by feeding tokens back into the corresponding prestates. The initial marking puts a token into the start place to represent a new claim; the final marking has a token in the closedclaim place after the `Closure` transition has fired:

```python
from pm4py.objects.petri_net.obj import PetriNet, Marking
from pm4py.objects.petri_net.utils import petri_utils

net = PetriNet("InsuranceClaimProcess")

# places
p_start = PetriNet.Place("p_start")
p_after_c = PetriNet.Place("p_after_claim_filed")
p_after_cr = PetriNet.Place("p_after_registration")
p_ready_for_fc = PetriNet.Place("p_ready_for_fraud_check")
p_after_fc = PetriNet.Place("p_after_fraud_check")
p_after_ca = PetriNet.Place("p_after_assessment")
p_after_ap = PetriNet.Place("p_after_approval")
p_after_p = PetriNet.Place("p_after_payment")
p_after_n = PetriNet.Place("p_after_notification")
p_closed = PetriNet.Place("p_closed")

net.places.update({
    p_start, p_after_c, p_after_cr, p_ready_for_fc, p_after_fc,
    p_after_ca, p_after_ap, p_after_p, p_after_n, p_closed
})

# transitions (names are internal, labels are the business activity)
t_c   = PetriNet.Transition("t_c",   "Insurance Claim")
t_cr  = PetriNet.Transition("t_cr",  "Claim Registration")
t_dv  = PetriNet.Transition("t_dv",  "Document Verification")
t_rds = PetriNet.Transition("t_rds", "Re-Document Submission")
t_fc  = PetriNet.Transition("t_fc",  "Fraud Check")
t_ii  = PetriNet.Transition("t_ii",  "In-depth Investigation")
t_ca  = PetriNet.Transition("t_ca",  "Claim Assessment")
t_ap  = PetriNet.Transition("t_ap",  "Approval")
t_p   = PetriNet.Transition("t_p",   "Payment")
t_n   = PetriNet.Transition("t_n",   "Notification")
t_cl  = PetriNet.Transition("t_cl",  "Closure")

net.transitions.update({t_c, t_cr, t_dv, t_rds, t_fc, t_ii, t_ca, t_ap, t_p, t_n, t_cl})

# flow relation
petri_utils.add_arc_from_to(p_start, t_c, net)
petri_utils.add_arc_from_to(t_c, p_after_c, net)

petri_utils.add_arc_from_to(p_after_c, t_cr, net)
petri_utils.add_arc_from_to(t_cr, p_after_cr, net)

petri_utils.add_arc_from_to(p_after_cr, t_dv, net)
petri_utils.add_arc_from_to(t_dv, p_ready_for_fc, net)

# if documents incomplete, re-submit and go back before DV
petri_utils.add_arc_from_to(p_ready_for_fc, t_rds, net)
petri_utils.add_arc_from_to(t_rds, p_after_cr, net)

# fraud check
petri_utils.add_arc_from_to(p_ready_for_fc, t_fc, net)
petri_utils.add_arc_from_to(t_fc, p_after_fc, net)

# in-depth investigation can loop back to fraud check as many times as needed
petri_utils.add_arc_from_to(p_after_fc, t_ii, net)
petri_utils.add_arc_from_to(t_ii, p_ready_for_fc, net)

# once FC is satisfactory, continue with assessment and downstream steps
petri_utils.add_arc_from_to(p_after_fc, t_ca, net)
petri_utils.add_arc_from_to(t_ca, p_after_ca, net)

petri_utils.add_arc_from_to(p_after_ca, t_ap, net)
petri_utils.add_arc_from_to(t_ap, p_after_ap, net)

petri_utils.add_arc_from_to(p_after_ap, t_p, net)
petri_utils.add_arc_from_to(t_p, p_after_p, net)

petri_utils.add_arc_from_to(p_after_p, t_n, net)
petri_utils.add_arc_from_to(t_n, p_after_n, net)

petri_utils.add_arc_from_to(p_after_n, t_cl, net)
petri_utils.add_arc_from_to(t_cl, p_closed, net)

# initial and final markings
im = Marking()
im[p_start] = 1  # new claim arrives

fm = Marking()
fm[p_closed] = 1  # claim closed
```

The accepting Petri net is given by the triple `(net, im, fm)`. Tokens can circulate through the `Re-Document Submission` loop between `Document Verification` and back to registration, and through the `In-depth Investigation` loop between `Fraud Check` and back to fraud checking, until the claim eventually progresses to closure.