<think>
1.  **Understand the Goal**: The user wants a Python dictionary representing a *DECLARE model* for a specific business scenario (Product Design and Launch Process). The dictionary must adhere to a specific structure and key definitions provided in the prompt.

2.  **Analyze the Input Data (Scenario)**:
    *   **Activities (Nodes)**:
        1.  IG (Idea Generation)
        2.  DD (Design Draft)
        3.  TFC (Technical Feasibility Check)
        4.  CE (Cost Evaluation)
        5.  PC (Prototype Creation)
        6.  LT (Laboratory Testing)
        7.  UT (User Testing)
        8.  AG (Approval Gate)
        9.  MP (Marketing Plan)
        10. FL (Final Launch)
    *   **Process Flow (Inferred)**:
        *   IG -> DD (Brainstorm -> Design)
        *   DD -> TFC (Design -> Check)
        *   DD -> CE (Design -> Cost) - *implied parallel activities or sequential* (Usually, a design is checked for feasibility and cost before prototyping). Let's assume they follow DD.
        *   TFC -> PC (Feasible -> Prototype)
        *   CE -> PC (Affordable -> Prototype)
        *   PC -> LT (Prototype -> Testing)
        *   LT -> UT (Technical Test -> User Test)
        *   UT -> AG (User Feedback -> Approval)
        *   AG -> MP (Approved -> Marketing)
        *   MP -> FL (Marketing Plan -> Launch)

    *   *Simplified Flow*: IG -> DD -> (TFC, CE) -> PC -> LT -> UT -> AG -> MP -> FL.

3.  **Analyze the Model Structure (Prompt Requirements)**:
    The dictionary has 14 keys.
    *   **Group 1 (Unitary/Existential)**: `'existence', 'absence', 'exactly_one', 'init'`
        *   Keys: Activity names.
        *   Values: Dictionary with keys `'support'` and `'confidence'`. According to the prompt text, the value is `(1.0, 1.0)` for these specific types (unless the prompt implies they are defined later, but the prompt says "For the keys {...}, the value is... support (1.0) and confidence of the declarative rule"). *Wait*, reading carefully: "For the keys `{'existence', ...}`, the value is a dictionary containing as keys the activities and as corresponding value the support (1.0) and confidence of the declarative rule."
        *   Correction/Refinement: In pm4py, *declarative rules* usually have parameters like `support` and `confidence` if they are rules extracted from data. However, the prompt specifically defines the value for these keys as "support (1.0) and confidence". This usually means the value associated with the activity *is* the parameters (or a tuple of them). Let's stick to the prompt's definition: `{activity: {'support': 1.0, 'confidence': 1.0}}`.

    *   **Group 2 (Relational)**: `'responded_existence', 'coexistence', 'response', 'precedence', 'succession', 'altresponse', 'altprecedence', 'altsuccession', 'chainresponse', 'chainprecedence', 'chainsuccession', 'noncoexistence', 'nonsuccession', 'nonchainsuccession'`
        *   Format: `{activity_1, activity_2: {'support': 1.0, 'confidence': 1.0}}` (usually, though sometimes implied pairs).
        *   The prompt says: "For the keys [...], the value is a dictionary containing as keys the activities and as corresponding value the support (1.0) and confidence of the declarative rule."
        *   This implies a structure like `{("A", "B"): {"support": 1.0, "confidence": 1.0}}` or `{("B", "A"): ...}`.
        *   Let's construct rules based on the process flow.

4.  **Constructing the Dictionary**:

    *   **Base Activities**: IG, DD, TFC, CE, PC, LT, UT, AG, MP, FL.

    *   **`'existence'`**: Every activity happens at least once in every trace.
        *   Value: `{activity: {'support': 1.0, 'confidence': 1.0} for activity in activities}`

    *   **`'absence'`**: No direct blocking (most likely 0 or empty). The prompt implies keys are activities, but usually, absence rules involve two activities (A must not be followed by B). However, the prompt strictly says "containing as keys the activities". This might mean unitary absence? Or absence of a *single* activity? Let's assume unitary absence (A never occurs) or pairs. Given the process flow, all activities are required. So 'absence' might be empty or standard pm4py might expect pairs. I will follow the prompt strictly: keys are activities. So, I'll probably put an empty dictionary or include unlikely combinations. Let's leave it empty or put 1.0 for specific activities that never appear. Actually, strictly following the key definition "containing as keys the activities", it looks like `{'IG': ..., 'DD': ...}`. Let's assume the user wants the rules populated.

    *   **`'exactly_one'`**: Only one specific activity happens (unlikely in a complex process, maybe 'init' or specific approvals). Or, it could mean exactly one specific activity *has to happen*. This seems specific. Let's look at 'init' instead.

    *   **`'init'`**: The process starts with a specific activity.
        *   Here, it starts with **IG**.

    *   **`'responded_existence'`**: A occurs immediately before B occurs (Succession).
        *   IG -> DD
        *   DD -> TFC
        *   DD -> CE
        *   TFC -> PC
        *   CE -> PC
        *   PC -> LT
        *   LT -> UT
        *   UT -> AG
        *   AG -> MP
        *   MP -> FL

    *   **`'coexistence'`**: A occurs before B (maybe parallel branches).
        *   TFC and CE happen after DD. So DD precedes TFC and DD precedes CE.
        *   Or maybe TFC and CE happen roughly together (overlap). If they are sequential, this might not apply. If parallel, `DD precedes TFC` and `DD precedes CE`.

    *   **`'response'`**: A is successful if B occurs (more specific than succession). Let's stick to succession logic for simplicity unless specified otherwise. Response usually means A must be followed by B, but *not necessarily immediately*. Let's keep it as immediate succession for this "complex" scenario or standard `responded_existence` (which is usually succession) vs `response` (allowing gaps). Given the complexity, I'll treat `response` as A is followed by B (non-strict) and `responded_existence` as immediate.

    *   **`'precedence'`**: A must be followed by B (allowing gaps).
        *   IG before DD
        *   IG before AG
        *   ... essentially all pairs where A is earlier in the list.

    *   **`'succession'`**: A must be immediately followed by B.
        *   Matches the flow defined above.

    *   **`'altresponse'`, `'altprecedence'`, `'altsuccession'`**: Alternating logic. A or B.
        *   TFC and CE are distinct paths after DD. DD -> TFC OR DD -> CE?
        *   Actually, usually DD leads to both. Or maybe they are alternatives. Let's define them as `TFC` precedes `PC` and `CE` precedes `PC`.

    *   **`'chainresponse'`, `'chainprecedence'`, `'chainsuccession'`**: Chain logic. A, B, C or A, C, B. A restricted type of precedence.
        *   The main flow is a single chain: IG -> ... -> FL.
        *   Maybe there are branching chains (Design checks -> Prototype).
        *   A (TFC/CE) -> PC. This is a path. Chain follows the path.
        *   I will define a chain `IG -> ... -> FL`? No, `chainsuccession` usually requires at least 3 steps? No, 2 is a minimum. I'll assume a general chain `IG -> DD -> TFC` (IG leads to DD which leads to TFC).

    *   **`'noncoexistence'`**: A and B do not happen (simultaneously or A before B). In process mining, usually A must not be followed by B.
    *   **`'nonsuccession'`**: A is *not* immediately followed by B.
    *   **`'nonchainsuccession'`**: Not a chain of B following A.

5.  **Refining the Model for the User**:
    The prompt asks to construct the dictionary. I should provide a concrete dictionary. Since this is a hypothetical scenario, I need to define the relationships clearly to make the dictionary useful.

    Let's define the core flow:
    1. IG -> DD -> (TFC, CE) -> PC -> LT -> UT -> AG -> MP -> FL

    Let's populate the dictionary fields based on this flow.

    *   *existence*: All activities are present. `{a: {...} for a in list}`
    *   *absence*: (Optional, or explicitly no activities are excluded)
    *   *exactly_one*: Maybe "Final Launch" happens exactly once? Or "Approval Gate"? Usually, in a specific case study, we define rules. Let's stick to existence first.
    *   *init*: IG

    *   *Relationships*:
        *   Succession (Immediate): IG-DD, DD-TFC, DD-CE, TFC-PC, CE-PC, PC-LT, LT-UT, UT-AG, AG-MP, MP-FL.
        *   Response (A followed by B): Same as succession or allows gaps. Let's use same for simplicity or slightly looser. Let's stick to defined flow.
        *   Precedence (A before B): IG before everything else. DD before TFC, PC, etc.
        *   Coexistence: TFC and CE happen around the same time? If sequential, no coexistence. If parallel, yes. Let's assume they happen in sequence for this specific "Process" flow, so maybe I won't list them unless I frame it as an alternative. Let's look at `altsuccession`: TFC and CE are alternatives for "Post-DD tasks" leading to PC. So `TFC` `alt-succession` `PC` and `CE` `alt-succession` `PC`.

6.  **Drafting the Dictionary Content**:

    ```python
    declare_model = {
        'existence': {
            'IG': {'support': 1.0, 'confidence': 1.0},
            'DD': {'support': 1.0, 'confidence': 1.0},
            'TFC': {'support': 1.0, 'confidence': 1.0},
            'CE': {'support': 1.0, 'confidence': 1.0},
            'PC': {'support': 1.0, 'confidence': 1.0},
            'LT': {'support': 1.0, 'confidence': 1.0},
            'UT': {'support': 1.0, 'confidence': 1.0},
            'AG': {'support': 1.0, 'confidence': 1.0},
            'MP': {'support': 1.0, 'confidence': 1.0},
            'FL': {'support': 1.0, 'confidence': 1.0}
        },
        'absence': {}, # No activities are explicitly forbidden or missing
        'exactly_one': {'FL': {'support': 1.0, 'confidence': 1.0}}, # Assume Launch happens once per process instance
        'init': {'IG': {'support': 1.0, 'confidence': 1.0}},

        # Response & Precedence (General)
        'precedence': {
            ('IG', 'DD'): {'support': 1.0, 'confidence': 1.0},
            ('IG', 'AG'): {'support': 1.0, 'confidence': 1.0},
            ('IG', 'FL'): {'support': 1.0, 'confidence': 1.0},
            ('DD', 'PC'): {'support': 1.0, 'confidence': 1.0},
            ('DD', 'TFC'): {'support': 1.0, 'confidence': 1.0},
            ('DD', 'CE'): {'support': 1.0, 'confidence': 1.0},
            # ... add more for a complete model
        },
        'response': { # A is followed by B (non-strict)
             ('IG', 'DD'): {'support': 1.0, 'confidence': 1.0},
             # ...
        },
        'responded_existence': { # Immediate succession
             ('IG', 'DD'): {'support': 1.0, 'confidence': 1.0},
             # ...
        },

        # Succession (Immediate)
        'succession': {
             ('IG', 'DD'): {'support': 1.0, 'confidence': 1.0},
             ('DD', 'TFC'): {'support': 1.0, 'confidence': 1.0},
             ('DD', 'CE'): {'support': 1.0, 'confidence': 1.0},
             ('TFC', 'PC'): {'support': 1.0, 'confidence': 1.0},
             ('CE', 'PC'): {'support': 1.0, 'confidence': 1.0},
             ('PC', 'LT'): {'support': 1.0, 'confidence': 1.0},
             ('LT', 'UT'): {'support': 1.0, 'confidence': 1.0},
             ('UT', 'AG'): {'support': 1.0, 'confidence': 1.0},
             ('AG', 'MP'): {'support': 1.0, 'confidence': 1.0},
             ('MP', 'FL'): {'support': 1.0, 'confidence': 1.0}
        },

        # Alternatives (TFC and CE both need to happen, but are sequential options)
        'altsuccession': {
             ('TFC', 'PC'): {'support': 1.0, 'confidence': 1.0},
             ('CE', 'PC'): {'support': 1.0, 'confidence': 1.0}
        },
        'altresponse': {
             ('TFC', 'PC'): {'support': 1.0, 'confidence': 1.0},
             ('CE', 'PC'): {'support': 1.0, 'confidence': 1.0}
        },
        'altprecedence': {
             ('TFC', 'PC'): {'support': 1.0, 'confidence': 1.0},
             ('CE', 'PC'): {'support': 1.0, 'confidence': 1.0}
        },

        # Chain Logic (IG, DD, TFC or IG, DD, CE)
        'chainprecedence': {
             ('IG', 'DD', 'TFC'): {'support': 1.0, 'confidence': 1.0}, # Conceptually, IG->DD->TFC is the path
             # Or maybe just branching. Let's stick to the main line.
             ('IG', 'DD', 'TFC'): {'support': 1.0, 'confidence': 1.0},
             ('IG', 'DD', 'CE'): {'support': 1.0, 'confidence': 1.0}
        },
        'chainresponse': { ... },
        'chainsuccession': { ... },

        # Non-relationships (Optional but good for completeness)
        'noncoexistence': {},
        'nonsuccession': {},
        'nonchainsuccession': {}
    }
    ```

7.  **Refining based on Prompt Specifics**:
    The prompt defines the structure:
    "For the keys `{'existence', ...}`, the value is a dictionary containing as keys the activities..."
    "For the keys `{'responded_existence', ...}`, the value is a dictionary containing as keys the activities and as corresponding value the support (1.0) and confidence..."

    This phrasing is slightly ambiguous for the relational keys. Is the value a dict of tuples? Or a dict of activities?
    *Interpretation A*: `{'succession': {('A', 'B'): {...}}}`. This is the standard pm4py format.
    *Interpretation B*: `{'succession': {'A': {('B',): {...}}}}`. (Unlikely).
    *Interpretation C*: `{'succession': {('A', 'B'): {'support': 1.0, 'confidence': 1.0}}}`. (This is the standard format).

    I will use the tuple keys for relational rules.

8.  **Final Polish of the Dictionary**:
    I need to make sure the activities are named correctly.
    Activities: `IG`, `DD`, `TFC`, `CE`, `PC`, `LT`, `UT`, `AG`, `MP`, `FL`.

    *   **existence**: All 10.
    *   **absence**: None (all required).
    *   **exactly_one**: `FL` (Launch).
    *   **init**: `IG`.

    *   **succession**:
        *   IG -> DD
        *   DD -> TFC
        *   DD -> CE
        *   TFC -> PC
        *   CE -> PC
        *   PC -> LT
        *   LT -> UT
        *   UT -> AG
        *   AG -> MP
        *   MP -> FL

    *   **response**: (A before B)
        *   Since the process is a strict chain, Response is identical to Responded Existence (immediate) or Precedence (allowing gaps). I'll include the same set for completeness, perhaps relaxing to just `IG` before everything for Precedence.

    *   **responded_existence**: Same as Succession (Immediate succession).

    *   **precedence**: IG before all others.

    *   **coexistence**: This is hard to infer from a simple list. I'll leave it empty or assume specific overlaps if applicable. I will leave it empty to avoid hallucinating process details not in the prompt (e.g. if TFC and CE are parallel, that's a big assumption).

    *   **altresponse/altprecedence/altsuccession**: TFC and CE are branches. I'll define them as `TFC` and `CE` both leading to `PC`.

    *   **chain...**: I'll define a chain involving the start and a key step. `IG, DD, TFC` or `IG, DD, CE`.

    *   **non...**: `nonsuccession` etc. This implies violations. Since there are no constraints violated in the prompt's ideal process, these are usually empty or defined if there are exceptions. I will leave them empty for a "correct" process model.

    *   **nonsuccession**: `DD` is not immediately followed by `LT`.

9.  **Formatting the Output**: Provide the dictionary code block.

    *Self-Correction on "Value" definition*: The prompt says "For the keys `{'existence', ...}`, the value is a dictionary containing as keys the activities and as corresponding value the support (1.0) and confidence".
    Okay, so the structure is:
    Key: 'existence'
    Value: { 'IG': {'support': 1.0, 'confidence': 1.0}, ... }

    Key: 'succession'
    Value: { ('IG', 'DD'): {'support': 1.0, 'confidence': 1.0}, ... }

    This matches standard pm4py conventions.

10. **Final Review of Scenario Logic**:
    Does the process make sense?
    Idea -> Design -> (Feasibility/Cost) -> Prototype -> Test -> User -> Approved -> Marketing -> Launch. Yes.

    Let's write the code.
</think>
```python
declare_model = {
    'existence': {
        'IG': {'support': 1.0, 'confidence': 1.0},
        'DD': {'support': 1.0, 'confidence': 1.0},
        'TFC': {'support': 1.0, 'confidence': 1.0},
        'CE': {'support': 1.0, 'confidence': 1.0},
        'PC': {'support': 1.0, 'confidence': 1.0},
        'LT': {'support': 1.0, 'confidence': 1.0},
        'UT': {'support': 1.0, 'confidence': 1.0},
        'AG': {'support': 1.0, 'confidence': 1.0},
        'MP': {'support': 1.0, 'confidence': 1.0},
        'FL': {'support': 1.0, 'confidence': 1.0}
    },
    'absence': {},
    'exactly_one': {
        'FL': {'support': 1.0, 'confidence': 1.0}
    },
    'init': {
        'IG': {'support': 1.0, 'confidence': 1.0}
    },
    'responded_existence': {
        ('IG', 'DD'): {'support': 1.0, 'confidence': 1.0},
        ('DD', 'TFC'): {'support': 1.0, 'confidence': 1.0},
        ('DD', 'CE'): {'support': 1.0, 'confidence': 1.0},
        ('TFC', 'PC'): {'support': 1.0, 'confidence': 1.0},
        ('CE', 'PC'): {'support': 1.0, 'confidence': 1.0},
        ('PC', 'LT'): {'support': 1.0, 'confidence': 1.0},
        ('LT', 'UT'): {'support': 1.0, 'confidence': 1.0},
        ('UT', 'AG'): {'support': 1.0, 'confidence': 1.0},
        ('AG', 'MP'): {'support': 1.0, 'confidence': 1.0},
        ('MP', 'FL'): {'support': 1.0, 'confidence': 1.0}
    },
    'coexistence': {},
    'response': {
        ('IG', 'DD'): {'support': 1.0, 'confidence': 1.0},
        ('IG', 'AG'): {'support': 1.0, 'confidence': 1.0},
        ('IG', 'FL'): {'support': 1.0, 'confidence': 1.0},
        ('DD', 'PC'): {'support': 1.0, 'confidence': 1.0},
        ('DD', 'TFC'): {'support': 1.0, 'confidence': 1.0},
        ('DD', 'CE'): {'support': 1.0, 'confidence': 1.0},
        ('PC', 'LT'): {'support': 1.0, 'confidence': 1.0},
        ('LT', 'UT'): {'support': 1.0, 'confidence': 1.0},
        ('UT', 'AG'): {'support': 1.0, 'confidence': 1.0},
        ('AG', 'MP'): {'support': 1.0, 'confidence': 1.0},
        ('MP', 'FL'): {'support': 1.0, 'confidence': 1.0}
    },
    'precedence': {
        ('IG', 'DD'): {'support': 1.0, 'confidence': 1.0},
        ('IG', 'TFC'): {'support': 1.0, 'confidence': 1.0},
        ('IG', 'CE'): {'support': 1.0, 'confidence': 1.0},
        ('IG', 'PC'): {'support': 1.0, 'confidence': 1.0},
        ('IG', 'LT'): {'support': 1.0, 'confidence': 1.0},
        ('IG', 'UT'): {'support': 1.0, 'confidence': 1.0},
        ('IG', 'AG'): {'support': 1.0, 'confidence': 1.0},
        ('IG', 'MP'): {'support': 1.0, 'confidence': 1.0},
        ('IG', 'FL'): {'support': 1.0, 'confidence': 1.0},
        ('DD', 'PC'): {'support': 1.0, 'confidence': 1.0},
        ('DD', 'LT'): {'support': 1.0, 'confidence': 1.0},
        ('DD', 'UT'): {'support': 1.0, 'confidence': 1.0},
        ('DD', 'AG'): {'support': 1.0, 'confidence': 1.0},
        ('DD', 'MP'): {'support': 1.0, 'confidence': 1.0},
        ('DD', 'FL'): {'support': 1.0, 'confidence': 1.0},
        ('TFC', 'PC'): {'support': 1.0, 'confidence': 1.0},
        ('TFC', 'LT'): {'support': 1.0, 'confidence': 1.0},
        ('TFC', 'UT'): {'support': 1.0, 'confidence': 1.0},
        ('TFC', 'AG'): {'support': 1.0, 'confidence': 1.0},
        ('TFC', 'MP'): {'support': 1.0, 'confidence': 1.0},
        ('TFC', 'FL'): {'support': 1.0, 'confidence': 1.0},
        ('CE', 'PC'): {'support': 1.0, 'confidence': 1.0},
        ('CE', 'LT'): {'support': 1.0, 'confidence': 1.0},
        ('CE', 'UT'): {'support': 1.0, 'confidence': 1.0},
        ('CE', 'AG'): {'support': 1.0, 'confidence': 1.0},
        ('CE', 'MP'): {'support': 1.0, 'confidence': 1.0},
        ('CE', 'FL'): {'support': 1.0, 'confidence': 1.0},
        ('PC', 'LT'): {'support': 1.0, 'confidence': 1.0},
        ('PC', 'UT'): {'support': 1.0, 'confidence': 1.0},
        ('PC', 'AG'): {'support': 1.0, 'confidence': 1.0},
        ('PC', 'MP'): {'support': 1.0, 'confidence': 1.0},
        ('PC', 'FL'): {'support': 1.0, 'confidence': 1.0},
        ('LT', 'UT'): {'support': 1.0, 'confidence': 1.0},
        ('LT', 'AG'): {'support': 1.0, 'confidence': 1.0},
        ('LT', 'MP'): {'support': 1.0, 'confidence': 1.0},
        ('LT', 'FL'): {'support': 1.0, 'confidence': 1.0},
        ('UT', 'AG'): {'support': 1.0, 'confidence': 1.0},
        ('UT', 'MP'): {'support': 1.0, 'confidence': 1.0},
        ('UT', 'FL'): {'support': 1.0, 'confidence': 1.0},
        ('AG', 'MP'): {'support': 1.0, 'confidence': 1.0},
        ('AG', 'FL'): {'support': 1.0, 'confidence': 1.0},
        ('MP', 'FL'): {'support': 1.0, 'confidence': 1.0}
    },
    'succession': {
        ('IG', 'DD'): {'support': 1.0, 'confidence': 1.0},
        ('DD', 'TFC'): {'support': 1.0, 'confidence': 1.0},
        ('DD', 'CE'): {'support': 1.0, 'confidence': 1.0},
        ('TFC', 'PC'): {'support': 1.0, 'confidence': 1.0},
        ('CE', 'PC'): {'support': 1.0, 'confidence': 1.0},
        ('PC', 'LT'): {'support': 1.0, 'confidence': 1.0},
        ('LT', 'UT'): {'support': 1.0, 'confidence': 1.0},
        ('UT', 'AG'): {'support': 1.0, 'confidence': 1.0},
        ('AG', 'MP'): {'support': 1.0, 'confidence': 1.0},
        ('MP', 'FL'): {'support': 1.0, 'confidence': 1.0}
    },
    'altresponse': {
        ('TFC', 'PC'): {'support': 1.0, 'confidence': 1.0},
        ('CE', 'PC'): {'support': 1.0, 'confidence': 1.0}
    },
    'altprecedence': {
        ('TFC', 'PC'): {'support': 1.0, 'confidence': 1.0},
        ('CE', 'PC'): {'support': 1.0, 'confidence': 1.0}
    },
    'altsuccession': {
        ('TFC', 'PC'): {'support': 1.0, 'confidence': 1.0},
        ('CE', 'PC'): {'support': 1.0, 'confidence': 1.0}
    },
    'chainresponse': {
        ('IG', 'DD', 'TFC'): {'support': 1.0, 'confidence': 1.0},
        ('IG', 'DD', 'CE'): {'support': 1.0, 'confidence': 1.0}
    },
    'chainprecedence': {
        ('IG', 'DD', 'TFC'): {'support': 1.0, 'confidence': 1.0},
        ('IG', 'DD', 'CE'): {'support': 1.0, 'confidence': 1.0}
    },
    'chainsuccession': {
        ('IG', 'DD', 'TFC'): {'support': 1.0, 'confidence': 1.0},
        ('IG', 'DD', 'CE'): {'support': 1.0, 'confidence': 1.0}
    },
    'noncoexistence': {},
    'nonsuccession': {
        ('IG', 'TFC'): {'support': 1.0, 'confidence': 1.0},
        ('IG', 'CE'): {'support': 1.0, 'confidence': 1.0},
        ('IG', 'PC'): {'support': 1.0, 'confidence': 1.0},
        ('IG', 'LT'): {'support': 1.0, 'confidence': 1.0},
        ('IG', 'UT'): {'support': 1.0, 'confidence': 1.0},
        ('IG', 'AG'): {'support': 1.0, 'confidence': 1.0},
        ('IG', 'MP'): {'support': 1.0, 'confidence': 1.0},
        ('IG', 'FL'): {'support': 1.0, 'confidence': 1.0},
        ('DD', 'PC'): {'support': 1.0, 'confidence': 1.0},
        ('DD', 'LT'): {'support': 1.0, 'confidence': 1.0},
        ('DD', 'UT'): {'support': 1.0, 'confidence': 1.0},
        ('DD', 'AG'): {'support': 1.0, 'confidence': 1.0},
        ('DD', 'MP'): {'support': 1.0, 'confidence': 1.0},
        ('DD', 'FL'): {'support': 1.0, 'confidence': 1.0},
        ('TFC', 'LT'): {'support': 1.0, 'confidence': 1.0},
        ('TFC', 'UT'): {'support': 1.0, 'confidence': 1.0},
        ('TFC', 'AG'): {'support': 1.0, 'confidence': 1.0},
        ('TFC', 'MP'): {'support': 1.0, 'confidence': 1.0},
        ('TFC', 'FL'): {'support': 1.0, 'confidence': 1.0},
        ('CE', 'LT'): {'support': 1.0, 'confidence': 1.0},
        ('CE', 'UT'): {'support': 1.0, 'confidence': 1.0},
        ('CE', 'AG'): {'support': 1.0, 'confidence': 1.0},
        ('CE', 'MP'): {'support': 1.0, 'confidence': 1.0},
        ('CE', 'FL'): {'support': 1.0, 'confidence': 1.0},
        ('PC', 'LT'): {'support': 1.0, 'confidence': 1.0},
        ('PC', 'UT'): {'support': 1.0, 'confidence': 1.0},
        ('PC', 'AG'): {'support': 1.0, 'confidence': 1.0},
        ('PC', 'MP'): {'support': 1.0, 'confidence': 1.0},
        ('PC', 'FL'): {'support': 1.0, 'confidence': 1.0},
        ('LT', 'AG'): {'support': 1.0, 'confidence': 1.0},
        ('LT', 'MP'): {'support': 1.0, 'confidence': 1.0},
        ('LT', 'FL'): {'support': 1.0, 'confidence': 1.0},
        ('UT', 'MP'): {'support': 1.0, 'confidence': 1.0},
        ('UT', 'FL'): {'support': 1.0, 'confidence': 1.0},
        ('AG', 'FL'): {'support': 1.0, 'confidence': 1.0},
        ('MP', 'FL'): {'support': 1.0, 'confidence': 1.0}
    },
    'nonchainsuccession': {}
}
```