Below are two POWL models in pm4py style. They share the same intake loop and sequencing, but differ in the cultural-fit stage: the first introduces an XOR with a CommunityAffiliationCheck branch (potential unfairness), the second removes this branch so all applicants take the same path.

POWL Model 1: With potential unfairness (XOR allowing a CommunityAffiliationCheck path that subtly tilts outcomes)
```python
import pm4py
from pm4py.objects.powl.obj import StrictPartialOrder, OperatorPOWL, Transition
from pm4py.objects.process_tree.obj import Operator

# Activities
ReceiveApplication_u = Transition(label="ReceiveApplication")
DataCompletenessCheck_u = Transition(label="DataCompletenessCheck")
RequestMoreInfo_u = Transition(label="RequestMoreInfo")
SkillAssessment_u = Transition(label="SkillAssessment")

# Unfair branch: either standard CulturalFitCheck, or CommunityAffiliationCheck then CulturalFitCheck (with potential uplift)
CommunityAffiliationCheck_u = Transition(label="CommunityAffiliationCheck")
CulturalFitCheck_standard_u = Transition(label="CulturalFitCheck")
CulturalFitCheck_after_affil_u = Transition(label="CulturalFitCheck")

ManagerialReview_u = Transition(label="ManagerialReview")
FinalDecision_u = Transition(label="FinalDecision")

# Loop for data completeness
data_loop_u = OperatorPOWL(operator=Operator.LOOP, children=[DataCompletenessCheck_u, RequestMoreInfo_u])

# Affiliation path: CommunityAffiliationCheck -> CulturalFitCheck
affil_then_culture_u = StrictPartialOrder(nodes=[CommunityAffiliationCheck_u, CulturalFitCheck_after_affil_u])
affil_then_culture_u.order.add_edge(CommunityAffiliationCheck_u, CulturalFitCheck_after_affil_u)

# XOR: standard CulturalFitCheck vs. affiliation-influenced path
unfair_xor_u = OperatorPOWL(operator=Operator.XOR, children=[CulturalFitCheck_standard_u, affil_then_culture_u])

# Root partial order (overall flow)
root_unfair = StrictPartialOrder(nodes=[
    ReceiveApplication_u,
    data_loop_u,
    SkillAssessment_u,
    unfair_xor_u,
    ManagerialReview_u,
    FinalDecision_u
])

# Sequential ordering
root_unfair.order.add_edge(ReceiveApplication_u, data_loop_u)
root_unfair.order.add_edge(data_loop_u, SkillAssessment_u)
root_unfair.order.add_edge(SkillAssessment_u, unfair_xor_u)
root_unfair.order.add_edge(unfair_xor_u, ManagerialReview_u)
root_unfair.order.add_edge(ManagerialReview_u, FinalDecision_u)
```

POWL Model 2: Without unfairness (all applicants go through the same CulturalFitCheck, no community-based branch)
```python
import pm4py
from pm4py.objects.powl.obj import StrictPartialOrder, OperatorPOWL, Transition
from pm4py.objects.process_tree.obj import Operator

# Activities
ReceiveApplication_f = Transition(label="ReceiveApplication")
DataCompletenessCheck_f = Transition(label="DataCompletenessCheck")
RequestMoreInfo_f = Transition(label="RequestMoreInfo")
SkillAssessment_f = Transition(label="SkillAssessment")
CulturalFitCheck_f = Transition(label="CulturalFitCheck")
ManagerialReview_f = Transition(label="ManagerialReview")
FinalDecision_f = Transition(label="FinalDecision")

# Loop for data completeness
data_loop_f = OperatorPOWL(operator=Operator.LOOP, children=[DataCompletenessCheck_f, RequestMoreInfo_f])

# Root partial order (overall flow, no XOR advantage branch)
root_fair = StrictPartialOrder(nodes=[
    ReceiveApplication_f,
    data_loop_f,
    SkillAssessment_f,
    CulturalFitCheck_f,
    ManagerialReview_f,
    FinalDecision_f
])

# Sequential ordering
root_fair.order.add_edge(ReceiveApplication_f, data_loop_f)
root_fair.order.add_edge(data_loop_f, SkillAssessment_f)
root_fair.order.add_edge(SkillAssessment_f, CulturalFitCheck_f)
root_fair.order.add_edge(CulturalFitCheck_f, ManagerialReview_f)
root_fair.order.add_edge(ManagerialReview_f, FinalDecision_f)
```