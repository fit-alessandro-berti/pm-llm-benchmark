<think>
We are given the database schema and example event log data. The task is to identify anomalies and undesirable behaviors in the event logs, hypothesize why they might occur, and propose SQL queries to investigate.

Let's first look at the example data and then think about possible anomalies.

### Observing the Event Logs for Anomalies

Looking at the event logs (order_event_log) for case_id 1001 to 1004:

**Case 1001:**
- Register Order (Sales) -> 2024-02-01 08:15:00
- Perform Credit Check (Finance) -> 2024-02-01 08:30:00
- Validate Stock (Warehouse) -> 2024-02-01 09:00:00
- Confirm Shipment (Logistics) -> 2024-02-01 09:15:00
- Ship Goods (Warehouse) -> 2024-02-01 09:45:00
- Issue Invoice (Finance) -> 2024-02-01 10:00:00
- Receive Payment (Finance) -> 2024-02-05 15:00:00

This seems normal.

**Case 1002:**
- Register Order (Sales) -> 2024-02-01 08:20:00
- Confirm Shipment (Logistics) -> 2024-02-01 08:25:00  [This is out of order! Payment hasn't been received yet and invoice not issued?]
- Ship Goods (Warehouse) -> 2024-02-01 08:40:00
- Perform Credit Check (Finance) -> 2024-02-01 09:10:00  [After Ship Goods?]
- Validate Stock (Warehouse) -> 2024-02-01 09:15:00
- Issue Invoice (Finance) -> 2024-02-01 09:30:00
- Receive Payment (Finance) -> 2024-02-02 10:00:00

Anomalies in Case 1002:
1. Confirm Shipment (Logistics) happens before Validate Stock (Warehouse) and Perform Credit Check (Finance). Typically, Validate Stock should happen before Confirm Shipment.
2. Perform Credit Check (Finance) happens after Ship Goods (Warehouse). Credit check should be done before shipping.

**Case 1003:**
- Register Order (Sales) -> 2024-02-01 08:45:00
- Perform Credit Check (Finance) -> 2024-02-01 09:00:00
- Ship Goods (Warehouse) -> 2024-02-01 09:10:00   [Without Confirming Shipment?]
- Issue Invoice (Finance) -> 2024-02-01 09:30:00
- Confirm Shipment (Logistics) -> 2024-02-01 09:45:00   [After Issue Invoice?]
- Receive Payment (Finance) -> 2024-02-02 11:00:00

Anomalies in Case 1003:
1. Ship Goods happens without a Confirm Shipment? But note: the activity "Ship Goods" is present. However, the sequence is:
   - After Credit Check, they ship the goods and then issue an invoice. Typically, Confirm Shipment should be done before issuing an invoice? But the example has an activity "Confirm Shipment" after invoice.

   However, looking at the expected process flow:
   1. Register Order (Sales)
   2. Perform Credit Check (Finance)
   3. Validate Stock (Warehouse)
   4. Confirm Shipment (Logistics)
   5. Ship Goods (Logistics)
   6. Issue Invoice (Finance)
   7. Receive Payment (Finance)

   So in Case 1003:
   - Credit Check done -> then Ship Goods (without Validate Stock or Confirm Shipment) -> then Issue Invoice -> then Confirm Shipment? 
   This is out of order.

**Case 1004:**
- Register Order (Sales) -> 2024-02-01 09:00:00
- Receive Payment (Finance) -> 2024-02-01 09:05:00   [Before any other activities?]
- Issue Invoice (Finance) -> 2024-02-01 09:20:00
- Confirm Shipment (Logistics) -> 2024-02-01 09:25:00   [Without shipping? Actually, it says "shipment_scheduled=N" meaning not scheduled?]
- Ship Goods (Warehouse) -> 2024-02-01 09:50:00

Anomalies in Case 1004:
1. Receive Payment happens very early (before Credit Check, Validate Stock, etc.). This should not happen until after the order is processed and the credit check is done? 
2. Confirm Shipment has "shipment_scheduled=N", which might mean that the shipment was not scheduled? But then they did ship goods? That seems inconsistent.

### Possible Explanations for Anomalies

1. **Case 1002:**
   - The Confirm Shipment happened too early (before stock validation and credit check). Maybe the system allowed early confirmation due to a system error? Or perhaps the order was urgent and the warehouse took the initiative?

2. **Case 1003:**
   - The order skipped the Validate Stock step and the Confirm Shipment step was done after the invoice was issued. This might be because the order was already validated by the sales team? But the process expects Validate Stock (warehouse) to happen. Alternatively, it could be an error in the system.

3. **Case 1004:**
   - Receive Payment happened without any prior steps. This might be an override for a cash order? But the order type is standard. Alternatively, it could be a system error that skipped steps.

### Hypotheses

- **Hypothesis 1:** There is a system error or process flaw that allows steps to be performed out of order. For example, in Case 1002, the Confirm Shipment might have been triggered by an urgent situation, but the system didn't enforce the order.
- **Hypothesis 2:** Some steps might be skipped or reordered intentionally for special orders. For example, Case 1004 might be a same-day order that bypassed the usual steps? But the order value is 3000, which is high.
- **Hypothesis 3:** The data entry might have been incorrect, leading to missing or incorrect steps.

### SQL Queries to Investigate

We can write queries to analyze the sequence of events per case and identify deviations from the expected order.

Expected order (based on the process flow):
1. 'Register Order'
2. 'Perform Credit Check'
3. 'Validate Stock'
4. 'Confirm Shipment'
5. 'Ship Goods'
6. 'Issue Invoice'
7. 'Receive Payment'

We can assign an order number to each event in the log and then check for each case if the events follow the expected order.

#### Query 1: Check the sequence of events for each order and flag any deviations.

We can assign a sequence number for the expected steps and then compare with the actual events.

Note: The example process flow is fixed, but in reality, we might have the same step multiple times? (But the example doesn't). So we can map the activity to the expected step index.

Let's map the activities to their expected step index:

Step 1: Register Order
Step 2: Perform Credit Check
Step 3: Validate Stock
Step 4: Confirm Shipment
Step 5: Ship Goods
Step 6: Issue Invoice
Step 7: Receive Payment

We can create a CTE that assigns the expected step index for each activity, then join with the event_log and order_event_log to get the timestamp and resource.

But note: the same step might appear multiple times? The example doesn't show duplicates. We assume each step is done once.

We can write:

```sql
WITH expected_steps AS (
    SELECT activity, step_index
    FROM (
        SELECT 'Register Order' AS activity, 1 AS step_index
        UNION ALL
        SELECT 'Perform Credit Check', 2
        UNION ALL
        SELECT 'Validate Stock', 3
        UNION ALL
        SELECT 'Confirm Shipment', 4
        UNION ALL
        SELECT 'Ship Goods', 5
        UNION ALL
        SELECT 'Issue Invoice', 6
        UNION ALL
        SELECT 'Receive Payment', 7
    ) AS steps
),
event_data AS (
    SELECT 
        oel.case_id,
        oel.activity,
        oel.timestamp,
        oel.resource,
        ests.step_index
    FROM order_event_log oel
    JOIN expected_steps ests ON oel.activity = ests.activity
    -- We might want to filter to only these activities to avoid nulls
),
ordered_events AS (
    SELECT 
        case_id,
        activity,
        timestamp,
        resource,
        step_index,
        ROW_NUMBER() OVER (PARTITION BY case_id ORDER BY timestamp) AS event_order
    FROM event_data
),
expected_sequence AS (
    SELECT 
        case_id,
        step_index,
        ROW_NUMBER() OVER (PARTITION BY case_id ORDER BY min_timestamp) AS expected_order
    FROM (
        SELECT 
            case_id,
            MIN(timestamp) AS min_timestamp,
            step_index
        FROM order_event_log oel
        JOIN expected_steps ON oel.activity = expected_steps.activity
        GROUP BY case_id, step_index
    ) AS events_per_case
)
SELECT 
    oe.case_id,
    oe.activity,
    oe.timestamp,
    oe.resource,
    oe.step_index,
    es.expected_order,
    oe.event_order
FROM ordered_events oe
JOIN expected_sequence es 
    ON oe.case_id = es.case_id AND oe.step_index = es.step_index
ORDER BY case_id;
```

But this might be too heavy. Alternatively, we can check for each case the sequence of step_index values and compare with the expected order.

Alternatively, we can for each case, get the sequence of step_index in the order of the timestamp and then check if it matches [1,2,3,4,5,6,7].

Query 2: Check the sequence of step_index for each case.

```sql
WITH events_per_case AS (
    SELECT 
        case_id,
        activity,
        step_index,
        ROW_NUMBER() OVER (PARTITION BY case_id ORDER BY timestamp) AS event_seq
    FROM order_event_log
    JOIN expected_steps USING (activity)
),
sequence_per_case AS (
    SELECT 
        case_id,
        event_seq,
        step_index,
        ROW_NUMBER() OVER (PARTITION BY case_id ORDER BY event_seq) AS actual_order
    FROM (
        SELECT 
            case_id,
            activity,
            step_index,
            event_seq
        FROM events_per_case
    ) AS events
)
SELECT 
    case_id,
    MAX(step_index) OVER (PARTITION BY case_id) AS max_step_index_reached,
    MIN(step_index) OVER (PARTITION BY case_id) AS min_step_index_reached,
    COUNT(*) AS total_events,
    ARRAY_AGG(step_index) OVER (PARTITION BY case_id) AS step_sequence
FROM sequence_per_case
GROUP BY case_id, event_seq
```

But this is complex. Instead, we can simply check for each case the sequence of step_index and see if it matches the expected [1,2,3,4,5,6,7] in order.

We can do:

For each case, collect the step_index in the order of occurrence and then check if the array is [1,2,3,4,5,6,7].

But note: the step_index might not be contiguous? But in the example they are.

Alternatively, we can check the step_index for the events in the order of occurrence and see if they are increasing by 1 each time and starting at 1 and ending at 7.

But let me simplify: For each case, we want to see the step_index of each event in the order of time. Then we can check if the step_index sequence is 1,2,3,4,5,6,7 without gaps.

We can do:

```sql
SELECT 
    case_id,
    event_order,
    step_index,
    (SELECT COUNT(*) FROM (
        SELECT 1 AS step_index
        FROM order_event_log oel
        JOIN expected_steps ests ON oel.activity = ests.activity
        WHERE oel.case_id =ocs.case_id
        ORDER BY oel.timestamp
        LIMIT 1
    ) AS first_step) as first_step_present,
    ... -- This is too complicated.
```

Alternatively, we can use a recursive CTE to generate the expected sequence and then compare with the actual sequence. But that might be heavy.

Instead, let's do:

For each case, we can list the activities that are present and then check if they are in the correct order and if the step_index is increasing and covers 1 to 7? But we don't have step_index in the order_event_log? We computed it via the expected_steps CTE.

Revised plan:

1. For each case, get the list of activities that occurred, and the order of occurrence (by timestamp).
2. Map each activity to its expected step_index.
3. Check if the sequence of step_index (in the order of occurrence) is exactly [1,2,3,4,5,6,7].

We can do:

```sql
WITH activities_per_case AS (
    SELECT 
        case_id,
        activity,
        MIN(timestamp) AS first_timestamp,
        step_index,
        ROW_NUMBER() OVER (PARTITION BY case_id ORDER BY MIN(timestamp)) AS occurrence_order
    FROM (
        SELECT 
            case_id,
            activity,
            step_index,
            ROW_NUMBER() OVER (PARTITION BY case_id ORDER BY timestamp) AS event_order
        FROM order_event_log
        JOIN expected_steps USING (activity)
    ) AS events
    GROUP BY case_id, activity, step_index
),
sequence_per_case AS (
    SELECT 
        case_id,
        occurrence_order,
        step_index
    FROM activities_per_case
),
expected_sequence AS (
    SELECT 
        case_id,
        1 AS occurrence_order,
        1 AS step_index
    UNION ALL
    SELECT 
        case_id,
        2,
        2
    UNION ALL
    SELECT 
        case_id,
        3,
        3
    UNION ALL
    SELECT 
        case_id,
        4,
        4
    UNION ALL
    SELECT 
        case_id,
        5,
        5
    UNION ALL
    SELECT 
        case_id,
        6,
        6
    UNION ALL
    SELECT 
        case_id,
        7,
        7
),
compare_sequence AS (
    SELECT 
        spc.case_id,
        spc.occurrence_order,
        spc.step_index,
        es.step_index AS expected_step
    FROM sequence_per_case spc
    LEFT JOIN expected_sequence es 
        ON spc.case_id = es.case_id AND spc.occurrence_order = es.occurrence_order
)
SELECT 
    case_id,
    MIN(step_index) AS first_step,
    MAX(step_index) AS last_step,
    COUNT(*) AS total_events,
    ARRAY_AGG(step_index) AS actual_sequence,
    ARRAY_AGG(expected_step) AS expected_sequence
FROM compare_sequence
GROUP BY case_id;
```

This will show for each case if the actual sequence of step indices matches the expected [1,2,3,4,5,6,7].

But note: we are assuming that the events are recorded for all 7 steps. If not, then it will show gaps.

Now, let's run this for the provided examples:

**Case 1001:** 
   - step_index: 1,2,3,4,5,6,7 -> [1,2,3,4,5,6,7] -> matches.

**Case 1002:**
   - step_index: 1,4,5,2,3,6,7 -> [1,4,5,2,3,6,7] -> does not match.

**Case 1003:**
   - step_index: 1,2,5,6,7,4,3? -> Actually, let's see the events in order:
        activity: Register Order -> step_index=1
        activity: Perform Credit Check -> step_index=2
        activity: Ship Goods -> step_index=5
        activity: Issue Invoice -> step_index=6
        activity: Confirm Shipment -> step_index=4 -> but this happens after issue invoice? 
        So the sequence of step_index: 1,2,5,6,4 -> then we also have receive payment? No, the last event is receive payment? 
        But in the data we have for 1003: 
            Register Order (1), Perform Credit Check (2), Ship Goods (5), Issue Invoice (6), Confirm Shipment (4) -> wait, that doesn't make sense because step 4 (Confirm Shipment) should come before step 5 (Ship Goods). 
        Actually, the example data for 1003 has:
            1003: 
                15: Register Order -> step 1
                16: Perform Credit Check -> step 2
                17: Ship Goods -> step 5 (but should be step 4 first?)
                18: Issue Invoice -> step 6
                19: Confirm Shipment -> step 4 (this is after issue invoice? but should be before ship goods?)
                20: Receive Payment -> step 7
        So the occurrence order of step_index: 1,2,5,6,4,7 -> sequence [1,2,5,6,4,7] -> not [1,2,3,4,5,6,7].

**Case 1004:**
   - step_index: 1 (Register Order), then step 7 (Receive Payment) -> then step 6 (Issue Invoice), then step 4 (Confirm Shipment) -> then step5 (Ship Goods). 
        So sequence: 1,7,6,4,5 -> [1,7,6,4,5] -> not matching.

### Proposed SQL Queries

Given the complexity, we'll provide two queries:

1. Query to identify orders that do not follow the expected sequence of step indices.
2. Query to identify orders that are missing some steps.

We'll break it down:

#### Query 1: Find orders where the sequence of step indices does not follow 1,2,3,4,5,6,7 in consecutive order.

We can use the following query:

```sql
WITH expected_steps AS (
    SELECT 'Register Order' AS activity, 1 AS step_index
    UNION ALL SELECT 'Perform Credit Check'
    UNION ALL SELECT 'Validate Stock'
    UNION ALL SELECT 'Confirm Shipment'
    UNION ALL SELECT 'Ship Goods'
    UNION ALL SELECT 'Issue Invoice'
    UNION ALL SELECT 'Receive Payment'
),
activities AS (
    SELECT 
        oel.case_id,
        oel.activity,
        ests.step_index
    FROM order_event_log oel
    JOIN expected_steps ests ON oel.activity = ests.activity
),
sequence_with_order AS (
    SELECT 
        case_id,
        activity,
        step_index,
        ROW_NUMBER() OVER (PARTITION BY case_id ORDER BY timestamp) AS event_order
    FROM activities
),
sequence_per_case AS (
    SELECT 
        case_id,
        event_order,
        step_index
    FROM sequence_with_order
),
expected_per_case AS (
    SELECT 
        case_id,
        1 AS event_order,
        1 AS step_index
    UNION ALL SELECT case_id, 2, 2
    UNION ALL SELECT case_id, 3, 3
    UNION ALL SELECT case_id, 4, 4
    UNION ALL SELECT case_id, 5, 5
    UNION ALL SELECT case_id, 6, 6
    UNION ALL SELECT case_id, 7, 7
)
SELECT 
    spc.case_id,
    spc.event_order,
    spc.step_index AS actual_step,
    es.step_index AS expected_step,
    CASE WHEN spc.step_index = es.step_index THEN 'MATCH' ELSE 'MISSING' END AS status
FROM sequence_per_case spc
JOIN expected_per_case es 
    ON spc.case_id = es.case_id AND spc.event_order = es.event_order
ORDER BY spc.case_id, spc.event_order;
```

This will show for each event in the order of occurrence, whether it happened at the expected step and if it is missing a step.

But note: we are only considering events that are in the expected_steps. If an event is not in the expected_steps, it is not recorded? We are filtering to only expected activities.

We might also want to know which cases are missing entire groups of steps.

#### Query 2: Count of orders by the number of steps recorded.

```sql
SELECT 
    case_id,
    COUNT(DISTINCT activity) AS num_steps_recorded
FROM order_event_log
JOIN expected_steps USING (activity)
GROUP BY case_id
HAVING COUNT(DISTINCT activity) < 7
ORDER BY case_id;
```

This will show orders that are missing steps.

#### Query 3: Orders that have step indices not in increasing order.

We can check if the step_index is increasing with each event. We can do:

```sql
SELECT 
    case_id,
    activity,
    step_index,
    LAG(step_index) OVER (PARTITION BY case_id ORDER BY timestamp) AS prev_step_index
FROM activities
WHERE step_index > LAG(step_index) OVER (PARTITION BY case_id ORDER BY timestamp) 
   OR LAG(step_index) OVER (PARTITION BY case_id ORDER BY timestamp) IS NULL
```

But this might be too broad. Alternatively, we can flag when a step_index is less than the previous one.

```sql
SELECT 
    case_id,
    activity,
    timestamp,
    resource,
    step_index,
    LAG(step_index) OVER (PARTITION BY case_id ORDER BY timestamp) AS prev_step_index
FROM activities
WHERE step_index < LAG(step_index) OVER (PARTITION BY case_id ORDER BY timestamp)
```

This will show events that are out of order by step_index.

### Summary of Queries

We provide three queries:

1. **Query 1**: For each case, show each event and the expected step index and whether it matches the expected next step.
2. **Query 2**: List of orders that have fewer than 7 steps recorded.
3. **Query 3**: Orders that have events out of the expected step order (i.e., step_index decreasing).

These queries can help identify the anomalies.

Note: We are not using the `orders` and `resources` tables in these queries because the anomalies are in the event logs and the process flow is defined by the event log activities.

Let's write the queries accordingly.

### Final Queries

**Query 1: Show event sequence per case and if it matches the expected next step index.**

```sql
WITH expected_steps AS (
    SELECT 'Register Order' AS activity, 1 AS step_index
    UNION ALL SELECT 'Perform Credit Check'
    UNION ALL SELECT 'Validate Stock'
    UNION ALL SELECT 'Confirm Shipment'
    UNION ALL SELECT 'Ship Goods'
    UNION ALL SELECT 'Issue Invoice'
    UNION ALL SELECT 'Receive Payment'
),
activities AS (
    SELECT 
        oel.case_id,
        oel.activity,
        ests.step_index
    FROM order_event_log oel
    JOIN expected_steps ests ON oel.activity = ests.activity
),
sequence_with_order AS (
    SELECT 
        case_id,
        activity,
        step_index,
        ROW_NUMBER() OVER (PARTITION BY case_id ORDER BY timestamp) AS event_order
    FROM activities
),
expected_sequence AS (
    SELECT 
        case_id,
        1 AS event_order,
        1 AS step_index
    UNION ALL SELECT case_id, 2, 2
    UNION ALL SELECT case_id, 3, 3
    UNION ALL SELECT case_id, 4, 4
    UNION ALL SELECT case_id, 5, 5
    UNION ALL SELECT case_id, 6, 6
    UNION ALL SELECT case_id, 7, 7
)
SELECT 
    seq.case_id,
    seq.event_order,
    ests.activity,
    ests.step_index AS actual_step,
    es.step_index AS expected_step,
    CASE WHEN seq.step_index = es.step_index THEN 'MATCH' ELSE 'MISMATCH' END AS match_status
FROM sequence_with_order seq
JOIN expected_sequence es 
    ON seq.case_id = es.case_id AND seq.event_order = es.event_order
JOIN expected_steps ests 
    ON seq.activity = ests.activity
ORDER BY seq.case_id, seq.event_order;
```

**Query 2: Orders with fewer than 7 steps:**

```sql
SELECT case_id, COUNT(DISTINCT activity) AS step_count
FROM order_event_log
JOIN expected_steps USING (activity)
GROUP BY case_id
HAVING COUNT(DISTINCT activity) < 7;
```

**Query 3: Events that occur out of the expected step index order (i.e., step_index is not increasing):**

```sql
SELECT case_id, activity, timestamp, resource, step_index
FROM (
    SELECT 
        case_id,
        activity,
        timestamp,
        resource,
        step_index,
        ROW_NUMBER() OVER (PARTITION BY case_id ORDER BY timestamp) AS rn
    FROM order_event_log
    JOIN expected_steps USING (activity)
) ranked
WHERE rn > 1 
  AND step_index < LAG(step_index) OVER (PARTITION BY case_id ORDER BY timestamp)
ORDER BY case_id, timestamp;
```

These queries should help in investigating the anomalies.

</think>

Based on the event log data and process flow description, I've identified anomalies in the event sequences. Below are the detected issues, hypotheses, and SQL queries to investigate them:

### Detected Anomalies & Hypotheses
1. **Case 1002**
   - *Anomaly*: `Confirm Shipment` occurs before `Validate Stock` and `Perform Credit Check`
   - *Hypothesis*: Urgent shipping request by sales team bypassed standard validation steps due to manual override or system error

2. **Case 1003**
   - *Anomaly*: `Ship Goods` before `Confirm Shipment`, and `Confirm Shipment` after `Issue Invoice`
   - *Hypothesis*: Missing `Validate Stock` step and reordered shipment confirmation likely caused by skipped workflow steps or incorrect activity mapping

3. **Case 1004**
   - *Anomaly*: `Receive Payment` as first activity, `Confirm Shipment` with "not scheduled" flag, and missing `Validate Stock`
   - *Hypothesis*: Payment received before order processing completed, possibly due to partial order entry or system error

4. **General Pattern**
   - *Anomaly*: Inconsistent step sequences across cases (e.g., cases 1001 follows sequence, 1002-1004 show rearrangements)
   - *Hypothesis*: Possible system/process flaws like:
     - Inadequate validation steps for high-value orders
     - Manual overrides breaking workflow
     - Inconsistent activity-resource mappings
     - Incorrect event sequencing logic

### Investigation SQL Queries
```sql
-- 1. Find orders with non-standard event sequences
SELECT case_id, 
       JSON_OBJECTAGG(activity, timestamp) AS event_sequence
FROM order_event_log
JOIN expected_steps USING (activity)
GROUP BY case_id
HAVING JSON_PATH_MATCH('$."1".timestamp' <> '$[0].timestamp') OR
       JSON_PATH_MATCH('$."2".timestamp' <> '$[1].timestamp') OR
       JSON_PATH_MATCH('$."3".timestamp' <> '$[2].timestamp') OR
       JSON_PATH_MATCH('$."4".timestamp' <> '$[3].timestamp');

-- 2. Identify missing validation steps
SELECT case_id, COUNT(*) AS total_events, COUNT(DISTINCT activity) AS unique_activities
FROM order_event_log
GROUP BY case_id
HAVING COUNT(DISTINCT activity) < 7;  -- 7 expected activities

-- 3. Find resource-activity mismatches
SELECT resource_id, activity, COUNT(*)
FROM order_event_log
JOIN resources USING (resource)
WHERE resource_id NOT IN (
  SELECT resource FROM resources WHERE role = (
    SELECT role FROM resources r 
    JOIN expected_steps sts 
      ON sts.activity = order_event_log.activity
  )
)
GROUP BY resource_id, activity;

-- 4. Payment before processing steps
SELECT case_id, activity, timestamp
FROM order_event_log
WHERE activity IN ('Receive Payment', 'Register Order', 'Perform Credit Check', 'Validate Stock')
ORDER BY timestamp;

-- 5. Resource role-activity alignment
SELECT resources.resource_id, resources.role, order_event_log.activity
FROM order_event_log
JOIN resources USING (resource)
WHERE resources.role <> (
  SELECT role FROM resources r 
  JOIN expected_steps sts 
    ON sts.activity = order_event_log.activity
);
```

### Key Investigation Approaches
1. **Sequence Validation**  
   Compare actual event sequences against expected order using JSON path filtering

2. **Missing Step Detection**  
   Identify cases where the number of recorded activities is less than 7

3. **Resource-Activity Mismatch**  
   Find inconsistencies between assigned roles and activity executors

4. **Temporal Anomalies**  
   Detect payment processing before core order validation steps

5. **Process Integrity Check**  
   Verify resource roles align with expected activities

These queries enable drilling down into:
- Step reordering patterns
- Missing validation phases
- Resource role inconsistencies
- Payment processing anomalies
- Cross-case deviation patterns

The queries can be refined based on specific investigation outcomes, focusing on high-value orders or urgent cases showing multiple anomalies.

