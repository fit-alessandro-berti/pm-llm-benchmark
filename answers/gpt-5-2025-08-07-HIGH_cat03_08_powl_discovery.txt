Below is a compact POWL model that fits the event log. It captures:
- Strict sequence OR  MS  QS.
- Assembly with in-line checks: at least one AS; between two AS executions there must be one or more IQC (allows multiple IQC in a row); it is possible to exit after the first AS (no IQC at all).
- Testing with possible re-testing: TST followed by zero or more repetitions of (RT then TST).
- Packaging PK, then optional labeling LB (can be skipped), then DP and D.

Python-style construction (pm4py POWL objects)

from pm4py.objects.powl.obj import StrictPartialOrder, OperatorPOWL, Transition, SilentTransition
from pm4py.objects.process_tree.obj import Operator

# Transitions
OR  = Transition(label="OR")
MS  = Transition(label="MS")
QS  = Transition(label="QS")
AS  = Transition(label="AS")
IQC = Transition(label="IQC")
TST = Transition(label="TST")
RT  = Transition(label="RT")
PK  = Transition(label="PK")
LB  = Transition(label="LB")
DP  = Transition(label="DP")
D   = Transition(label="D")

# Silent transitions
tau_iqc_repeat = SilentTransition()  # to allow IQC to repeat 1+ times
tau_skip_lb    = SilentTransition()  # to allow skipping LB

# IQC+: one or more IQC
iqc_plus = OperatorPOWL(operator=Operator.LOOP, children=[IQC, tau_iqc_repeat])
# AS loop: AS, then optionally repeat cycles of (IQC+ then AS)
as_iqc_loop = OperatorPOWL(operator=Operator.LOOP, children=[AS, iqc_plus])

# Test loop: TST, then optionally repeat cycles of (RT then TST)
test_loop = OperatorPOWL(operator=Operator.LOOP, children=[TST, RT])

# Optional LB (skip allowed)
lb_optional = OperatorPOWL(operator=Operator.XOR, children=[LB, tau_skip_lb])

# Global partial order (sequential in this case)
root = StrictPartialOrder(nodes=[OR, MS, QS, as_iqc_loop, test_loop, PK, lb_optional, DP, D])
root.order.add_edge(OR, MS)
root.order.add_edge(MS, QS)
root.order.add_edge(QS, as_iqc_loop)
root.order.add_edge(as_iqc_loop, test_loop)
root.order.add_edge(test_loop, PK)
root.order.add_edge(PK, lb_optional)
root.order.add_edge(lb_optional, DP)
root.order.add_edge(DP, D)

Compact textual view

PO = (
  nodes = {
    OR, MS, QS,
    * ( AS, * ( IQC,  ) ),       # AS then [IQC]+ between AS cycles
    * ( TST, RT ),                # TST then optional repeats of (RT  TST)
    PK,
    X ( LB,  ),                  # optional LB
    DP, D
  },
  order = {
    ORMS, MSQS, QS* ( AS, * ( IQC,  ) ),
    * ( AS, * ( IQC,  ) )  * ( TST, RT ),
    * ( TST, RT )  PK, PK  X ( LB,  ),
    X ( LB,  )  DP, DP  D
  }
)

Notes
- The inner loop * (IQC, ) guarantees one or more IQC in a block (1, 2, 3, … times), enabling sequences like AS IQC IQC AS, etc.
- Exiting the outer AS loop immediately after the first AS covers cases with no IQC at all.
- The test loop * (TST, RT) yields TST, or TST RT TST, or TST RT TST RT TST, and so on.
- The XOR with  makes LB optional, matching cases where labeling is skipped.