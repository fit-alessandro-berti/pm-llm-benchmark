# DuckDB SQL: Filtering Cases by Sequence Pattern & Timing

## Strategy

The solution uses a three-layered CTE approach:

1. **`LEAD` window functions** to peek at the next two events per case (direct succession check)
2. **Pattern + timing filter** to identify offending cases
3. **`NOT IN` exclusion** to return only clean cases

## The Query

```sql
-- ============================================================
-- Step 1: Attach next two activities & their timestamps
--         to every event within each case (ordered by time)
-- ============================================================
WITH ordered_events AS (
    SELECT
        case_id,
        activity,
        timestamp,
        LEAD(activity, 1) OVER (
            PARTITION BY case_id ORDER BY timestamp
        ) AS next_activity,
        LEAD(activity, 2) OVER (
            PARTITION BY case_id ORDER BY timestamp
        ) AS next_next_activity,
        LEAD(timestamp, 1) OVER (
            PARTITION BY case_id ORDER BY timestamp
        ) AS next_timestamp,
        LEAD(timestamp, 2) OVER (
            PARTITION BY case_id ORDER BY timestamp
        ) AS next_next_timestamp
    FROM event_log
),

-- ============================================================
-- Step 2: Find cases containing the exact 3-step sequence
--         IN DIRECT SUCCESSION where the gap between
--         'Create Order' and 'Confirm Order' exceeds 5 days
-- ============================================================
cases_to_exclude AS (
    SELECT DISTINCT case_id
    FROM ordered_events
    WHERE
        -- ---- Sequence pattern (direct succession) ----
            activity           = 'Approve Purchase Requisition'
        AND next_activity      = 'Create Order'
        AND next_next_activity = 'Confirm Order'
        -- ---- Timing condition: CreateConfirm > 5 days ----
        AND next_next_timestamp - next_timestamp > INTERVAL 5 DAY
)

-- ============================================================
-- Step 3: Return ALL events EXCEPT those belonging to
--         the flagged cases
-- ============================================================
SELECT el.*
FROM event_log el
WHERE el.case_id NOT IN (
    SELECT case_id FROM cases_to_exclude
)
ORDER BY el.case_id, el.timestamp;
```

## How Each Requirement Is Met

| Requirement | Mechanism |
|---|---|
| **Direct succession** (no intervening events) | `LEAD(..., 1)` and `LEAD(..., 2)` within `PARTITION BY case_id ORDER BY timestamp` — these always reference the **immediately next** rows, so no gap is possible |
| **Exact activity sequence** | `WHERE activity = 'Approve Purchase Requisition' AND next_activity = 'Create Order' AND next_next_activity = 'Confirm Order'` |
| **> 5 days between Create Order  Confirm Order** | `next_next_timestamp - next_timestamp > INTERVAL 5 DAY` — here `next_timestamp` is the *Create Order* event and `next_next_timestamp` is the *Confirm Order* event |
| **Exclude matching cases entirely** | `NOT IN (SELECT case_id FROM cases_to_exclude)` removes **all** events of flagged cases |

## Key Design Decisions

- **`DISTINCT` in `cases_to_exclude`**: A case might contain the pattern multiple times; we only need the `case_id` once for exclusion.
- **`LEAD` vs. self-join**: `LEAD` is both cleaner and more performant — it avoids a three-way self-join and naturally enforces the *"no events in between"* constraint since it always looks at the immediate successor.
- **DuckDB's `INTERVAL` syntax**: `INTERVAL 5 DAY` is idiomatic DuckDB; timestamp arithmetic returns an interval that can be compared directly.