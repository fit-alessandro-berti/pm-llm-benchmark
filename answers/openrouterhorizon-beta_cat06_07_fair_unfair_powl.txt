Below are two POWL models that implement the described hiring process. The first includes the biased XOR branch; the second removes it so all applicants follow the same path.

Model 1: POWL with Potential Unfairness (XOR branch including CommunityAffiliationCheck)
- Activities:
  ReceiveApplication, DataCompletenessCheck, RequestMoreInfo, SkillAssessment, CulturalFitCheck, CommunityAffiliationCheck, ManagerialReview, FinalDecision
- Structure:
  1) A loop to ensure data completeness: execute DataCompletenessCheck; if incomplete, RequestMoreInfo then repeat; otherwise proceed.
  2) After the loop, execute SkillAssessment.
  3) XOR branch: either CulturalFitCheck (standard) or CommunityAffiliationCheck (biased uplift).
  4) ManagerialReview, then FinalDecision.

Python (pm4py POWL construction):

import pm4py
from pm4py.objects.powl.obj import StrictPartialOrder, OperatorPOWL, Transition, SilentTransition
from pm4py.objects.process_tree.obj import Operator

ReceiveApplication = Transition(label="ReceiveApplication")
DataCompletenessCheck = Transition(label="DataCompletenessCheck")
RequestMoreInfo = Transition(label="RequestMoreInfo")
SkillAssessment = Transition(label="SkillAssessment")
CulturalFitCheck = Transition(label="CulturalFitCheck")
CommunityAffiliationCheck = Transition(label="CommunityAffiliationCheck")
ManagerialReview = Transition(label="ManagerialReview")
FinalDecision = Transition(label="FinalDecision")

# Loop: DataCompletenessCheck then either exit or do RequestMoreInfo and repeat
completeness_loop = OperatorPOWL(operator=Operator.LOOP, children=[DataCompletenessCheck, RequestMoreInfo])

# XOR: either standard cultural fit or affiliation-based uplift (potentially unfair)
xor_culture = OperatorPOWL(operator=Operator.XOR, children=[CulturalFitCheck, CommunityAffiliationCheck])

# Partial order: ReceiveApplication -> completeness_loop -> SkillAssessment -> xor_culture -> ManagerialReview -> FinalDecision
root_unfair = StrictPartialOrder(nodes=[ReceiveApplication, completeness_loop, SkillAssessment, xor_culture, ManagerialReview, FinalDecision])
root_unfair.order.add_edge(ReceiveApplication, completeness_loop)
root_unfair.order.add_edge(completeness_loop, SkillAssessment)
root_unfair.order.add_edge(SkillAssessment, xor_culture)
root_unfair.order.add_edge(xor_culture, ManagerialReview)
root_unfair.order.add_edge(ManagerialReview, FinalDecision)


Model 2: POWL Without Unfairness (no community-based branch; everyone does the same CulturalFitCheck)
- Activities:
  ReceiveApplication, DataCompletenessCheck, RequestMoreInfo, SkillAssessment, CulturalFitCheck, ManagerialReview, FinalDecision
- Structure:
  1) Same data completeness loop.
  2) SkillAssessment.
  3) Single CulturalFitCheck (no XOR giving selective advantages).
  4) ManagerialReview, then FinalDecision.

Python (pm4py POWL construction):

import pm4py
from pm4py.objects.powl.obj import StrictPartialOrder, OperatorPOWL, Transition, SilentTransition
from pm4py.objects.process_tree.obj import Operator

ReceiveApplication2 = Transition(label="ReceiveApplication")
DataCompletenessCheck2 = Transition(label="DataCompletenessCheck")
RequestMoreInfo2 = Transition(label="RequestMoreInfo")
SkillAssessment2 = Transition(label="SkillAssessment")
CulturalFitCheck2 = Transition(label="CulturalFitCheck")
ManagerialReview2 = Transition(label="ManagerialReview")
FinalDecision2 = Transition(label="FinalDecision")

# Loop for completeness (same structure)
completeness_loop2 = OperatorPOWL(operator=Operator.LOOP, children=[DataCompletenessCheck2, RequestMoreInfo2])

# No XOR: everyone goes through CulturalFitCheck2
root_fair = StrictPartialOrder(nodes=[ReceiveApplication2, completeness_loop2, SkillAssessment2, CulturalFitCheck2, ManagerialReview2, FinalDecision2])
root_fair.order.add_edge(ReceiveApplication2, completeness_loop2)
root_fair.order.add_edge(completeness_loop2, SkillAssessment2)
root_fair.order.add_edge(SkillAssessment2, CulturalFitCheck2)
root_fair.order.add_edge(CulturalFitCheck2, ManagerialReview2)
root_fair.order.add_edge(ManagerialReview2, FinalDecision2)

Explanation of fairness difference:
- In Model 1, the XOR node introduces two alternative paths: CulturalFitCheck vs. CommunityAffiliationCheck. The latter implicitly boosts candidates with certain affiliations, creating potential unfairness.
- In Model 2, the XOR node is removed; all candidates undergo the same CulturalFitCheck, eliminating the affiliation-based advantage while preserving the loop for data completeness and the sequential order of remaining steps.