# DuckDB SQL Query for Process Variant Analysis

Here's a comprehensive solution that addresses all requirements:

```sql
WITH
-- Step 1: Get ordered activity sequences for each case
ordered_sequences AS (
    SELECT
        case_id,
        STRING_AGG(activity, ' > ' ORDER BY timestamp) AS activity_sequence
    FROM
        event_log
    GROUP BY
        case_id
),

-- Step 2: Count cases per variant and identify top K variants
variant_counts AS (
    SELECT
        activity_sequence,
        COUNT(*) AS case_count
    FROM
        ordered_sequences
    GROUP BY
        activity_sequence
),

-- Step 3: Get top K variants by frequency
top_variants AS (
    SELECT
        activity_sequence
    FROM
        variant_counts
    ORDER BY
        case_count DESC
    LIMIT 5  -- Change K as needed
),

-- Step 4: Get case_ids belonging to top variants
top_case_ids AS (
    SELECT
        o.case_id
    FROM
        ordered_sequences o
    JOIN
        top_variants t ON o.activity_sequence = t.activity_sequence
)

-- Final result: all events from top variant cases
SELECT
    e.*
FROM
    event_log e
WHERE
    e.case_id IN (SELECT case_id FROM top_case_ids)
ORDER BY
    e.case_id,
    e.timestamp;
```

## Explanation:

1. **Ordered Sequences**: The first CTE (`ordered_sequences`) creates the activity sequence for each case by concatenating activities in timestamp order using `STRING_AGG` with the `ORDER BY timestamp` clause.

2. **Variant Counting**: The second CTE (`variant_counts`) groups these sequences and counts how many cases share each unique sequence.

3. **Top K Variants**: The third CTE (`top_variants`) selects the most frequent variants by sorting by case count and limiting to the top K (I used 5 as an example - adjust as needed).

4. **Case Filtering**: The fourth CTE (`top_case_ids`) identifies which case_ids belong to these top variants.

5. **Final Result**: The main query returns all events from the original log that belong to cases in the top variants, maintaining the original order by case_id and timestamp.

## Notes:

- The `STRING_AGG` function concatenates activities with " > " between them to clearly show the sequence.
- For very large datasets, you might want to consider using a more efficient sequence representation (like a hash) instead of the string concatenation.
- The value of K (currently 5) should be adjusted based on your specific requirements.
- If you need to handle cases with missing timestamps or other edge cases, additional filtering would be needed.